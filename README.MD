--TO SEE YOUR ORACLE VERSION
--===========================
SELECT * FROM V$VERSION ;
--Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
--PL/SQL Release 11.2.0.1.0 - Production
--"CORE	11.2.0.1.0	Production"
--TNS for 64-bit Windows: Version 11.2.0.1.0 - Production
--NLSRTL Version 11.2.0.1.0 - Production
/
--DATA 
--======
--IT IS STORED REPRESENTATION OF INFORMATION WHICH HAS SOME MEANING.
--EX. PHONE NO., CUSTOMER INFORMATION IN BANK  ETC...
--DATA CAN BE   STRUCTURE WISE (STUDENT INFORMATION)
--              UN-STRUCTURE WISE (WHICH IS NOT UNDERSTANDABLE LIKE GEOGRAPHICAL DATA)
--              SEMI-STRUCTURE (COMBINATION OF STRUCTURE AND UN-STRUCTURE LIKE XML DATA (EXTENDED MARKUP LANGUAGE))
/
--META DATA
--===============
--IT DESCRIBES THE CHARACTERSTIC OF A DATA LIKE MARKSHEET, WITHDRAW FORM
--TO CREATE A META DATA WE REQUIRE :
--          DATA DEFINATION
--          SIZE OF DATA
--          VALUES ALLOWED
--META DATA DESIGNED BY DATA MODULER.
/
--
--CREATE TABLE
--============
--HERE WE CREATE A TABLE WITH DIFFERENT DATATYPE AND IN FORCEFULLY CASE WE TAKE ""
--1000 COLUMN ADD IN TABLE
--TABLE NAME SHOULD 30 CHARACTER LONG
--COLUMN NAME SHOULD 30 CHARACTER LONG
CREATE TABLE ABC (NAME VARCHAR2(20));
CREATE TABLE ABC2 (NAME VARCHAR2(20));
CREATE TABLE "ABC 2"(NAME VARCHAR2(1));
CREATE TABLE "ABC 2 TO 5" ("NAME AND DEMO" VARCHAR2(1));
CREATE TABLE DEMO_NEW ("1ST_COLUMN" VARCHAR2(20), "2ND_COLUMN" CHAR, "3RD_COLLUMN" NUMBER, "4TH_COLUMN" DATE);

--DESCRIBE A TABLE (DESC)
--=======================
--HERE DESCRIBE TABLE DETAILS LIKE THEIR COLUMN NAME WITH THEIR DATATYPE
DESC EMP;
DESC "ABC 2";

--INSERT RECORD IN A TABLE
--=========================
--HERE WE INSERT SOME VALUE IN EXISTING TABLE
INSERT INTO DEMO_NEW VALUES('NIEL', 'M', 7788882863, '26-OCT-1999');

--COMMIT
--=======
--SAVE THE DATA PERMANENET
COMMIT;

--DATA RETRIVE/SHOW FROM TABLE
--=============================
--HERE WE SHOW WHAT ARE THE VALUE INSIDE TABLE
SELECT * FROM DEMO_NEW;

--DICTIONARY TABLE
--================
--HERE WE IDENTIFY TABLE OR OBJECT INFORMATION

--USER TABLES
--============
--TABLE NAME, STATUS, NO OF ROWS
SELECT * FROM USER_TABLES;

--USER_OBJECTS
--=============
--OBJECT_NAME, OBJECT_TYPE, CREATED DATE, CREATED TIME(TIMESTAMP)
SELECT * FROM USER_TABLES;

--USER_TAB_COLUMNS
--================
--TABLE NAME, COLUMN NAME, DATA TYPE
SELECT * FROM USER_TAB_COLUMNS;

--NUMBER DATATYPE / INTEGER DATATYPE
--===================================
--147.44  147(PRESCION), 44(SCALE)
CREATE TABLE "CHECK1" (CHECK_DEMO NUMBER(4,2));
INSERT INTO CHECK1 VALUES(79.06);
INSERT INTO CHECK1 VALUES(85.066);
INSERT INTO CHECK1 VALUES(66.842);
SELECT * FROM CHECK1;--79.06  85.07 66.84
COMMIT;

--LONG DATATYPE
--===============
--HERE WE STORE ALPHA NUMERIC VALUE WITH  ONE LONG COLUMN
--2GB
CREATE TABLE LONG_TEST (DETAILS LONG);
INSERT INTO LONG_TEST VALUES('DBVHDFJKNJKSDFHKLJVFJKJJVHSDLFKJKSDFKLSDJF  J KLSDJFLJKJJHLHJU');
COMMIT;
SELECT * FROM LONG_TEST;

--DATE TIME DATATYPE
--===================
--DD-MON--YY
SELECT TO_DATE ('26-OCT-22') FROM DUAL;--26-OCT-22

--TIMESTAMP
--=========
--HH:MI:SS
SELECT SYSTIMESTAMP FROM DUAL ;--21-JUL-22 12.42.49.091000000 AM +05:30

--RAW DATATYPE
--=============
--WORK ONLY FOR JAVA DEVELOPER
--SHOW ONLY BINARY FORMAT
--2000 BYTE
--LENGTH IS MANDATORY
CREATE TABLE AWARD_SHOW2 (NAME VARCHAR2(10), CLIP RAW (1000));

--LONG RAW DATATYPE
--==================
--SIMILAR TO RAW 
--LENGTH 2GB
--NO NEED TO MENTION LENGTH
CREATE TABLE LRAW (NAME VARCHAR2(20), CLIP LONG RAW);

--LOB (LARGE OBJECT DATATYPE)
--============================
DIVIDED IN  1.BLOB
            2.CLOB
            3.NCLOB
            
--BLOB DATATYPE
--==============
--USED  TO STORE IMAGE , VIDEO, THUMB IMPRESSION, GEOGRAPHICAL DATA
--LENGTH SIZE 4GB
--NOT REQUIRE TO MENTION LENGTH
CREATE TABLE "BLOB TEST" (NAME VARCHAR2 (11), MEDIA BLOB);

--CLOB DATATYPE
--==============
--USED TO STORE HUGE AMOUNT OF CHARACTER DATA
--TAKE 'N' NO. OF CLOB COLUMNS
--LENGTH 4GB
--LENGTH NOT REQUIRED
CREATE TABLE "CLOB TEST" (NO NUMBER, GROUP_NAME VARCHAR2(20), MEMEBERS CLOB, REVIEW CLOB);
INSERT INTO "CLOB TEST" VALUES (1, 'PRINCE DANCE GROUP', 'THEY HAVE 30 MEMBERS IN A GROUP',
    'THEY ARE  VERY EXICITED TO DANCE IN GIST');

--NCLOB DATATYPE
--===============
--IT STORES UNI-CODE DATA USING NATIONAL CHARACTER SET
--USING FOR ANOTHER LANGUAGE LIKE JAPANESE, SAUDI ARABIC

--SELECT 
--=======
--THROUGH SELECT WE PULL DATA FROM A OBJECT.
SELECT ENAME FROM EMP;

--FROM
--=====
--WHICH OBJECT WE PULL DATA THERE USED FROM CLAUSE 
SELECT * FROM EMP ;

--DUAL
--=====
--THIS ONE IS BUILT IN TABLE
--COLUMN NAME IS DUMMY
--DATATYPE IS VARCHAR2(1)
SELECT 'HII' FROM DUAL;
SELECT 'HI', 'NIEL' FROM DUAL;

--ALIAS NAME
--==========
--DIVIDED INTO 2 PARTS    1.COLUMN ALIAS
--                        2. TABLE ALIAS
--1.COLUMN ALIAS
--==============
--THIS IS USED TO GIVE ALTERNATIVE NAME OF A COLUMN
--FORCEFULLY WE CAN TAKE "   "
--ALIAS NAME CAN'T TAKE AT WHERE CONDITION

SELECT ENAME AS NAME FROM EMP;--AT COLUMN NAME WE SEE THE ALIAS NAME 

SELECT ENAME NAME FROM EMP;
--AS OPTIONALLY.

--2.TABLE ALIAS
--==============
SELECT E. ENAME , E.SAL , E.JOB FROM EMP E;
--HERE AS NOT REQUIRED .

--COMMENT
--========
--WE CAN HIDE A PARTICULAR SYNTAX USING --, /*  */
SELECT ENAME --AS NAME OF ALL EMP
    FROM EMP;
SELECT ENAME, /*COMM*/  SAL  FROM EMP;

--WHERE CONDITION 
--==================
--IT IS USED TO FILTER SOME DATA FROMM OBJECT

--ARITHMATIC OPERATION
--=====================
--WE CAN USE ARITHMATIC OPERATION IN SQL STATEMENT.
--THIS OPERATION CAN BE USED IN SELECT STATEMENT & WHERE CONDITION.
--IT FOLLOWS BODMAS RULE.

SELECT 1+2 AS ADDITION FROM DUAL;--3

SELECT 1+2 AS ADDITION, 2*3 AS MULTIPLICATION, 10/2 AS DIVISION, 10-2 AS SUBSTRACT FROM DUAL;

SELECT 1+2 AS ADDITION, 2*3 AS MULTIPLICATION, 10/2 AS DIVISION, 10-2 AS SUBSTRACT FROM EMP;
--SAME ARITHMATIC OPERATION BUT RECORD WILL BE 14.

SELECT EMPNO, ENAME, SAL, SAL+100  FROM EMP;

SELECT EMPNO, ENAME, SAL,SAL*EMPNO FROM EMP;

SELECT EMPNO, ENAME, SAL, SAL*12+100 FROM EMP;

SELECT EMPNO, ENAME, SAL, DEPTNO, (SAL*12),(100*DEPTNO),(SAL*12)+(100*DEPTNO)FROM EMP;

SELECT EMPNO, ENAME, SAL, DEPTNO, SAL*12+100*DEPTNO FROM EMP;

SELECT EMPNO, ENAME, SAL, SAL*12+100 AS "FIRST COLUMN", SAL*(12+100)AS SECOND_COLUMN FROM EMP;

SELECT EMPNO, ENAME, SAL, SAL*12+100 , SAL*5*5+100+300  FROM EMP;

SELECT EMPNO, ENAME, SAL, SAL*12+100 FROM EMP WHERE SAL*12+500-400= 9700;
--HERE WE USED WHERE CONDITION IN ARITMATIC OPERATION.

SELECT * FROM EMP WHERE (10*2/2-9)=1;
--CONDITION CHECK USING ARITHMATIC.

SELECT SYSDATE+1 AS TOMMOROW_DATE FROM DUAL;

SELECT SYSTIMESTAMP +1 AS TOMMOROW_DATE FROM DUAL;

SELECT HIREDATE , HIREDATE+1 AS SECOND_DAY FROM EMP;

SELECT HIREDATE, HIREDATE+1 AS "2ND DAY", HIREDATE +2 "3RD DAY" FROM EMP;
--========================================================================================================
--========================================================================================================
--NULL VALUE
--============
--NULL IS A UNDEFINED VALUE
--ABSENCE OF DATA
--  <> TO 0
--WE CAN'T ANY PERFORM WITH NULL
--IT REPRESENTS WITH NULL KEYWORD

SELECT * FROM EMP WHERE COMM IS NULL;
--WHERE COMM IS NULL ONLY THOSE RECORD WILL BE DISPLAY .

SELECT ENAME, JOB, SAL FROM EMP WHERE COMM IS NULL;

SELECT * FROM DEMO_ANIL;

INSERT INTO DEMO_ANIL VALUES (41, 'MO ICHA',NULL);
INSERT INTO DEMO_ANIL VALUES (41, '__',NULL);

SELECT COMM , COMM+100 AS COMMISION FROM EMP;

SELECT ENAME, JOB, SAL, COMM, SAL+100*COMM AS INCREMEN FROM EMP;

SELECT EMPNO, ENAME, JOB , HIREDATE, SAL, COMM, DEPTNO, SAL*2/4*15-5+DEPTNO
        AS VALUESS FROM EMP;  
--====================================================================================================
--====================================================================================================
--NVL
--======
--IT IS USED TO CONVERT NON VALUE TO ACTUAL VALUE
--SINGLE ROW FUNCTION
--2 ARGUMENT,
    --1ST, EXPRESSION OR COLUMN WHICH CONTAIN NULL VALUE
    --2ND, TARGET VALUE WHICH WILL CONVERT A NULL TO ACTUAL VALUE
--IF 1ST ARGUMENT IS NOT NULL THEN IT WILL SHOW THE 1ST ARGUMENT
--2 ARGUMENT ARE MANDATORY.

SELECT NVL(COMM) FROM EMP;--ERROR
--NVL FUNCTION HAVE MANDATORY 2 ARGUMENT .

SELECT EMPNO, ENAME, COMM, NVL(COMM,500) AS NEW FROM EMP;
--WHERE COMM NULL ONLY THOSE VALUES DISPLAY 500 .
--WHICH COMM ARE NOT NULL SAME VALUES WILL BE DISPLAY AS TABLE INSERT.

SELECT EMPNO, ENAME, SAL, COMM, SAL+COMM, SAL + NVL(COMM,0) , 
        NVL (SAL,0)+NVL (COMM,0), SAL+NVL(COMM,0)+100
        FROM EMP;
--HERE WE USE MULTIPLE NVL FUNCTION .

SELECT NULL, 'ABC', NVL (NULL , 'ABC')FROM DUAL;

SELECT NVL(SAL, EMPNO) FROM EMP;
--ALL SAL DETAILS ONLY. COZ ANY SAL HAVE NOT NULL .

SELECT 'DEMO FOR NVL' AS DEMO, 'ABC', NVL ('NIEL' , 'NEEK')FROM DUAL;

SELECT HIREDATE, NVL (NULL, SYSDATE) FROM EMP;

SELECT ID, NAME, DOJ, NVL( NAME , 'LOVELY')AS "NAME LIST", NVL(DOJ,SYSDATE) AS "DATE" FROM DEMO_NIEL;

SELECT EMPNO, ENAME, SAL, COMM, SAL+NVL(COMM,100+200) FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM,  NVL(NVL(COMM,0),100) FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM,  NVL(COMM,sal +100) FROM EMP;
/
--NVL2
--======
--IT IS USED TO CONVERT A NOT NULL AND NULL VALUE TO ACTUAL VALUE
--3 ARGUMENT
    --1ST, VALUE(NULL, NOT NULL)
    --2ND, IF 1ST ARGUMENT IS NOT NULL IT WILL SHOW THE 2ND ARGUMENT
    --3RD, IF 1ST ARGUMENT IS NULL , IT WILL SHOW THE 3RD ARGUMENT
--2nd AND 3rd ARGUMENT ARE BOYH EQUAL DATATYPE.
--IF 2nd ARGUMENT IS CHARACTER THEN , IT CAN WORK WITH ANY DATATYPE.
--3 ARGUMENT ARE COMPULSARY

SELECT NVL2(COMM, 100)  FROM EMP;--ERROR
--INVALID NO OF ARGUMENT.
SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, 300,200)+SAL FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, SAL+300,SAL+200) FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, SAL+100,SAL+NVL(COMM,100)) FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, SAL+500+COMM, SAL+NVL(COMM,500)) FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, SAL+COMM,SAL+200) FROM EMP;

SELECT ENAME, SAL, COMM, NVL2(COMM, 'KYA RE BABA', 500) FROM EMP;

SELECT ENAME, SAL, COMM, NVL2(COMM, 'SAL_COMM', 'SAL') AS INCOME FROM EMP WHERE DEPTNO IN (10,30);

SELECT COMM, NVL2(COMM, 123, 123) FROM EMP;

SELECT COMM, NVL2(COMM, NULL, 123) FROM EMP;

SELECT COMM, NVL2(COMM, NULL, NULL) FROM EMP;

SELECT COMM, NVL2(COMM, 100, -123) FROM EMP;

--Q. DISPLAY  EMPLOYEE INFORMATION LIKE EMPNO, ENAME, SAL AS BASIC SALARY, SAL*.12 "PF", SAL*.15 "HRA", 
--    SAL*.10 "DA", SAL*.5 "TA", MONTHLY PACKAGE, QUATERLY PACKAGE, HALF YEARLY PACKAGE, ANNUAL PACKAGE LPA?
--=========================================================================================================
SELECT EMPNO, ENAME,COMM, SAL AS "BASIC SALARY", SAL* .12 AS PF, SAL* .15 AS HRA, SAL* .10 AS DA,
        SAL* .5 AS TA, 
        (SAL+ NVL(COMM, 0)+ SAL* .12 + SAL* .15 + SAL* .10 + SAL* .5 )  AS "MONTHLY EMPLOYEE PACKAGE",
        (SAL+ NVL(COMM, 0)+ SAL* .12 + SAL* .15 + SAL* .10 + SAL* .5 ) * 3 AS "QUATERLY EMPLOYEE PACKAGE",
        (SAL+ NVL(COMM, 0)+ SAL* .12 + SAL* .15 + SAL* .10 + SAL* .5 ) * 6 AS "HALF YEARLY EMPLOYEE PACKAGE",
  (SAL+ NVL(COMM, 0)+ SAL* .12 + SAL* .15 + SAL* .10 + SAL* .5 ) * 12   || 'LPA' AS "ANNUAL EMPLOYEE PACKAGE"
          FROM EMP;

--NULL IF 
--========
--SINGLE ROW FUNCTION
--USED TO COMPARE A COLUMN OR EXPRESSION
--2 ARGUMENT (COMPULSARY) 
--IF BOTH ARE EQUAL THEN OP IS NULL
--IF BOTH ARE NOT EQUAL THEN IT WILL SHOW THE 1ST ARGUMENT
--DATATYPE SHOULD MATCH
SELECT NULLIF(100) FROM DUAL;--ERROR
--INVALID NO. OF ARGUMENT.

SELECT NULLIF(100, 200) FROM DUAL;--100
--HERE BOTH ARE NOT EQUAL SO DISPLAY 1ST ARG..

SELECT NULLIF ('A', 'A') FROM DUAL;--NULL
--HERE BOTH ARG. ARE SAME SO IN O/P IT DISPLAY NULL.

SELECT NULLIF('A', 100)FROM DUAL;--ERROR   
--DATATYPE ARE MISMATCH.

SELECT NULLIF('A', 'Z')FROM DUAL;--A

SELECT NULLIF (NULL, NULL) FROM DUAL; --ERROR   
--CAUSE DATATYPE ARE NOT MATCH (NULL <> NULL)

SELECT ENAME, JOB, NULLIF(ENAME, JOB) FROM EMP;
--ALL "ENAME" CAUSE 'ENAME AND JOB ARE NOT MATCHED SO SHOW THE 1ST ARGUMENT.

SELECT NULLIF ( 'HD', 44) FROM DUAL;--ERROR
--DATA TYPE NOT MATCH
/
--COALESCE FUNCTION
--==================
--SINGLE ROW FUNCION
--ACCEPT N NO. OF ARGUMENT
--RETURNS 1ST NOT NULL EXPRESSION
--DATATYPE SHOULD MATCH

SELECT COALESCE (NULL, NULL, 100,200, 300) FROM DUAL;--100

SELECT COALESCE (10, NULL, 50,40) FROM DUAL;--10

SELECT COALESCE (500, NULL, NULL, 100,200,30) FROM DUAL;--500

SELECT COALESCE (500, NULL, 'ABC') FROM DUAL;--ERROR 
--CAUSE THE DATATYPE ARE SHOULD NOT MATCH

SELECT COALESCE (NULL, 100, NULL, 25000) FROM DUAL;--100

SELECT COALESCE (200,100,300, 250000) FROM DUAL;--200

SELECT COALESCE (NULL, 0,10,20) FROM DUAL;
--0 (0 HAVE UNIQUE VALUE)

SELECT COMM, SAL, COALESCE (COMM, SAL, 10) NEW FROM EMP;
--WHERE IN COMM IS NULL THEN IT SHOW SAL VALUE AND WHERE COMM VALUE IS NOT NULL THEN IT WILL SHOW THE
--                              COMM VALUE
      
SELECT COMM, SAL, COALESCE (10,COMM, SAL, 10) FROM EMP;--10

SELECT COALESCE (NULL, NULL) FROM DUAL;--NULL
/

--CONCATENATION OPERATOR / CONCAT OPERATOR
--=========================================
--USED TO MERGE N NO. OF EXPRESSION
--IT REPRESENT BY TWO VERTICAL BAR (  ||  ).
--NO DATATYPE RESTRICTION.

SELECT ' HII THIS IS NIEL ' || 'AND I AM FROM BERHAMPUR' AS "NIEL DEMO PRACTICE"  FROM DUAL;

SELECT ' HII THIS IS NIEL ' || 'AND I AM FROM BERHAMPUR' || 'AND MY NO IS 7788882863' 
          AS "NIEL DEMO PRACTICE"  FROM DUAL;

SELECT 'THE BASIC SALARY OF EMPLOYEE ' || ENAME || 'IS :- ' || SAL FROM EMP;

SELECT 'THE BASIC SALARY OF EMPLOYEE ' || ENAME || 'IS :- ' || SAL FROM EMP WHERE SAL =  800;

SELECT 'THE BASIC SALARY OF EMPLOYEE ' || ENAME  || ' IS :- ' || SAL FROM EMP WHERE ENAME =  'KING';

SELECT ENAME, JOB, ENAME  || ' ' || JOB FROM EMP;

SELECT ENAME || ' : '|| 'MONTHLY SALARY= ' || SAL AS SALARY FROM EMP;

SELECT 'THE DESIGNATION OF ' || ENAME || ' IS ' || JOB AS DESIGNATION FROM EMP;

SELECT ENAME || ' : ' || 'MONTHLY SALARY = ' || (SAL +NVL(COMM, 0)+500) AS SALARY FROM EMP;
/

--DISTINCT KEYWORD / UNIQUE KEYWORD
--==================================
--USED TO REMOVE DUPLICATE ROWS IN A COLUMN
--IF WE PROVIDE MULTIPLE COLUMN WITH DISTINCT , THEN IT CHECKS EACH COLUMN VALUES , IF IT IS SATISFY 
--             DISPLAY ACCORDINGLY.

SELECT DISTINCT (COMM), (DEPTNO) FROM EMP;
--HERE 1st LOOK COMM WHERE COMM DUPLICATE VALUE IS THERE IT GO TO DEPTNO.
--AND DISPLAY ACCORDINGLY .

SELECT DISTINCT(20,20,10,587) FROM DUAL;--ERROR,  
--WE CAN'T TAKE MULTIPLE VALUES AT A TIME IN DISTINCT KEYWORD.

SELECT DISTINCT DEPTNO FROM EMP;

SELECT DISTINCT JOB, DEPTNO FROM EMP;

SELECT UNIQUE JOB FROM EMP;

SELECT DISTINCT JOB, EMPNO FROM EMP;
--HERE ALL RECORDS WILL BE DISPLAY COZ, ALL EMPNO ARE UNIQUE.

SELECT DISTINCT  DEPTNO, JOB FROM EMP;

SELECT DISTINCT(JOB) FROM EMP;
-- HERE WE GET UNIQUE JOB IN EMP TABLE

SELECT DISTINCT DEPTNO FROM EMP;
-- SHOW ONLY UNIQUE DEPTNO NOT DUPLICATE

SELECT DISTINCT EMPNO FROM EMP;
-- SHOW ALL  EMPNO BCOZ EMPNO ARE ALWAYS UNIQUE 

SELECT DISTINCT JOB, DEPTNO FROM EMP;
-- SHOW JOB , DEPTNO WHICH ARE UNIQUE NOT DUPLICATE

SELECT DISTINCT JOB, EMPNO FROM EMP;
-- HERE SHOW ALL VALUE OF EMP BECOZ ALL EMPNO ARE UNIQUE

SELECT DISTINCT JOB, DEPTNO, EMPNO FROM EMP;
-- HERE SHOW ALL VALUE OF EMP BECOZ ALL EMPNO ARE UNIQUE
/
--RELATIONAL OPERATOR  /  COMAPARISON OPERATOR
--=============================================
--EQUAL OPERATOR  =
--NOT EQUAL OPERATOR  <>, ^=, !=
--GREATER THAN OPERATOR   >
--GREATER THAN EQUAL OPERATOR   >=
--SMALLER THAN OPERATOR   <
--SMALLER THAN EQUAL OPERATOR   <=
--IN OPERATOR   (USE FOR MULTIPLE VALUE)
--IS OPERATOR   (USE FOR ONLY NULL VALUE).

SELECT * FROM EMP WHERE EMPNO = 7839;

SELECT * FROM EMP WHERE EMPNO <> 7839;

SELECT * FROM EMP WHERE EMPNO != 7839;

SELECT * FROM EMP WHERE EMPNO ^= 7839;

SELECT * FROM EMP WHERE DEPTNO > 10;

SELECT * FROM EMP WHERE DEPTNO >= 10;

SELECT ENAME FROM EMP WHERE DEPTNO <> 10;

SELECT * FROM EMP WHERE DEPTNO < 30;

SELECT * FROM EMP WHERE DEPTNO <= 30;

SELECT * FROM EMP WHERE DEPTNO IN (10, 20);

SELECT * FROM EMP WHERE COMM IS NULL ;
/
--LOGICAL OPERATOR 
--=================
--AND OPERATOR 
--=============
--AND OPERATOR ALLOW TO CREATE STATEMENT BASED ON 2 OR MORE CONDITION.
--IF ONE CONITION IS FAILED THEN ENTIRE DATA WILL BE DISPLAY BLANK.
--HERE COLUMN SHOULD BE DIFFERENT .
--    T = T = T
--    F = T = F
--    T = F = F
--    F = F = F

SELECT * FROM EMP WHERE DEPTNO = 10 AND SAL = 5000 AND JOB = 'PRESIDENT'; 
--- ALL CONDITION TRUE SO SHOW THE OP.

SELECT * FROM EMP WHERE DEPTNO = 10 AND SAL = 5000 AND JOB = 'CLERK'; 
--- ALL CONDITION ARE NOT TRUE AND DOESN'T MATCH EACH OTHER SO HERE NO OP

SELECT ENAME FROM EMP WHERE EMPNO = 7934 AND MGR = 7782 AND HIREDATE = '23-JAN-82';
---- ALL CONDITION ARE TRUE AND MATCHED EACH OTHER SO SHOW THE ENAME.
/
--OR OPERATOR
--============
--AND OPERATOR ALLOW TO CREATE STATEMENT BASED ON 2 OR MORE CONDITION.
--IF BOTH CONDITION ARE FALSE THEN IT WILL BE FALSE OTHERWISE TRUE.
--    T = T = T
--    T = F = T
--    F = T = T
--    F = F = F

SELECT * FROM EMP;

SELECT * FROM EMP WHERE DEPTNO = 10 AND SAL = 5000 OR JOB = 'SALESMAN';

SELECT * FROM EMP WHERE DEPTNO = 10 AND SAL = 5500 OR JOB = 'SALESMAN';
--- HERE WE GET ONLY SALESMAN DETAIL BCOZ THE 1ST ARGUMENT ARE NOT SATISFIED

SELECT * FROM EMP WHERE DEPTNO = 10 AND (SAL = 5000 OR JOB = 'SALESMAN'); 
-- 1ST ARGUMENT IS FILTER WHERE DEPTNO IS 10
-- 2ND IS SHOW WHERE SAL IS 5000 AND JOB SALESMAN
-- HERE USING AND OPERATION SO ONLY KING EMPNAME ARE SATISFIED .

SELECT * FROM EMP WHERE DEPTNO = 10 AND (SAL = 1250 OR JOB = 'SALESMAN');
--- HERE WE NOTHING GET COZ THE ARGUMENT ARE NOT SATISFIED

SELECT * FROM EMP WHERE SAL = 1250 OR JOB = 'SALESMAN';
-- HERE WE GET WHICH EMP SAL IS 1250 AND WHICH JOB ARE SALESMAN TOO.

SELECT * FROM EMP WHERE DEPTNO = 30 AND (SAL = 1250 OR JOB = 'SALESMAN');
-- HERE WE GET WHICH ONE IS DEPTNO IS 30 AND SAL IS 1250 AND REST ALL SALESMAN ARE ALSO SHOW

SELECT * FROM EMP WHERE DEPTNO = 10 OR SAL = 1250 OR JOB = 'SALESMAN';

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE SAL > 2000 OR DEPTNO =20;

SELECT EMPNO, ENAME, SAL , DEPTNO, JOB FROM EMP WHERE SAL > 2000 OR DEPTNO = 20 OR JOB = 'SALESMAN';

SELECT * FROM EMP WHERE SAL = 800 ;

SELECT * FROM EMP WHERE SAL IN(3000, 800) ;

SELECT * FROM EMP WHERE SAL IN (8000, 3000,1250,5000,5500,1100);

SELECT * FROM EMP WHERE COMM IN (NULL, 1400);
--1400

SELECT * FROM EMP WHERE COMM IS NULL OR COMM = 1400;

SELECT * FROM EMP WHERE ENAME = 'KING' AND ENAME = 'SCOTT';
---NOTHING TO SHOW COZ IN 'AND' OPERATOR WE CANT TAKE SAME COLUMN 2 TIME.

SELECT * FROM EMP WHERE (DEPTNO = 10 AND SAL = 5000) OR (DEPTNO = 30 AND JOB = 'SALESMAN') ;

SELECT * FROM EMP WHERE (DEPTNO = 10 AND SAL = 5000) OR (DEPTNO = 30 AND JOB = 'SALESMAN')AND COMM IS NULL ;
--ONLY KING RECORD .
/
--NOT OPERATOR
--=============
--THIS IS A LOGICAL OPERATOR WHICH IS USED TO CHECK MULTIPLE VALUES.
--WE CAN USE ALSO NOT IN , NOT LIKE.
--IT WORKS LIKE OPPOSITE VALUES CHECK.

SELECT * FROM EMP WHERE DEPTNO NOT IN (10, 20) AND JOB ='MANAGER';

SELECT * FROM EMP WHERE DEPTNO NOT IN ( 20, 30) AND JOB ='MANAGER';

SELECT * FROM EMP WHERE ENAME NOT IN 'KING'; 

SELECT * FROM EMP WHERE DEPTNO  NOT  LIKE  20 ;

SELECT * FROM EMP WHERE DEPTNO NOT IN (10, 20) OR JOB ='ANALYST';
/
--BETWEEN OPERATOR
--=================
--IT IS USED TO DISPLAY ROW BASED ON RANGED VALUES .
--THIS RANGE CAN BE NUMBER , DATE, CHARACTER.
--ALWAYS BETWEEN OPERATOR SPECIFY SMALLEST TO GREATEST.

SELECT * FROM EMP WHERE SAL BETWEEN 1000 AND 3000 ;

SELECT * FROM EMP WHERE SAL BETWEEN 3000 AND 1000;--ERROR
-- IT CANT DISPLAY

SELECT * FROM EMP WHERE SAL NOT BETWEEN 1000 AND 3000;

SELECT ENAME, JOB , HIREDATE , SAL FROM EMP WHERE HIREDATE BETWEEN '01-JAN-1110' AND  '20-FEB-2021';

SELECT * FROM EMP WHERE SAL NOT BETWEEN 1100  AND 3000;

SELECT * FROM EMP WHERE (DEPTNO =10 OR DEPTNO = 30) AND SAL  BETWEEN  2000 AND 5000;

SELECT * FROM EMP WHERE SAL >= 1000 AND SAL <= 3000;

CREATE TABLE "TEST BETWEEN"(NAME VARCHAR2 (10));
INSERT INTO "TEST BETWEEN" VALUES ('A');
INSERT INTO "TEST BETWEEN" VALUES ('B');
INSERT INTO "TEST BETWEEN" VALUES ('C');
INSERT INTO "TEST BETWEEN" VALUES ('D');

SELECT * FROM "TEST BETWEEN" WHERE NAME BETWEEN 'A' AND 'C';

SELECT  * FROM EMP WHERE ENAME BETWEEN 'MARTIN' AND 'WARD';
/
--LIKE OPERATOR
--==============
--USING LIKE OPERATOR WE CAN SEARCH A PARTICULAR VALUE OR GROUP OF COLUMN VALUE IN TABLE.
--IN LIKE OPERATOR WE CAN 2 WILD CHARACTER THAT IS  1. % (PERCENTAGE)(ANY CHARACTER)
--                                                  2. _ (UNDERSCORE)(SINGLE CHARACTER)
--WE CAN SEARCH COLUMN VALUES USING LIKE OPERATOR.
--IF WE SEARCH WITH SPECIAL CHARACTER + WILD CHARACTER ALONG WITH ESCAPE.

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE 'S';  
-- HERE O/P NOT SHOW COZ HERE NO ENAME IS ONLY S.

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE 'SMITH';

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME = 'SMITH';
--- WE CAN ALSO SEARCH THIS TYPE FOR PARTICULAR VALUE

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE 'S%';
-- HERE WE CAN SHOW ONLY WHICH ENAME IS STARTING FROM S LETTER .

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE '%S';
-- HERE WE CAN SEE WHICH ENAME ARE END WITH S LETTER

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE '____';
-- HERE WE SEE WHICH ENAME ARE 4 LETTER WORD

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE 'WAR%';
-- HERE WE SEE WHICH ENAME START WITH WAR

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE '%D%';
-- HERE WE SEE WHICH ENAME BETWEEN D LETTER AVAILABLE

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE '%A%';

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME LIKE '%LL%';

SELECT * FROM EMP WHERE EMPNO LIKE '7%';

SELECT * FROM EMP WHERE EMPNO LIKE '_9%'; --HERE WE SEE WHICH EMPNO ARE START AFTER ONE NUMBER IS 9

SELECT * FROM EMP WHERE EMPNO LIKE '_9%' AND JOB LIKE 'C%';
--MULIPLE LIKE OPERATOR USED HERE .

SELECT * FROM EMP WHERE ENAME LIKE 'C%' AND JOB LIKE 'MANAGER';

SELECT * FROM EMP WHERE ENAME LIKE 'C%' OR JOB = 'MANAGER';

SELECT ENAME, EMPNO, SAL FROM EMP WHERE ENAME LIKE 'M%';

SELECT ENAME, EMPNO, SAL FROM EMP WHERE ENAME NOT LIKE 'M%';

SELECT * FROM  EMP WHERE ENAME LIKE '____';
--WHICH ENAME ARE 4 LETTER

SELECT * FROM  EMP WHERE ENAME LIKE '%C__T%';

SELECT * FROM  EMP WHERE HIREDATE LIKE '%80%';

SELECT * FROM  EMP WHERE HIREDATE LIKE '%DEC%';

CREATE TABLE EXPORT_TABLE(STD_ID NUMBER, STD_NAME VARCHAR2(20));
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (3,'MAH*SH');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (1,'AMIT');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (2,'SURESH%');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (2,'SURESH');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (3,'ASISH_');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (4,'SA_I');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (4,'MANO_J');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (7,'SAROJ');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (8,'BH%G_BAN');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (9,'BH_G%BAN');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (8,'MU%KESH');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (9,'_HI');
Insert into EXPORT_TABLE (STD_ID,STD_NAME) values (6,'MANO_J');

SELECT * FROM EXPORT_TABLE;

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'SUR%';
--    SURESH%
--    SURESH

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'SUR%!%' ESCAPE '!';
--SURESH%

INSERT INTO EXPORT_TABLE VALUES (3, 'MAHE*SH');

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'MAH%';
--      MAH*SH
--      MAHE*SH
--      MAHE*SH

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'SA!_%' ESCAPE '!';
--      SA_I
SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'MANO!_%' ESCAPE '!';
--      MANO_J
--      MANO_J

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'SUR%!%' ESCAPE '!';
--      SURESH%

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'BH!_%' ESCAPE '!';
--BH_G%BAN

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'BH!%%!_%' ESCAPE '!';
--OR
SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE 'BH!%_%' ESCAPE '!';
--BH%G_BAN

SELECT * FROM EMP WHERE ENAME NOT LIKE 'S%' OR ENAME LIKE 'A%';

SELECT * FROM EXPORT_TABLE WHERE STD_NAME LIKE '_H_';

--ORDER BY CLAUSE
--================
--THIS IS USED TO SORTING THE ROWS.
--THIS CLAUSE ALWAYS SPECIFY AT LAST IN STATEMENT.
--DEFAULT ORDER IS ASC.
--IN ASC NULL ALWAYS DISPLAY LAST , BUT IN DESC NULL ALWAYS DISPLAY FIRST.
--IT GIVES PRIORITY 1ST NUMBER , UPPER LETTER, LOWER LETTER , NULL (ASC)

SELECT * FROM EMP ORDER BY ENAME;

SELECT * FROM EMP ORDER BY SAL;

SELECT * FROM EMP ORDER BY SAL DESC;

SELECT * FROM EMP ORDER BY HIREDATE;

SELECT EMPNO, ENAME, JOB, SAL FROM EMP ORDER BY 2,3;
--2,3 MEAN COLUMN NUMBER.

SELECT EMPNO, ENAME, JOB, SAL,DEPTNO, COMM FROM EMP ORDER BY 5,2;

SELECT * FROM EMP ORDER BY 4 DESC;

SELECT * FROM EMP ORDER BY 8 DESC, 2 ASC;

SELECT * FROM EMP WHERE DEPTNO= 30 AND JOB ='SALESMAN' ORDER BY ENAME;

SELECT ENAME AS "EMPLOYEE NAME", SAL AS SALARY, DEPTNO AS "DEPARTMENT NO" FROM EMP ORDER BY SALARY DESC;
--SE CAN ALSO SORTING USE ALIAS NAME .

SELECT ENAME , SAL, NVL (COMM, 0)FROM EMP ORDER BY NVL(COMM, 0);

SELECT * FROM TEST110 ORDER BY (NAME);
--1ST NUMBER , UPPER LETTER, LOWER LETTER , NULL (ASC)

--CASE CONVERSATION FUNCTION :
--=============================
--LOWER FUNCTION
--===============
--IT CONVERTS THE ALPHA CHARACTER VALUES TO LOWER CASE .

SELECT ENAME , SAL FROM EMP;

SELECT ENAME, LOWER(ENAME) FROM EMP;

SELECT 'ORACLE', LOWER ('ORACLE'), LOWER ('oracle') from dual;

SELECT ENAME, LOWER(ENAME) FROM EMP WHERE ENAME = 'KING';

SELECT ENAME , SAL FROM EMP WHERE lower (ename) = 'king';

SELECT ENAME, LOWER (ENAME), SAL FROM EMP ORDER BY lower(ename);

SELECT 'ORACLE CORPORATION', LOWER('ORACLE CORPORATION') AS "LOWER OP" FROM DUAL;

--UPPER FUNCTION
--===============
--IT CONVERTS THE ALPHA CAHRACTER TO UPPER CASE.

SELECT UPPER (ENAME), SAL FROM EMP;

SELECT 'oracle' , UPPER ('oracle') from dual;

SELECT EMPNO, ENAME FROM EMP WHERE ENAME = UPPER('KING');

SELECT * FROM EMP ORDER BY UPPER(ENAME);

SELECT UPPER(LOWER(UPPER('ORACLE')))FROM DUAL;

SELECT ENAME, JOB, SAL,COMM,NVL(COMM, 0), SAL*12 FROM EMP WHERE JOB = UPPER('MANAGER');

SELECT UPPER('THE '||ENAME||'''S BASIC SALARY IS RUPEESS '||SAL) FROM EMP;

SELECT UPPER('The '|| Ename || '''s Basic Salary Is Rupees = ' || SAL )FROM EMP 
                        WHERE JOB IN ('MANAGER', UPPER('clerk')) ORDER BY SAL DESC;

--INITCAP FUNCTION  
--=================
--CONVERTS THE ALPHA CHARACTRS INTO UPPER CASE FOR THE FIRST LETTER OR EACH WORD,
--        KEEPING ALL OTHER LETTER IN LOWER CASE.

SELECT ENAME, INITCAP(ENAME)FROM EMP;

SELECT ENAME, LOWER(ENAME), UPPER(ENAME), INITCAP (ENAME)FROM EMP WHERE JOB = 'MANAGER';

SELECT 'ORACLE CORPORATION', INITCAP ('ORACLE CORPORATION IS SITAUTED IN USA') 
            AS "INITCAP OP" FROM DUAL;
/
--CONCAT FUNCTION 
--=================
--IT CONCATS THE 1st CHARACTER VALUE TO 2nd CHARACTER VALUE .
--IT ACCEPT ONLY 2 PARAMETERS.
--HERE NO DATATYPE RESTRICTION .

SELECT CONCAT('ORACLE ', 'CORPORATION') FROM DUAL;

SELECT CONCAT('ABC', 500) FROM DUAL;

SELECT CONCAT ('ORACLE', 'CORPORATION', 'USA') FROM DUAL;-- ERROR,  
--IT ACCEPT ONLY 2 ARGUMENT 

SELECT CONCAT ('ORACLE ', 'USA') FROM DUAL;

SELECT CONCAT ('100 ', 200) FROM DUAL;

SELECT CONCAT (100, 200) FROM DUAL;

SELECT EMPNO, ENAME, JOB, SAL, COMM, NVL(COMM, CONCAT(100,200)) FROM EMP;
--HERE SHOW WHERE COMM IS NULL THEN SHOW THERE 100200 AND REST OF ALL COMM VALUE

SELECT EMPNO, ENAME, SAL, COMM, NVL(COMM, 100||200) FROM EMP;
-- THIS ONE ALSO SAME VALUE BUT HERE CONCAT OPERATOR USED

--SUBSTRING (SUBSTR)
--===================
--IT IS A SINGLE ROW FUNCTION .
--IT RETURNS SPECIFIC VALUES FROM ACTUAL VALUE.
--IT ACCEPT 3 ARGUMENT.
--1st IS ACTUAL VALUE, 2nd IS STATRTING POINT , 3rd IS ENDING POINT.
--IF WE TAKE 2nd ARGUMENT AS M AND 3rd ARGUMENT AS N THEN 
--        IF M IS 0 THEN IT TREATED AS 1.
--        IF M IS +VE THEN IT COUNTS FROM LEFT TO RIGHT 
--        IF M IS -VE THEN IT COUNTS FROM RIGHT TO LEFT.
--        IF N IS OMMITED THEN IT RETURNS ALL VALUES TILL END.
--        IF N IS LESS THAN 1 THEN IT RETURNS NULL.

SELECT 'ORACLE', SUBSTR('ORACLE', 1) FROM DUAL;--ORACLE


SELECT 'ORACLE', SUBSTR('ORACLE', 2,4) FROM DUAL;--RACL

SELECT 'ORACLE', SUBSTR('ORACLE', 2) AS SUBSTRING FROM DUAL;--RACLE

SELECT 'ORACLE', SUBSTR('ORACLE', 2,3) AS SUBSTRING FROM DUAL;--RAC

SELECT 'ORACLE', SUBSTR('ORACLE', 2,2) AS SUBSTRING FROM DUAL;--RA

SELECT 'ORACLE', SUBSTR('ORACLE', 3,1) AS SUBSTRING FROM DUAL;--A

SELECT 'ORACLE', SUBSTR('ORACLE', 0,1) AS SUBSTRING FROM DUAL;--O

SELECT 'ORACLE', SUBSTR('ORACLE', -3,2) AS SUBSTRING FROM DUAL;--CL

SELECT 'NORTH AMERICA', SUBSTR('NORTH AMERICA', 6) FROM DUAL;-- AMERICA

SELECT 'NORTH AMERICA', SUBSTR('NORTH AMERICA', -7) FROM DUAL;--AMERICA

SELECT 'NORTH AMERICA', SUBSTR('NORTH AMERICA', -7,0) FROM DUAL;--NULL , 
--        3RD ARG. LESS THAN 1 THEN RETURN NULL

SELECT 'NORTH AMERICA', SUBSTR('NORTH AMERICA', -7,7) FROM DUAL;--AMERICA

SELECT 'NORTH AMERICA', SUBSTR('NORTH AMERICA', -7,10) FROM DUAL;--AMERICA

SELECT 'NORTH AMERICA', SUBSTR('NORTH AMERICA', 6+1) AS SUBSTRING FROM DUAL;--AMERICA

SELECT ENAME, SUBSTR(ENAME, 2) FROM EMP;

SELECT ENAME, SUBSTR(ENAME, -3,2) FROM EMP;   

SELECT ENAME, JOB FROM EMP WHERE SUBSTR (JOB, 4,3)= UPPER ('AGE');

SELECT ENAME, JOB, SUBSTR(JOB, 4, 3) FROM EMP;

SELECT ENAME, JOB FROM EMP WHERE SUBSTR(JOB , 4,3)='AGE';

SELECT ENAME, JOB, SUBSTR(JOB, 1,3) FROM EMP WHERE SUBSTR(JOB, 4,3)= 'AGE';

SELECT CONCAT(INITCAP(ENAME), CONCAT (' IS A ', CONCAT(INITCAP(SUBSTR(JOB, 1, 3)),'EATER'))) 
              FROM EMP WHERE ENAME= 'KING';
--King IS A PreEATER

SELECT ENAME, SUBSTR(ENAME, 1, 3)AS SUBSTRING FROM EMP ORDER BY SUBSTR(ENAME, 1,3);

SELECT SUBSTR (ENAME, 1, 1 ), SUBSTR(ENAME,4,4) FROM EMP WHERE ENAME= 'KING';

SELECT 'NEELAKANTHA', SUBSTR('NEELAKANTHA', -8 ) FROM DUAL;--LAKANTHA

SELECT SUBSTR('BLAKE', 3) FROM EMP WHERE ENAME = 'BLAKE';
/
--LENGTH FUNCTION
--================
--IT IS A SINGLE ROW FUNCTION .
--IT COUNTS THE NO. OF CHARACTER / PRESENT IN A VALUE.
--IF A STRING IS NULL THEN IT RETURNS NULL.

SELECT COMM, LENGTH(COMM) FROM EMP;
--WHERE COMM PRESENT IT DISPLAY LENGTH & WHERE NULL IS THERE IT DISPLAY NULL.

SELECT 'ORACLE', LENGTH('ORACLE') FROM DUAL;

SELECT ENAME, LENGTH(ENAME) FROM EMP ORDER BY 2;

SELECT ENAME, LENGTH(ENAME) FROM EMP ORDER BY ENAME;

SELECT 'ORA CLE', LENGTH('ORA CLE') FROM DUAL;

SELECT * FROM EMP WHERE LENGTH(ENAME)= 4;

SELECT ENAME, SAL, LENGTH(SAL)  FROM EMP ;

SELECT * FROM EMP WHERE LENGTH (SAL)>3;

SELECT ENAME, LENGTH(ENAME), LENGTH(ENAME)+1 FROM EMP;

SELECT ENAME, LENGTH(ENAME), LENGTH(ENAME)-1, 
        SUBSTR(ENAME, LENGTH(ENAME)-1) AS LAST_2_WORD, 
        SUBSTR(ENAME, LENGTH(ENAME), LENGTH(ENAME))AS LAST_WORD FROM EMP;

SELECT LENGTH(ENAME) || ' CHARACTER EXIST IN' || ' ' || INITCAP(ENAME)|| '''S NAME' AS "NAMES AND LENGTHS "
                FROM EMP;
/
--INSTRING FUNCTION (INSTR)
--==========================
--THIS IS A SINGLE ROW FUNCTION.
--IT RETURNS NUMERIC POSITION OF GIVEN EXPRESSION.
--IT ACCEPT 4 ARGUMENT .
--BUT 3,4 ARG. ARE OPTIONAL.
--1st ARG. IS ACTUAL VALUE, 2nd ARG. IS SEARCHING VALUE, 3rd ARG. IS STARTING POINT, 4th IS NO. OF OCCURANCE
--3rd AND 4th ARG. IS BY DEFAULT 1.
--IF IT IS DOESN'T FIND ANY POSITION IT RETURNS 0.
--IF WE TAKE 3rd ARG.AS M & 4th ARG. AS N THEN,
--       M IS +VE THEN IT SEARCH FROM LEFT TO RIGHT
--       M IS -VE THEN IT SEARCH FROM RIGHT TO LEFT BUT IT ALWAYS COUNT FROM LEFT TO RIGHT.
--       N CAN'T BE LESSER THAN 1.
--       M CAN'T BE 0.

SELECT 'CORPORATE FLOOR', INSTR('FLOOR', 'O') FROM DUAL;
---- HERE WE GET THE POSITION OF 'O' IN FLOOR

SELECT 'COROPRATE FLOOR', INSTR('CORPORATION FLOOR', 'r') FROM DUAL;
--HERE WE GET 0 CAUSE r NOT IN ACTUAL VALUE

SELECT 'CORPORATE FLOOR', INSTR('CORPORATION FLOOR', 'O', 2) FROM DUAL;
-- HERE WE GET FROM CORPORATION FLOOR ON 2 PLACE(SEARCHING PLACE) FIRST 'O ' POSITION NO IS 2

SELECT 'CORPORATE FLOOR', INSTR('CORPORATION FLOOR', 'O', 3) FROM DUAL;
-- HERE WE GET FROM CORPORATION FLOOR ON 3 PLACE(SEARCHING PLACE) FIRST 'O ' POSITION NO IS 5.

SELECT 'CORPORATE FLOOR', INSTR('CORPORATE FLOOR', 'O', 1,1) FROM DUAL;
-- HERE WE GET ON ACTUAL VALUE SEARCHING STARING POINT IS 1 AND FIRST 'O' FIND THE POSITION IS 2.

SELECT 'CORPORATE FLOOR', INSTR('CORPORATION FLOOR', 'O', 1) FROM DUAL;

SELECT 'CORPORATE FLOOR', INSTR('CORPORATION FLOOR', 'OR') FROM DUAL;
--2

SELECT 'CORPORATE FLOOR', INSTR('CORPORATE FLOOR', 'OR',3,2) FROM DUAL;
--14

SELECT 'CORPORATE FLOOR', INSTR('CORPORATE FLOOR', 'OR',2,2) FROM DUAL;
--5

SELECT 'NEELAKANTHA SAHU' , INSTR('NEELAKANTHA SAHU', 'A',6, 2 ) FROM DUAL;

SELECT INSTR('TECHONETHENET','E', -3 ) FROM DUAL;
--10

SELECT 'CORPORATE FLOOR', INSTR('CORPORATE FLOOR', 'O',2,-1) FROM DUAL;--ERROR
--4TH ARG.CAN'T BE LESSER THAN 1

SELECT 'CORPORATE FLOOR', INSTR('CORPORATE FLOOR', 'O',2,0) FROM DUAL;--ERROR
--4TH ARG.CAN'T BE LESSER THAN 1

SELECT 'CORPORATE FLOOR', INSTR('CORPORATE FLOOR', 'O', 0) FROM DUAL;
--OP IS 0

SELECT ENAME, INSTR(ENAME, 'A') MO FROM EMP ORDER BY MO ;

SELECT ENAME, LENGTH(SUBSTR(ENAME,INSTR(ENAME, 'A'))) FROM EMP;
-- HERE 1ST INSTR THE ENAME , THEN WHAT IS THE OUTPUT COMES THAT WILL SUBSTR, THEN FIND THE LENGTH
--EXAMPLE-- IN BLAKE 1ST INSTR(BLAKE, A) = 3,
--          THEN SUBSTR(BLAKE, 3)= AKE
--          THEN LENGTH OF AKE = 3

SELECT ENAME, INSTR(ENAME , 'A') FROM EMP WHERE ENAME = 'BLAKE';

SELECT * FROM EMP WHERE INSTR(ENAME, 'A' )=3;

SELECT ENAME, INSTR(ENAME, 'A') FROM EMP ORDER BY INSTR(ENAME, 'A');

--LPAD
--===========
--IT IS A SINGLE ROW FUNCTION .
--IT WILL ADD VALUES FROM LEFT SIDE OF THE ACTUAL VALUE.
--IT ACCEPT 3 ARGUMENT .
--BUT 3rd IS OPTIONAL.
--1st ARG. IS ACTUAL VALUE, 2nd IS PADDING APPLY NO., 3rd IS WHAT WE WANT TO PADDING
--IF IF 2nd ARG. IS LESS THAN ACTUAL VALUE LENGTH THEN IT WILL CUT THE VALUES FROM RIGHT SIDE OF ACTUAL VALUE.
--IF WE DON'T SPECIFY 3rd ARG. THEN IT WILL BE ADD BLANK SPACE.

SELECT 'KING' , LPAD('KING', 7,'*') FROM DUAL;
---***KING

SELECT 'KING', LPAD('KING', 7) FROM DUAL;
--___KING '_ = SPACE'

SELECT 'KING', LPAD('KING', 4,'*') FROM DUAL;
--KING

SELECT 'KING', LPAD('KING', 5,'*') FROM DUAL;
--*KING

SELECT 'KING', LPAD('KING', 3,'*') FROM DUAL;
-- KIN
--VALUE MINUS

SELECT ENAME, LPAD(ENAME, 7,'#') FROM EMP;

SELECT ENAME, LPAD(ENAME, 7, '#*') FROM EMP WHERE ENAME = 'KING';
--*#*KING


--RPAD
--==============
--IT IS A SINGLE ROW FUNCTION .
--IT WILL ADD VALUES FROM RIGHT SIDE OF THE ACTUAL VALUE.
--IT ACCEPT 3 ARGUMENT .
--BUT 3rd IS OPTIONAL.
--1st ARG. IS ACTUAL VALUE, 2nd IS PADDING APPLY NO., 3rd IS WHAT WE WANT TO PADDING
--IF IF 2nd ARG. IS LESS THAN ACTUAL VALUE LENGTH THEN IT WILL CUT THE VALUES FROM RIGHT SIDE OF ACTUAL VALUE.
--IF WE DON'T SPECIFY 3rd ARG. THEN IT WILL BE ADD BLANK SPACE.

SELECT 'KING' , RPAD('KING', 7,'*') FROM DUAL;
---KING***

SELECT 'KING', RPAD('KING', 7) FROM DUAL;
--KING___
--'_' = SPACE'

SELECT 'KING', RPAD('KING', 4,'*') FROM DUAL;
--KING

SELECT 'KING', RPAD('KING', 5,'*') FROM DUAL;
--KING*

SELECT 'KING', RPAD('KING', 3,'*') FROM DUAL;
-- KIN
--VALUE MINUS

SELECT ENAME, RPAD(ENAME, 7,'#') FROM EMP;

SELECT ENAME, RPAD(ENAME, 7, '#*') FROM EMP WHERE ENAME = 'KING';
--KING#*#

--LTRIM
--==============
--THIS IS A SINGLE ROW FUNCTION.
--THIS IS USED TO TRIM THE EXPRESSION FROM LEFT SIDE FROM A ACTUAL VALUE.
--IT ACCEPT 2 ARGUMENTS.
--1st ARG. IS ACTUAL VALUE & 2nd ARG. IS TRIMMING VALUE .
--2nd ARG. IS OPTINAL , IF WE DON'T SPECIFY 2nd ARG. THEN IT WILL BE DISPLAY ACTUAL VALUE.
--IT WILL TRIM UNLESS A NEW CHARACTER GET.

SELECT LTRIM('NIEL', 'N') FROM DUAL;

SELECT 'ABC' , LTRIM ('ABC', 'A') FROM DUAL;
--BC
/
SELECT 'ABCA', LTRIM('ABCA', 'A') FROM DUAL;
--BCA
/
SELECT 'ABACA', LTRIM('ABACA', 'A') FROM DUAL;
--BACA
/
SELECT 'AABACA', LTRIM('AABACA', 'A') FROM DUAL;
--BACA

/
SELECT 'xyzXxyLAST WORD', LTRIM('xyzXxyLAST WORD', 'xy') from dual;
--zXxyLAST WORD
/
SELECT 'xyxzXxyLAST WORD', LTRIM('xyxzXxyLAST WORD', 'xy') FROM DUAL;
--zXxyLAST WORD
/
SELECT 'xyyxzXxyLAST WORD', LTRIM('xyyxzXxyLAST WORD', 'xy') from dual;
--zXxyLAST WORD
/
SELECT 'xyXzXxyLAST WORD', LTRIM('xyXzXxyLAST WORD', 'xy') from dual;
--XzXxyLAST WORD
/
SELECT 'MANAGER', LTRIM('MANAGER', 'MAN') FROM DUAL;
--GER
/
SELECT 'MANAGER', LTRIM('MANAGER', 'MANAGER') FROM DUAL;
--NULL
SELECT JOB, LTRIM(JOB, 'MAN') FROM EMP WHERE JOB LIKE 'MANAGER';
--GER
--GER
--GER
SELECT LTRIM ('NIEL', 'S' )FROM DUAL;--SAME 1ST ARGUMENT ON OP COZ THEIR NOTHING VALUE TO LTRIM
SELECT LTRIM ('            NIEL') FROM DUAL;--SPACE WILL BE REMOVED FROM LEFT SIDE
--======================================================================================================
--RTRIM
--==============
--THIS IS A SINGLE ROW FUNCTION.
--THIS IS USED TO TRIM THE EXPRESSION FROM RIGHT SIDE FROM A ACTUAL VALUE.
--IT ACCEPT 2 ARGUMENTS.
--1st ARG. IS ACTUAL VALUE & 2nd ARG. IS TRIMMING VALUE .
--2nd ARG. IS OPTINAL , IF WE DON'T SPECIFY 2nd ARG. THEN IT WILL BE DISPLAY ACTUAL VALUE.
--IT WILL TRIM UNLESS A NEW CHARACTER GET.

SELECT 'ABC' , RTRIM ('ABC', 'A') FROM DUAL;
--ABC

SELECT 'ABCA', RTRIM('ABCA', 'A') FROM DUAL;
--ABC

SELECT 'ABACA', RTRIM('ABACA', 'A') FROM DUAL;
--ABAC

SELECT 'AABACAA', RTRIM('AABACAA', 'A') FROM DUAL;--AABAC

SELECT 'xyzXxyLAST WORDzxy', RTRIM('xyzXxyLAST WORDzxy', 'xy') from dual;
--xyzXxyLAST WORDz

SELECT RTRIM('ABACA', 'CA') FROM DUAL;
--AB

SELECT 'xyxzXxyLAST WORDxyx', RTRIM('xyxzXxyLAST WORDxyx', 'xy') FROM DUAL;
--xyxzXxyLAST WORD

SELECT 'xyyxzXxyLAST WORDxyyx', RTRIM('xyyxzXxyLAST WORDxyyx', 'xy') from dual;
--xyyxzXxyLAST WORD

SELECT 'MANAGER', RTRIM('MANAGER','GER') FROM DUAL;
--MANA

SELECT 'MANAGER', RTRIM('MANAGER', 'MANAGER') FROM DUAL;
--NULL

SELECT JOB, RTRIM(JOB, 'GER') FROM EMP WHERE JOB LIKE 'MANAGER';
--MANA
--MANA
--MANA

SELECT RTRIM ('NIEL            ') FROM DUAL;
--NIEL
--SPACE WILL BE REMOVED FROM RIGHT SIDE
--=================================================================================================
--TRIM :
--========
--THIS IS A SINGLE ROW FUNCTION.
--IT IS USED TO TRIM / CUT CHARACTER FROM BOTH SIDE OF A COLUMN OR EXPRESSION.
--IT ACCEPTS 2 ARGUMENT.
--1ST ARG. IS TRIMMING VALUE. (OPTINAL).
--2ND ARG. IS ACTUAL VALUE.(MANDATORY).
--IF WE DON'T SPECIFY 1ST ARG. THEN IT WILL TRIM SPACE FROM BOTH SIDE.
--ONLY ONE CHARACTER WE TRIM FROM BOTH SIDE.

SELECT TRIM ('A' FROM 'ABCA') FROM DUAL;
--BC

SELECT TRIM ('S' FROM 'MITHSS') FROM DUAL;
--MITH


SELECT TRIM ('S' FROM 'SSMITH') FROM DUAL;
--MITH

SELECT TRIM ('S' FROM 'SSS') FROM DUAL;
--NULL.

SELECT TRIM ('N' FROM 'NIELnN') FROM DUAL;
--IELN
--ON ORACLE DATA ARE ALWAYS CASE SENSITIVE.

SELECT TRIM ('                                      NIEL    ') FROM DUAL;
--NIEL
--SPACE WILL BE REMOVED FROM BOTH SIDE.
--====================================================================================================

--LEADING:
--=========
--WITHOUT USING LTRIM WE CAN TRIM DATA FROM LEFT SIDE USING LEADING .
--BUT ONLY CHARACTER WE TRIM FROM ACTUAL VALUE.
--SYNTAX :
--=========
--SELECT TRIM (LEADING <' TRIM_VALUE '> FROM <' ACTUAL_VALUE '> ) FROM < TABLE_NAME >;

SELECT TRIM (LEADING 'S' FROM 'SAHU') FROM DUAL;
--AHU.
--==================================================================================================

--TRAILING :
--==========
--WITHOUT USING RTRIM WE CAN TRIM DATA FROM RIGHT SIDE USING TRAILING .
--BUT ONLY CHARACTER WE TRIM FROM ACTUAL VALUE.
--SYNTAX :
--=========
--SELECT TRIM (TRAILING <' TRIM_VALUE '> FROM <' ACTUAL_VALUE '> ) FROM < TABLE_NAME >;

SELECT TRIM (TRAILING 'A' FROM 'SAJIA') FROM DUAL;
--SAJI
--=====================================================================================================

--REPLACE 
--========
--THIS IS A SINGLE ROW FUNCTION.
--IT ACCEPT 3 ARGUMENT .
--1ST ARGUMENT IS ACTUAL VALUE. (MANDATORY).
--2ND ARGUMENT IS SEACHING VALUE. (MANDATORY).
--3RD ARGUMENT IS REPLACE VALUES .(OPTIONAL).
--IF WE DON'T PROVIDE 3RD ARG. THEN IT WILL REMOVE THE 2ND ARG.(SEARCHING VALUE) FROM 1ST ARG(ACTUAL VALUE)
--IF 2ND ARG. IS NOT IN 1ST ARG. THEN IT WILL DISPLAY THE 1ST ARG.
--IT WILL REPLACE PATTERN BY PATTERN.





--TRANSLATE FUNCTION
--===================
SELECT 'BLACK', TRANSLATE('BLACK','B','C')FROM DUAL;
--CLACK
/
SELECT 'OXFORD',TRANSLATE('OXFORD', 'O','A') FROM DUAL;
--AXFARD
/
SELECT 'OXFORD',TRANSLATE('OXFORD', 'O') FROM DUAL;
--ERROR
--INVALID NO. OF ARGUMENT COZ IN TRANSLATE FUNCTION 3 ARGUMENT ARE COMPULSARY

/
SELECT 'JACK AND JUE', TRANSLATE('JACK AND JUE', 'JA', 'BL') FROM DUAL;
--BLCK LND BUE
-- IT WILL TRANSLATE EACH BY EACH CHARACTER
/
SELECT 'JACK AND JUE', TRANSLATE('JACK AND JUE', 'JA', 'BLZ') FROM DUAL;
--BLCK LND BUE
/
SELECT 'JACK AND JUE', TRANSLATE('JACK AND JUE', 'J', 'BLZ') FROM DUAL;
--BACK AND BUE
-- IT WILL SHOW ONLY WHICH NO CHARACTER MATCH 
/
SELECT 'JACK AND JUE', TRANSLATE('JACK AND JUE', 'JAKU', 'BLZ') FROM DUAL;
--BLCZ LND BE
-- HERE 'U' REMOVE COZ IN 2ND ARG. 4 LETTER AND 3RD LETTER 3 LETTER SO REMOVE THIS ONE UNMATCHED CHARACTER
/



CHR FUNCTION
===============================================================================
===============================================================================


SELECT CHR(67) || CHR(65) || CHR(84) FROM DUAL;
--CAT


ASCII FUNCTION
======================================================================================
======================================================================================

SELECT ASCII('A') || ASCII('B') FROM DUAL;
--6566
SELECT ASCII('C') || ASCII('A') || ASCII('T') FROM DUAL;
--676584
/
SELECT ASCII('A'), ASCII('APPLE') FROM DUAL;
--65
/
SELECT ASCII('a') FROM DUAL;
--97
/
SELECT ASCII('A'), ASCII('B'), ASCII('O'), ASCII('ORACLE') FROM DUAL;
--65  --66  --79  --79
/

USEFUL FUNCTION
==============================
==============================
ROUND FUNCTION
================
================


SELECT ROUND(2.5) FROM DUAL;
--3
/
SELECT ROUND(2.4) FROM DUAL;
--2
/
SELECT ROUND(21.5,1) FROM DUAL;
--21.5
/
SELECT ROUND(0.5,1)+1.5 FROM DUAL;
--2
/
SELECT ROUND(21.56,1) FROM DUAL;
--21.6
--HERE GET AFTER DECIMAL WE SEE WHICH ONE IS GRAEATER THAN
/
SELECT ROUND(2.45,1) FROM DUAL;
--2.5
--HERE GET AFTER DECIMAL HOW MUCH VALUE ARGUMENT THEN IT WILL ROUNDOFF TO THEIR VALUE
/
SELECT ROUND(2.52,1) FROM DUAL;
--2.5
/
SELECT ROUND(21.525,2) FROM DUAL;
--21.52
/
SELECT ROUND(21.25,2) FROM DUAL;
--21.25
/
SELECT ROUND(21.568,2) FROM DUAL;----------
--21.57
SELECT ROUND(21.55,1) FROM DUAL;
--21.6
/


TRUNC FUNCTON
==============
SELECT TRUNC(2.5) FROM DUAL;
--2
/
SELECT TRUNC(21.5,1) FROM DUAL;
--21.5
/
SELECT TRUNC(21.87,1) FROM DUAL;
--21.8
/
SELECT TRUNC(21.87,2) FROM DUAL;
--21.87
/
SELECT TRUNC(21.878,2) FROM DUAL;
--21.87
/
SELECT ROUND(TRUNC(21.87,1)) FROM DUAL;
--22


CEIL FUNCTION--
=================
=================


SELECT CEIL(21) FROM DUAL;
--21
/
SELECT CEIL(9.2323) FROM DUAL;
--10
/
SELECT CEIL(21.589444) FROM DUAL;
--22





FLOOR FUNCION---
=================
=================


SELECT FLOOR(9) FROM DUAL;
--9
/
SELECT FLOOR(2.23214) FROM DUAL;
--2
/
SELECT FLOOR(2189.88) FROM DUAL;
--2189

MODULUDS FUNCTION--
===================
==================


SELECT MOD(10,2) FROM DUAL;
--0
/
SELECT MOD(10,3) FROM DUAL;
--1
/
SELECT SAL, MOD(SAL, 2) FROM EMP;
--HERE WE GET ALL SAL'S DIVIDE BY 2.
/


POWER FUNCTION --  (POWER)
=================
=================
--THIS FUNCTION ARE WORK MAKE POWER OF ACTUAL VALUE

SELECT POWER(5,2) FROM DUAL;
--25
/
SELECT SAL, POWER(SAL,2) FROM EMP;
--HERE WE GET POWER OF ALL SAL VALUE.

SQUARE ROOT FUNCTION--  (SQRT)
======================
======================

--HERE WE GET SQUARE ROOT OF GIVEN VALUE 

SELECT SQRT(25) FROM DUAL;
--5
/
SELECT SQRT(125) FROM DUAL;
--11.1803398874989484820458683436563811772
/
SELECT SQRT(625) FROM DUAL;
--25
/
SELECT ROUND(SQRT(SAL)) FROM EMP;
--HERE WE 1ST SQRT SAL OF ALL EMP 
--THEN ROUNDOFF ALL VALUE WE GET
/


ABSOLUTE FUNCTION-- (ABS)
=================
=================
--HERE WE GET ABSOLUTE POSITIVE VALUE


SELECT ABS(-10) FROM DUAL;
--10
/
SELECT ABS(10) FROM DUAL;
--10
--HERE WE GET ALSO POSITIVE OUTPUT WHEN ACTUAL VALUE ARE POSITIVE
/
SELECT ABS(0) FROM DUAL;
--0


SIGN FUNCTION--
=============
=============
--IT SHOW SIGN SPECIFICATION OF A NO
--IF -VE THEN -1
--IF +VE THEN 1
-- IF 0 THEN 0


SELECT SIGN(-23), SIGN(23), SIGN(0) FROM DUAL;                                                         
--HERE WE GET ALL THE SIGN VALUE OF VALUE
-- -1
-- 1
-- 0
/
SELECT SIGN(-23) FROM DUAL;
-- -1
/

TO CHANGE THE DATE FORMAT--
ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH:MI:SS P.M.';










DATE FUNCTION
==============
SELECT SYSDATE, SYSDATE+1 FROM DUAL;--NEXTDAY
SELECT SYSDATE, SYSDATE-1 FROM DUAL;--PREVIOUS DAY
SELECT SYSDATE*1 FROM DUAL;--ERROR
SELECT SYSDATE/1 FROM DUAL;--ERROR
SELECT SYSDATE-SYSDATE FROM DUAL;--0
SELECT TO_DATE ('15-MAR-22')-2 FROM DUAL;--13-MAR-22
SELECT SYSDATE + SYSDATE FROM DUAL;--ERROR--DATE + DATE NOT ALLOWED
1/24 = 1 HOUR
1/24/60 = 1 MINUTE
1/24/60/60 = 1 SECOND
SELECT SYSDATE+2-SYSDATE FROM DUAL;--2
SELECT (SYSDATE+2) - (SYSDATE-1) FROM DUAL;--3
ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YYYY, HH:MI:SS P.M.';-- FOR DATE FORMAT CHANGE 
SELECT SYSDATE, SYSDATE+1/24 FROM DUAL;--1 HOUR EXTEND
SELECT SYSDATE, SYSDATE+1/24/60 FROM DUAL;--1 MINUTES EXTEND
SELECT SYSDATE, SYSDATE+1/24/60/60 FROM DUAL;-- 1 SECOND EXTENDED
SELECT SYSDATE, HIREDATE, SYSDATE - HIREDATE, FLOOR (ROUND(SYSDATE-HIREDATE)/7), FLOOR(ROUND(SYSDATE- HIREDATE)/365) FROM EMP;
--1ST ONE FOR GET WEEKLY
--2ND ONE FOR GET YEARLY

ADD_MONTHS FUNCTION
==================
SELECT SYSDATE, ADD_MONTHS(SYSDATE,1) FROM DUAL;--1 MONTH ADD
SELECT ADD_MONTHS(SYSDATE,-2) FROM DUAL;--2 MONTH BACK
SELECT ADD_MONTHS( '26-OCT-99',2) FROM DUAL;--2 MONTH ADD
SELECT ADD_MONTHS(SYSDATE,-12*2) FROM DUAL;--24 MONTHS BACK
SELECT ENAME, HIREDATE, ADD_MONTHS(HIREDATE, -12) FROM EMP WHERE ADD_MONTHS(HIREDATE ,-12) IN '01-MAY-1980';
-- SEARCHING THROUGH ADD_MONTHS FUNCTION
SELECT (ADD_MONTHS(TRUNC(SYSDATE , 'YEAR'),12)-1)  FROM DUAL;

MONTHS_BETWEEN FUNCTION
=======================
SELECT SYSDATE, MONTHS_BETWEEN(SYSDATE, '20-APR-22') FROM DUAL-- 1 MONTH BETWEEN
SELECT SYSDATE, MONTHS_BETWEEN (SYSDATE, ADD_MONTHS(SYSDATE, -12)) FROM DUAL;--12 
SELECT SYSDATE, MONTHS_BETWEEN (SYSDATE, ADD_MONTHS(SYSDATE, 12)) FROM DUAL;-- -12
SELECT MONTHS_BETWEEN ('20-MAY-2020', '20-APR-2020') FROM DUAL;--1

NEXT_DAY FUNCTION
==================
-- IT RETURNS THE DATE OF FIRST WEEK DAY
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THU') FROM DUAL;-- 20-MAY === 26-MAY
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'FRI') FROM DUAL;-- 20-MAY(FRI) === 27-MAY(FRI)
SELECT SYSDATE, NEXT_DAY(SYSDATE-1, 'THU') FROM DUAL;
SELECT ENAME,HIREDATE, NEXT_DAY(HIREDATE, 'MON') FROM EMP;--HERE WE GET NEXT WEEK'S MON DATE WHICH
    --ONE ACTUAL VALUE IS HIREDATE
SELECT * FROM EMP WHERE NEXT_DAY(HIREDATE,'MON') = '23-NOV-1981';

LAST_DAY FUNCTION
==================
--IT RETURNS THE LAST DATE OF 1ST ARGUMENT
SELECT SYSDATE, LAST_DAY(SYSDATE) FROM DUAL;--31-MAY-22
SELECT SYSDATE, NEXT_DAY(LAST_DAY(SYSDATE),'MON') FROM DUAL;--06-JUN-22
SELECT ADD_MONTHS(LAST_DAY(SYSDATE),-1)+1 FROM DUAL;--1 MAY 22  -- SYSDATE = 20.5.22
Q. WAQ TO DISPLAY DAYS LEFT FOR THE CURRENT MONTH.
SELECT LAST_DAY(SYSDATE)-SYSDATE FROM DUAL;

TRUNC WITH DATES
=================
--IT DISPALY THE 1ST DATE OF CUREENT WEEK
SELECT SYSDATE, TRUNC(SYSDATE, 'DAY') FROM DUAL;--15-MAY-22 --SYS = 20-MAY
SELECT SYSDATE, TRUNC(TO_DATE('15-MAY-22'), 'DAY') FROM DUAL;--15-MAY-22
SELECT TRUNC(SYSDATE-6, 'DAY') FROM DUAL;--08-MAY-22
SELECT TRUNC(SYSDATE,'DD') FROM DUAL;--14-MAY-22  --'DD' MEANS DAY WISE 
SELECT SYSDATE, TRUNC(SYSDATE, 'MON') FROM DUAL;--01-MAY-22   --IT RETURN 1ST DATE OF THIS MONTH
SELECT SYSDATE, TRUNC(SYSDATE, 'MM') FROM DUAL;
SELECT SYSDATE, TRUNC(SYSDATE, 'MONTH') FROM DUAL;
SELECT SYSDATE, TRUNC(SYSDATE, 'YEAR') FROM DUAL;--01-JAN-22
SELECT SYSDATE, TRUNC(SYSDATE, 'YY') FROM DUAL;
SELECT SYSDATE, TRUNC(SYSDATE, 'YYYY') FROM DUAL;
SELECT NEXT_DAY(TRUNC(SYSDATE, 'YY'),'MON') FROM DUAL;
SELECT NEXT_DAY(ADD_MONTHS(TRUNC(SYSDATE,'YY'),12),'MON') FROM DUAL;
SELECT NEXT_DAY(ADD_MONTHS(TRUNC(SYSDATE,'YY'),-7),'MON') FROM DUAL;
SELECT TRUNC (SYSDATE) FROM DUAL;

GREATEST FUNCTION
=================
--IT PICKS HIGHEST VALUE FROM LIST OF PARAMETER
-- DATATYPE SHOULD MATCH
SELECT GREATEST(100,200,300) FROM DUAL;--300
SELECT GREATEST('A', 'B', 'C') FROM DUAL;--C
SELECT GREATEST('NIEL', 'NARAYAN', 'NOBITA') FROM DUAL;--NOBITA
SELECT GREATEST('AZ','ABC') FROM DUAL;--AZ
SELECT GREATEST('W', 'NARAYAN', 'NOBITA') FROM DUAL;--W
SELECT GREATEST(SYSDATE,TO_DATE('05-SEP-2017'), TO_DATE('21-AUG-2021')) FROM DUAL;--YEAR 1ST
SELECT GREATEST(TO_DATE('05-SEP-2017'), TO_DATE('05-OCT-2017')) FROM DUAL;--MONTH 1ST
SELECT GREATEST(TO_DATE('05-SEP-2017'), TO_DATE('06-SEP-2017')) FROM DUAL;--DATE 1ST
SELECT EMPNO, SAL, GREATEST (EMPNO,SAL) FROM EMP;
SELECT EMPNO, SAL, GREATEST (EMPNO,SAL) FROM EMP WHERE DEPTNO=10;
SELECT EMPNO, SAL, GREATEST (EMPNO,SAL) FROM EMP WHERE SAL>1500 AND DEPTNO=10;
SELECT SAL, COMM,GREATEST(COMM, SAL) FROM EMP;
SELECT SAL, COMM, GREATEST(NVL(COMM,0), SAL) FROM EMP;

LEAST FUNCTION
==============
--IT PICKS LOWEST VALUE FROM LIST OF PARAMETER
-- DATATYPE SHOULD MATCH
SELECT LEAST(100,200,300) FROM DUAL;--100
SELECT LEAST('A', 'B', 'C') FROM DUAL;--A
SELECT LEAST('NIEL', 'NARAYAN', 'NOBITA') FROM DUAL;--NARAYAN
SELECT LEAST('AZ','ABC') FROM DUAL;--ABC
SELECT LEAST('W', 'NARAYAN', 'NOBITA') FROM DUAL;--NARAYAN
SELECT LEAST(SYSDATE,TO_DATE('05-SEP-2017'), TO_DATE('21-AUG-2021')) FROM DUAL;--YEAR 1ST
SELECT LEAST(TO_DATE('05-SEP-2017'), TO_DATE('05-OCT-2017')) FROM DUAL;--MONTH 1ST
SELECT LEAST(TO_DATE('05-SEP-2017'), TO_DATE('06-SEP-2017')) FROM DUAL;--DATE 1ST
SELECT EMPNO, SAL, LEAST (EMPNO,SAL) FROM EMP;
SELECT EMPNO, SAL, LEAST (EMPNO,SAL) FROM EMP WHERE DEPTNO=10;
SELECT EMPNO, SAL, LEAST (EMPNO,SAL) FROM EMP WHERE SAL>1500 AND DEPTNO=10;
SELECT SAL, COMM,LEAST(COMM, SAL) FROM EMP;
SELECT SAL, COMM, LEAST(NVL(COMM,0), SAL) FROM EMP;

USER FUNCTION
==============
--HERE WE GET WHICH ORACLE USER CONNECTED
SHOW USER;
SELECT USER FROM DUAL;

COVERSION FUNCTION
===================
IMPLICIT DATATYPE CONVERSION
=============================
--IN THIS FUNCTION DATATYPE AUTOMATIC COVERSION WHICH HAVE ORACLE RESERVED
SELECT SAL, SAL+'10' FROM EMP;--10 ADD BT IT WILL CONVERT ADD ACCEPT
SELECT * FROM EMP WHERE HIREDATE = '17-DEC-80';
SELECT * FROM EMP WHERE EMPNO='7369';

EXPLICIT DATA TYPE CONVERSION
==============================
TO_CHAR CNVERSION
==================
DECIMAL INDICATOR
==================
SELECT TO_CHAR(1234, '9999D99') FROM DUAL;--1234.00
SELECT TO_CHAR(12345, '9999D99') FROM DUAL;--#######
SELECT TO_CHAR(12345, '999999D99') FROM  DUAL;--12345.00
SELECT SAL, TO_CHAR(SAL,'$9999999999999999999999999.999') FROM EMP;--$SAL

GROUP SEPARATOR
================
SELECT TO_CHAR(1234, '9999.99') FROM DUAL;
SELECT TO_CHAR(12345, '9G99G999D99') FROM DUAL;--12,345.00
SELECT TO_CHAR(12345, '9,99,9,9.99999') FROM DUAL;--1,23,4,5.00000
SELECT SAL,TO_CHAR(TO_NUMBER (TO_CHAR(SAL,'9,99,99.99'),'9,99,99.99'),'$99999.99') FROM EMP;
SELECT TO_CHAR(SYSDATE,'A.M.') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'B.C.') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'MI') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'DD') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'DAY') FROM DUAL;
SELECT TO_CHAR(SYSTIMESTAMP,'DD') FROM DUAL;
SELECT TO_CHAR(SYSTIMESTAMP, 'DAY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'MM ') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'MONTH') FROM DUAL;
SELECT TO_CHAR(SYSDATE+100, 'MONTH') FROM DUAL;
SELECT SYSDATE+100, TO_CHAR(SYSDATE+100, 'MM') FROM DUAL;
SELECT SYSDATE , TO_CHAR(SYSDATE, 'YY YYYY YEAR') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YEAR') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'RR                                RRRR') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'RRRR') FROM DUAL;
SELECT EMPNO, ENAME, HIREDATE, TO_CHAR(HIREDATE, 'DAY')FROM EMP;
SELECT EMPNO, ENAME, HIREDATE, TO_CHAR(HIREDATE, 'DAY')||'--->'|| TO_CHAR(HIREDATE, 'MONTH')||'--->'||
 TO_CHAR(HIREDATE, 'YEAR')FROM EMP;
SELECT HIREDATE, INITCAP(TO_CHAR(HIREDATE,'MON')) FROM EMP;
SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY HH:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DD-DAY MM-MON-MONTH YY-YYYY-YEAR HH-MI-SS')FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DD-MON-YEAR-HH') FROM DUAL;
SELECT TO_CHAR(SYSDATE+7/24,'DD-MON-YYYY HH24:MI:SS P.M.') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'DDSP') FROM DUAL;
SELECT EMPNO, ENAME, HIREDATE, TO_CHAR(HIREDATE, 'DAY ---> MONTH ---> YEAR') FROM EMP;
SELECT TO_CHAR(SYSDATE+1, 'DDDSP') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DSP-MONTH-YEAR') FROM DUAL;
SELECT TO_CHAR(TRUNC(SYSDATE,'YEAR')+5,'DDD') FROM DUAL;
SELECT TO_CHAR(TRUNC(SYSDATE,'YEAR')+5,'DDD') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DDD') FROM DUAL;
SELECT TO_CHAR(TO_DATE('20-NOV-2022'), 'DDTH/MON/YEAR' ) FROM DUAL;
SELECT LENGTH(TO_CHAR(TO_NUMBER(SAL+2),'$999999.99')) FROM EMP;
SELECT LENGTH(TO_CHAR(TO_NUMBER(SAL+2),'$999999.99')), TO_NUMBER(TO_CHAR(LENGTH(SAL))) FROM EMP;
SELECT TO_CHAR(TO_NUMBER(SAL+2),'$999999.99'),LENGTH(TO_CHAR(TO_NUMBER(SAL+2),'$9999999.99')) FROM EMP;
SELECT TO_CHAR(1234,'9999D99'),LENGTH(TRIM(TO_CHAR(1234,'9999D99'))) FROM DUAL;


DL (LONG DATE)
===============
--DAY,MON DATE, YYYY
SELECT TO_CHAR(SYSDATE, 'DL') FROM DUAL;--Monday, May 23, 2022

DS (SHORT DATE)
===============
--MM/DD/YYYY
SELECT TO_CHAR(SYSDATE, 'DS ') FROM DUAL;--5/23/2022

TS (SHORT TIME)
===============
--HH:MI:SS A.M/P.M.
SELECT TO_CHAR(SYSDATE, 'TS ') FROM DUAL;--1:48:42 PM 

FORMAT MODIFIER 
================
SELECT TO_CHAR(560, 'FM000000') FROM DUAL;--000560
SELECT TO_CHAR(560, 'FM111111') FROM DUAL;--ERROR

TO_NUMBER FUNCTION
===================
SELECT * FROM PRODUCT_MASTER;
SELECT DISTINCT PRODUCT_ID FROM PRODUCT_MASTER ORDER BY TO_NUMBER(SUBSTR(PRODUCT_ID, 2));
SELECT DISTINCT PRODUCT_ID FROM PRODUCT_MASTER ORDER BY (SUBSTR(PRODUCT_ID, 2)); --NOT SHOW IN PROPER WAY NUMBER OF ORDER BY
SELECT TO_NUMBER('143')+7 FROM DUAL;

TO_DATE FUNCTION
=================
SELECT TO_DATE('25-MAR-2022')+1 FROM DUAL;
SELECT ('25-MAR-2022') +1 FROM DUAL;-- INVALID NUMBER
SELECT TO_DATE('25-OCT-22') FROM DUAL;
SELECT TO_DATE('25-OCT-22')+5 FROM DUAL;
SELECT TO_DATE('120698', 'DD-MM-YY' ) FROM DUAL;
SELECT TO_CHAR(TO_DATE('120698','DD-MM-YY'), 'YY-MM-DD') FROM DUAL;
SELECT TO_CHAR(TO_DATE('12061998', 'DD-MM-YYYY'),'DD-MON-YEAR') FROM DUAL;

WEEK DAY INDICATOR
==================
NUMERIC WEEK DAY INDICATOR (D)
===========================
SELECT TO_CHAR(SYSDATE, 'D') FROM DUAL;-- HERE WE GET ACTUAL DATE IS WHICH NO. OF DAY IN CURRENT WEEK 
SELECT TO_CHAR(TO_DATE('26-OCT-99'), 'D') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DSP') FROM DUAL;--SPELL OF D 
SELECT ENAME,TO_CHAR(HIREDATE, 'D') FROM EMP WHERE TO_CHAR(HIREDATE, 'D')= 2;
SELECT ENAME, HIREDATE, TO_CHAR(HIREDATE, 'DAY') FROM EMP;
SELECT ENAME, HIREDATE FROM EMP WHERE TRIM(TO_CHAR(HIREDATE, 'DAY'))= 'MONDAY';
SELECT ENAME, HIREDATE FROM EMP WHERE (TO_CHAR(HIREDATE, 'DAY')) LIKE 'MOND%';

MONTH DAY INDICATOR (DD)
====================
--HERE COUNT THE HOW MUCH DAY STILL TODAY
SELECT TO_CHAR(SYSDATE, 'DD') FROM DUAL;--HOW MUCH DAY STILL COVER ON THIS MONTH
SELECT TO_CHAR(SYSDATE, 'DDSP') FROM DUAL;--HERE SPELL THE 'DD' CONDN.
SELECT TO_CHAR(SYSDATE, 'DD-DAY') FROM DUAL;--23-MONDAY   
SELECT HIREDATE, TO_CHAR(HIREDATE, 'DD-DAY') FROM EMP;
--  17-WEDNESDAY
--  20-FRIDAY..................
SELECT * FROM EMP WHERE TO_CHAR(HIREDATE, 'DD-DAY') = '17-WEDNESDAY';
SELECT * FROM EMP WHERE TRIM(TO_CHAR(HIREDATE,'DD-DAY'))= '20-FRIDAY' ;
SELECT TO_CHAR(SYSDATE, 'DDTH,MON,YYYY') FROM DUAL;
SELECT TO_CHAR(TRUNC(SYSDATE, 'MM'),'DDTH-MON-YY') FROM DUAL;

YEAR DAY INDICATOR (DDD)
=========================
--HERE COUUNT HOW MUCH DAY IS FULFIL STILL NOW (1-366)
SELECT TO_CHAR(TO_DATE('31-DEC-2022'), 'DDD') FROM DUAL;
SELECT ADD_MONTHS(TRUNC(SYSDATE, 'YY'),12)- TRUNC(SYSDATE, 'YY') FROM DUAL;--365

WEEK OF THE MONTH INDICATOR (W)--WEEK STRAT FROM 1 DATE (1 WEEK = 1 TO 7)
================================
--IT RETURN WEEK OF THE MONTH IN  A NO
SELECT TO_CHAR(SYSDATE, 'W') FROM DUAL;--4
SELECT TO_CHAR(TO_DATE('01-JUL-22'),'W') FROM DUAL;--1
SELECT TO_CHAR(TO_DATE('31-JUL-22'),'W') FROM DUAL;--5

YEAR WEEK INDICATR (WW)
=======================
--IT RETURNS THE WEEK OF THE YEAR ;
SELECT TO_CHAR(SYSDATE,'WW') FROM DUAL;--21
SELECT TO_CHAR(TO_DATE('5-JAN-22'),'WW') FROM DUAL;

QUARTER OF THE YEAR INDICATOR
=============================
--IT RETURN THE CURRENT QUARTER OF THE YEAR IN A NO.
SELECT TO_CHAR(SYSDATE, 'Q') FROM DUAL;--2
SELECT * FROM EMP WHERE TO_CHAR(HIREDATE, 'Q') = 2;
SELECT * FROM EMP WHERE TO_CHAR(HIREDATE, 'Q') IN (2,3);

ROMAN NUMERAL MONTH CONVERTER
==============================
-- I, II, III, IV, V...
SELECT TO_CHAR(SYSDATE, 'RM') FROM DUAL;
SELECT TO_CHAR(TO_CHAR(SYSDATE, 'Q'),'RM') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'RM') FROM DUAL;
SELECT TO_CHAR(TO_CHAR(SYSDATE, 'DD'),'RM') FROM DUAL;

JULIAN DAY
==========
--SUPPORT ONLY 7 DIGIT
--WE CAN SPELL ANY NO TO WORD USING JULIAN CALENDAR
SELECT TO_CHAR(TO_DATE(500000,'J'),'JSP') FROM DUAL;

AGGREGATE FUNCTION
===================
AVERAGE FUNCTION (AVG)
========================
--IGNORE NULL VALUES
SELECT AVG (SAL) FROM EMP;--2073.214285714285714285714285714285714286 ,GET AVERAGE OF SAL COLUMN
SELECT AVG(NULL) FROM DUAL;--NULL

SUM FUNCTION (SUM)
==================
--IGNORE NULL VALUES
SELECT SUM (SAL) FROM EMP;--SUM/TOTAL AMOUNT OF SAL COLUMN  
SELECT SUM(COMM) FROM EMP;-- HERE IGNORES NULL VALUES
SELECT SUM(NVL(COMM,0)) FROM EMP;
SELECT SUM(100) FROM EMP;--1400   HERE IN EMP TABLE 14 RECORD AVAILABLE SO IT MULTIPLE 100 * 14 RECORD
SELECT SUM(100) FROM DUAL;--100

MAXIMUM VALUE (MAX)
====================
SELECT MAX(SAL) FROM EMP; --5000  , HERE GET MAX VALUE IN SAL COLUMN
SELECT MAX (ENAME) FROM EMP;--WARD  ,HERE CHECK MAX VALUE IN ALPHABATIC
SELECT MAX(HIREDATE) FROM EMP;-- HERE 1ST PRIORITY IS YEAR, 2ND IS MONTH LIKE 1,2,3,...., THEN 3RD IS DATE 
CREATE TABLE TEST_MAX (DOB DATE);
INSERT INTO TEST_MAX VALUES('10-JAN-2022');
INSERT INTO TEST_MAX VALUES('2-FEB-2022');
SELECT MAX(DOB) FROM TEST_MAX;--02-FEB-22

MINIMUM VALUE (MIN)
===================
SELECT MIN(SAL) FROM EMP; --800 , HERE GET MIN VALUE IN SAL COLUMN
SELECT MIN (ENAME) FROM EMP;--ADAMS ,HERE CHECK MIN VALUE IN ALPHABATIC
SELECT MIN(HIREDATE) FROM EMP;-- HERE 1ST PRIORITY IS YEAR, 2ND IS MONTH LIKE 1,2,3,...., THEN 3RD IS DATE 
CREATE TABLE TEST_MAX (DOB DATE);
INSERT INTO TEST_MAX VALUES('10-JAN-2022');
INSERT INTO TEST_MAX VALUES('2-FEB-2022');
SELECT MIN(DOB) FROM TEST_MAX;--01-JAN-22
SELECT MIN (SAL) FROM EMP WHERE DEPTNO=20;

COUNT FUNCTION (COUNT)
======================
SELECT COUNT(*), COUNT(EMPNO), COUNT(JOB), COUNT(COMM) FROM EMP;--14  14  14  4
SELECT COUNT(*) FROM EMP;--HERE COUNT HOW MUCH RECORD AVAILABLE IN EMP TABLE AND WHEN GIVE '*' 
                          --THEN IT IGNORES NULL VALUE
SELECT COUNT(EMPNO) FROM EMP;--14
SELECT COUNT(COMM) FROM EMP;-- 4  ,HERE IGNORES NULL VALUES
SELECT COUNT(NVL(COMM,0)) FROM EMP;--14
SELECT MAX(SAL), MIN(SAL), COUNT(SAL), AVG(SAL) FROM EMP;--5000	800	14	2073.214285714285714285714285714285714286
 
GROUP BY FUNCTION
==================
SELECT SAL, SUM(SAL) FROM EMP;-- ERROR ,NOT A SINGLE A GROUP FUNCTION
SELECT DEPTNO, SUM(SAL ) FROM EMP GROUP BY DEPTNO;
SELECT DISTINCT DEPTNO, SUM (SAL) FROM EMP ;--ERROR
SELECT ENAME, SAL, SUM(SAL) FROM EMP GROUP BY ENAME,SAL;--NOTHING CHNAGE COZ BOTH ARE EQUAL MAINTAIN
SELECT ENAME,DEPTNO FROM EMP GROUP BY DEPTNO, ENAME;
SELECT ENAME, SUM(SAL) FROM EMP GROUP BY ENAME;--ALL ENAME WID THEIR SAL
SELECT JOB , DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO, JOB;
SELECT SUM(SAL) FROM EMP GROUP BY DEPTNO;--SUM SAL IN DEPTNO WISE BT SHOW ONLY SUM(SAL) 
SELECT SUM(SAL) FROM EMP WHERE JOB ='SALESMAN';--HERE SHOW ONLY SALESMAN'S TOTAL SAL
SELECT JOB, SUM(SAL)FROM EMP WHERE JOB = 'SALESMAN' GROUP BY JOB;--SALESMAN JOB WISE SUM SALARY
SELECT JOB, COUNT(JOB)FROM EMP GROUP BY JOB;-- HERE WE GET IN HOW MANY EMPLOYEE IN EACH JOB CATEGORY
SELECT JOB, COUNT(*) FROM EMP GROUP BY JOB;
SELECT JOB, COUNT(JOB)FROM EMP WHERE JOB = 'SALESMAN' GROUP BY JOB;-- HERE NLY SHOW FILTERED COMMAND 
SELECT LPAD(ENAME, 7,'*'), SUM (SAL) FROM EMP GROUP BY LPAD(ENAME, 7,'*');--ENAME LENGTH WISE * ADD LIKE 
                                                            --*MARTIN, **CLARK, ***KING
SELECT MAX(HIREDATE) FROM EMP WHERE ENAME IN ('KING', 'TURNER');
SELECT JOB, SUM(SAL) FROM EMP GROUP BY JOB ORDER BY JOB;--HERE WE KNOW JOB WISE SUM SAL
SELECT JOB, SUM(SAL) FROM EMP GROUP BY JOB ORDER BY  SUM(SAL);--HERE ORDER BY SUM SAL
SELECT JOB ||' RS.' || SUM (SAL) FROM EMP GROUP BY JOB ORDER BY SUM(SAL);
SELECT TO_CHAR(HIREDATE, 'MON') FROM EMP GROUP BY (HIREDATE,'MM'),TO_CHAR(HIREDATE, 'MON') 
    ORDER BY TO_CHAR(HIREDATE, 'MM');

HAVING CLAUSE
==============
 SELECT DEPTNO, COUNT(*) FROM EMP GROUP BY (DEPTNO)HAVING COUNT(*)>3;--HERE HAVING LIKES WHERE CONDITION
 SELECT DEPTNO, COUNT(*) FROM EMP GROUP BY DEPTNO HAVING COUNT(*)>3 ORDER BY COUNT(*);
 SELECT JOB, COUNT(*) FROM EMP WHERE JOB IN ('ANALYST', 'SALESMAN')--1ST FILTER
 GROUP BY(JOB) HAVING COUNT(*)>3--2ND FILTER
 ORDER BY COUNT(*);--3RD FILTER
 SELECT * FROM EMP HAVING ENAME = 'KING';--ERROR COZ  not a GROUP BY expression
SELECT COUNT(*) FROM EMP HAVING COUNT(*)>2;--14
SELECT SUM (SAL) FROM EMP HAVING SUM (SAL)>5000;--29025
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO HAVING MAX(SAL)>2900;
SELECT JOB, SUM(SAL)AS PAYROLL FROM EMP WHERE JOB NOT LIKE 'SALES%' GROUP BY JOB HAVING SUM(SAL)>5000 
                                                                                  ORDER BY SUM(SAL);
SELECT JOB, SUM(SAL)AS PAYROLL FROM EMP  GROUP BY JOB HAVING SUM(SAL)>5000 AND JOB NOT LIKE 'SALES%'
                                                                                  ORDER BY SUM(SAL);
--ABOVE 2 ARE SAME BT QUERY IN DIFFERENT WAY
SELECT DEPTNO, SUM(SAL)+SUM(COMM) FROM EMP GROUP BY DEPTNO HAVING SUM(SAL)+SUM(COMM)>8000;--30  11600
SELECT DEPTNO, AVG(SAL), SUM (SAL) FROM EMP GROUP BY DEPTNO HAVING AVG(SAL)>2500 ;--10  2916....  8750
SELECT * FROM EMP HAVING 15-5=10;-- TRUE CONDN. SHOW WHOLE TABLE
SELECT MIN(ROUND(MAX(AVG(SAL)))) FROM EMP GROUP BY DEPTNO;--group function is nested too deeply

--CONSTRAINTS
--==============
--CONSTRAINT IS A RESTRICTION WHICH DOESN'T ALLOW UNWANTED DATA ENTER INTO A TABLE.
--THERE ARE 6 TYPES.    1.NOT NULL CONSTRAINT
--                      2.UNIQUE CONSTRAINT
--                      3.PRIMARY KEY CONSTRAINT
--                      4.FOREIGN KEY CONSTRAINT
--                      5.CHECK CONSTRAINT
--                      6.DEFAULT (OPTION)
--WE CAN DEFINE CONSTRAINT IN TABLE LEVEL OR COLUMN LEVEL.

--COLUMN LEVEL
--=============
--SPECIFIED CONSTRAINT NEXT IN COLUMN NAME .
--DEFINE WITH EACH COLUMN NAME .
--COMPOSITE KEY CAN'T BE DEFINED IN COLUMN LEVEL.

--TABLE LEVEL 
--===========
--DEFINE CONSTRAINTS AFTER DEFINING ALL COLUMN.
--NOT NULL CAN'T BE DEFINED .
--COMPOSITE KEY IT WILL BE DEFINED AT TABLE LEVEL ONLY

--COMPOSITE KEY
--==============
--IF WE APPLY A CONSTRAINT IS MORE THAN ONE COLUMN THAT'S CALLED COMPOSITE KEY CONSTRAINT.
--COMPOSITE KEY ALWAYS DEFINE AT TABLE LEVEL.

--1.NOT NULL CONSTRAINT 
--======================
CREATE TABLE TEST_5TH_BATCH1 (ID NUMBER CONSTRAINT TEST_5TH_BATCH1_ID_NN NOT NULL);
DESC TEST_5TH_BATCH1;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'TEST_5TH_BATCH1';
--OWNER,CONSTRAINT NAME, TABLE NAME, SERACH CONDITION....
INSERT INTO TEST_5TH_BATCH1 VALUES (10);
INSERT INTO TEST_5TH_BATCH1 VALUES (NULL);-- ERROR  These objects cannot accept NULL values.

CREATE TABLE TEST_5TH_BATCH2(ID NUMBER NOT NULL, NAME VARCHAR2(10)CONSTRAINT TEST_5TH_BATCH2_NAME_NN NOT NULL );
DESC TEST_5TH_BATCH2;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'TEST_5TH_BATCH2';
--OWNER,CONSTRAINT NAME, TABLE NAME, SERACH CONDITION....

--2.UNIQUE CONSTRAINT
--==================
--COLUMN LEVEL
--=============
CREATE TABLE TEST_5TH_BATCH3 (STD_ROLLNO NUMBER CONSTRAINT TEST_5TH_BATCH3_STD_RLNO_UNQ UNIQUE,
                            STD_NAME VARCHAR2(10) 
                            CONSTRAINT TEST_5TH_BATCH3_STD_NAME_NN NOT NULL );
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'TEST_5TH_BATCH3';
DESC TEST_5TH_BATCH3;
INSERT INTO TEST_5TH_BATCH3 VALUES (100, 'HITESH');
INSERT INTO TEST_5TH_BATCH3 VALUES (101, 'NILESH');
INSERT INTO TEST_5TH_BATCH3 VALUES (100, 'RITESH');
--ERROR  An UPDATE or INSERT statement attempted to insert a duplicate key.
INSERT INTO TEST_5TH_BATCH3 VALUES ('', 'RITESH');
INSERT INTO TEST_5TH_BATCH3 VALUES ('', 'RITESH');
INSERT INTO TEST_5TH_BATCH3 VALUES (' ', 'RITESH');--ERROR  invalid number

SELECT * FROM TEST_5TH_BATCH3;

CREATE TABLE TEST_5TH_BATCH6(STD_ROLLNO NUMBER UNIQUE NOT NULL, STD_NAME VARCHAR2(10));

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'TEST_5TH_BATCH6';

INSERT INTO TEST_5TH_BATCH6 VALUES (1,'NIEL');
INSERT INTO TEST_5TH_BATCH6 VALUES (2,'NIEL');
INSERT INTO TEST_5TH_BATCH6 VALUES (1,'NIEL');--ERROR An UPDATE or INSERT statement attempted to 
                                              --insert a duplicate key.
INSERT INTO TEST_5TH_BATCH6 VALUES (2,'AKASH');
-- ERROR An UPDATE or INSERT statement attempted to insert a duplicate key.
INSERT INTO TEST_5TH_BATCH6 VALUES ('','NIEL');
--ERROR  cannot insert NULL into ("SCOTT"."TEST_5TH_BATCH6"."STD_ROLLNO")

TABLE LEVEL
--=============
CREATE TABLE TEST_5TH_BATCH4 (STD_ROLLNO NUMBER, STD_NAME VARCHAR2(10) NOT NULL, 
CONSTRAINT TEST_5TH_BATCH4_STD_RLNO_UNQ UNIQUE(STD_ROLLNO));
INSERT INTO TEST_5TH_BATCH4 VALUES (1, 'NIEL');
INSERT INTO TEST_5TH_BATCH4 VALUES ('', 'NIEL');
INSERT INTO TEST_5TH_BATCH4 VALUES (1, 'NIEL');
--ERROR  Either remove the unique restriction or do not insert the key.
INSERT INTO TEST_5TH_BATCH4 VALUES (0, '');
--ERROR  These objects cannot accept NULL values.

COMPOSITE KEY
==============
CREATE TABLE TEST_5TH_BATCH5 (STD_ROLLNO NUMBER, STD_NAME VARCHAR2(10), 
CONSTRAINT TEST_5TH_BATCH5_STD_RLNO_UNQ UNIQUE(STD_ROLLNO,STD_NAME));
DESC TEST_5TH_BATCH5;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='TEST_5TH_BATCH5';
INSERT INTO TEST_5TH_BATCH5 VALUES (100, 'KRISHNA');
INSERT INTO TEST_5TH_BATCH5 VALUES (100, 'BALARAM');
INSERT INTO TEST_5TH_BATCH5 VALUES (200, 'BALARAM');
INSERT INTO TEST_5TH_BATCH5 VALUES (200, 'BALARAM');
--ERROR An UPDATE or INSERT statement attempted to insert a duplicate key.

3.PRIMARY KEY
============
CREATE TABLE TEST_5TH_BATCH7 (SLNO NUMBER CONSTRAINT TEST_5TH_BATCH7_SLNO_PMKEY PRIMARY KEY,
    STD_ROLLNO NUMBER UNIQUE, STD_NAME VARCHAR2(10));
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'TEST_5TH_BATCH7';    
INSERT INTO TEST_5TH_BATCH7 VALUES (1,100,'ABC');
INSERT INTO TEST_5TH_BATCH7 VALUES (1,200,'PQR');--ERROR  An UPDATE or INSERT statement attempted to
                                                  --insert a duplicate key.
INSERT INTO TEST_5TH_BATCH7 VALUES (NULL,100,'ABC');--ERROE An attempt was made to insert NULL into
                                                      --previously listed objects.
INSERT INTO TEST_5TH_BATCH7 VALUES (3,200,'ABC');

CREATE TABLE TEST_5TH_BATCH71 (SLNO NUMBER, STD_ROLLNO NUMBER, STD_NAME VARCHAR2(10), PRIMARY KEY(SLNO));
INSERT INTO TEST_5TH_BATCH71 VALUES (1,100, 'A');
INSERT INTO TEST_5TH_BATCH71 VALUES (1,100, 'A');
--ERROR  An UPDATE or INSERT statement attempted to insert a duplicate key. 
INSERT INTO TEST_5TH_BATCH71 VALUES (2,100, 'A');

CREATE TABLE TEST_5TH_BATCH8 (SLNO NUMBER, STD_ROLLNO NUMBER, STD_NAME VARCHAR2(10), 
    PRIMARY KEY (SLNO, STD_ROLLNO, STD_NAME));
INSERT INTO TEST_5TH_BATCH8 VALUES (1,100,'A');
INSERT INTO TEST_5TH_BATCH8 VALUES (1,100,'A');--EROR An UPDATE or INSERT statement attempted to 
                                                  --insert a duplicate key.
INSERT INTO TEST_5TH_BATCH8 VALUES (2,100,'A');
INSERT INTO TEST_5TH_BATCH8 VALUES (3,100,'A');
INSERT INTO TEST_5TH_BATCH8 VALUES (1,100,'Z');
INSERT INTO TEST_5TH_BATCH8 VALUES (1,101,'Z');

CREATE TABLE TEST_5TH_BATCH9(SLNO NUMBER, STD_ROLLNO NUMBER, STD_NAME VARCHAR2(10), STD_ADDR VARCHAR2(10),
    PRIMARY KEY(SL_NO, STD_ROLLNO), 
    PRIMARY KEY (STD_NAME, STD_ADDR)) ;--EROR table can have only one primary key

4. FOREIGN KEY
==============
CREATE TABLE ABC_PK2 (ID NUMBER PRIMARY KEY, NAME VARCHAR2(100) NOT NULL, MOB NUMBER UNIQUE);
INSERT INTO ABC_PK2 VALUES(100, 'ABC', 1234);

FOREIGN KEY AT TABLE LEVEL
==========================
CREATE TABLE XYZ_FK2(ID NUMBER, NAME VARCHAR2(10), CONSTRAINT ID_FK2 FOREIGN KEY(ID) REFERENCES ABC_PK2(ID));
SELECT * FROM ABC_PK2;
SELECT * FROM XYZ_FK2;
INSERT INTO XYZ_FK2 VALUES(100, 'A1');
INSERT INTO XYZ_FK2 VALUES(100, 'A1');
INSERT INTO XYZ_FK2 VALUES('', 'A1');
INSERT INTO XYZ_FK2 VALUES('', 'A1');
INSERT INTO XYZ_FK2 VALUES(200, 'A2');--ERROR parent key not found"

CREATE TABLE ABC_PK3 (ID NUMBER UNIQUE, NAME VARCHAR2(10));
INSERT INTO ABC_PK3 (ID) VALUES(1);
SELECT * FROM ABC_PK3 ;

CREATE TABLE XYZ_FK3(ID NUMBER, NAME VARCHAR2(10), FOREIGN KEY (ID) REFERENCES ABC_PK3(ID));
INSERT INTO XYZ_FK3 (ID) VALUES (1);
INSERT INTO XYZ_FK3 (ID) VALUES (2);-- ERROR  violated - parent key not found

FOREIGN KEY AT COLUMN LEVEL
===========================
CREATE TABLE XYZ_FK1(ID NUMBER REFERENCES ABC_PK3(ID));
INSERT INTO XYZ_FK1 VALUES(1);
INSERT INTO XYZ_FK1 VALUES('');
INSERT INTO XYZ_FK1 VALUES(2);--ERROR violated - parent key not found

CREATE TABLE TEST_COMP_FK (ID NUMBER , SLNO NUMBER , FOREIGN KEY (ID) REFERENCES TEST_COMP (ID));--ERROR
--IF WE TAKE PRIMARY KEY IN COMPOSITE THEN WE IT COMPULSARY TO TAKE COMPOSITE IN FOREIGN KEY 

CREATE TABLE TEST_COMP_FK (ID NUMBER REFERENCES  TEST_COMP (ID, SLNO), SLNO NUMBER  );--ERROR

CREATE TABLE TEST_COMP_FK (ID NUMBER , SLNO NUMBER , FOREIGN KEY (ID, SLNO) REFERENCES TEST_COMP (ID,SLNO));
--CREATED 

CHECK CONSTARINT
=================
--IT IS USED TO APPLY A CONDITION OR RULE ON A TABLE COLUMN.
--A SINGLE COLUMN HAVE MULTIPLE CHECK CONSTRAINT.
--WE TAKE N NO. OF CHECK CONSTRAINT ON A COLUMN .
--WE SPECIFY BOTH COLUMN LEVEL AND TABLE LEVEL ALSO.

CREATE TABLE DEPT_MASTER1(DEPTNO NUMBER CONSTRAINT CHK_DEPTNO CHECK(DEPTNO BETWEEN 10 AND 90),
                          DNAME VARCHAR2(15) CONSTRAINT CHK_DNAME_UP CHECK (DNAME = UPPER(DNAME)),
                          LOC VARCHAR2(15) CONSTRAINT CHK_LOC CHECK (LOC IN 
                          ('DALLAS', 'BOSTON', 'NEW WORK', 'CHICAGO')));  
                          
INSERT INTO DEPT_MASTER1(DEPTNO) VALUES (10);
INSERT INTO DEPT_MASTER1(DEPTNO) VALUES (91);--ERROR  check constraint (SCOTT.CHK_DEPTNO) violated
INSERT INTO DEPT_MASTER1(DNAME) VALUES ('NIEL');
INSERT INTO DEPT_MASTER1(DNAME) VALUES ('Nitin');--ERROR check constraint (SCOTT.CHK_DNAME_UP) violated
INSERT INTO DEPT_MASTER1(DNAME) VALUES ('nitin');--ERROR check constraint (SCOTT.CHK_DNAME_UP) violated
INSERT INTO DEPT_MASTER1(LOC) VALUES ('DALLAS');
INSERT INTO DEPT_MASTER1(LOC) VALUES ('BOSTON');
INSERT INTO DEPT_MASTER1(LOC) VALUES ('dallas');--ERROR check constraint (SCOTT.CHK_LOC) violated
INSERT INTO DEPT_MASTER1(LOC) VALUES ('BERHAMPUR');--ERROR check constraint (SCOTT.CHK_LOC) violated
/
CREATE TABLE TEST_CHECK (ID NUMBER, NAME VARCHAR2(10), MOB NUMBER, CHECK (ID BETWEEN 1 AND 1000),
                        CHECK (NAME = INITCAP(NAME)));
INSERT INTO TEST_CHECK VALUES(99, 'Niel', 7788882863);
INSERT INTO TEST_CHECK VALUES(1001,'Niel',143);--ERROR  CHECK CONSTRAINT VIOLATED
/
CREATE TABLE TEST_CHECK2(ID NUMBER, CHECK(ID ^= NULL));
INSERT INTO TEST_CHECK2 VALUES(NULL);-- NULL ALWAYS SPECIFIED VALUE SO IT TAKE.

SELECT * FROM TEST_CHECK2;

/
DEFAULT (OPTION) CONSTRAINT 
===========================
--THIS CONSTRAINT WE CAN'T APLLY IN TABLE LEVEL.

CREATE TABLE TEST_DEFAULT1(ID NUMBER, SAL NUMBER DEFAULT 100);
INSERT INTO TEST_DEFAULT1(ID) VALUES(1);
SELECT * FROM TEST_DEFAULT1;--HERE WE GIVE ONE VALUE(ID) BUT DEFAULT IS 100 SO HERE DEFAULT VALUE IS 100
/
CREATE TABLE EMP_NEW2 (EMPNO NUMBER PRIMARY KEY,
                      ENAME VARCHAR2(10) NOT NULL CHECK(ENAME = UPPER(ENAME)), 
                      JOB VARCHAR2(10) NOT NULL CHECK (JOB = LOWER(JOB)),
                      MGR NUMBER, 
                      HIREDATE DATE DEFAULT SYSDATE,
                      SAL NUMBER(7,2) NOT NULL,
                      CHECK (SAL BETWEEN 2000 AND 100000),
                      COMM NUMBER(7,2),
                      DEPTNO NUMBER,
                      CHECK (SAL + COMM <= 100000));
                      
INSERT INTO EMP_NEW2(EMPNO, ENAME, JOB, SAL) VALUES (1, 'NIEL', 'swe', 55000);
INSERT INTO EMP_NEW2(EMPNO, ENAME, JOB, SAL, COMM) VALUES (1000, 'ABC', 'SWE', 99900, 100);--ERROR 
--CHECK JOB=LOWER(JOB)

INSERT INTO EMP_NEW2(EMPNO, ENAME, JOB, SAL, COMM) VALUES (1000, 'ABC', 'swe', 99900, 100);
INSERT INTO EMP_NEW2(EMPNO, ENAME, JOB, SAL, COMM) VALUES (1000, 'ABC', 'swe', 99900, 101);--ERROR  
--SAL + COMM <= 100000

ADD CONSTRAINT TO A TABLE
===========================
CREATE TABLE EMP_DUP AS SELECT * FROM EMP;--make a duplicate table with only column name and their value
ALTER TABLE <TABLE NAME> ADD <CONSTRAINT NAME> CONSTRAINT(COLUMN NAME)
/
ALTER TABLE EMP_DUP ADD CONSTRAINT EMP_DUP_NO_PK PRIMARY KEY(EMPNO);
ALTER TABLE EMP_DUP ADD CONSTRAINT EMP_DUP_DEPTNO_UK UNIQUE (DEPTNO);--ERROR  CANT VALID COZ THERE DUPLICATE VALUE ALREADY THERE.
ALTER TABLE EMP_DUP ADD CONSTRAINT EMP_DUP_MGR_FK FOREIGN KEY(MGR) REFERENCES EMP_DUP(EMPNO);

MODIFY CONSTRAINT TO A TABLE
============================
ALTER TABLE <TABLE NAME> MODIFY <COLUMN NAME>  <CONSTRAINT NAME> CONSTRAINT
/
ALTER TABLE EMP_DUP MODIFY ENAME CONSTRAINT EMP_DUP_ENAME_NN NOT NULL ;
ALTER TABLE EMP_DUP MODIFY COMM CONSTRAINT EMP_DUP_COMM_DEF DEFAULT 200;--ERROR 
--constraint specification not allowed here

ALTER TABLE EMP_DUP MODIFY COMM  DEFAULT 100; 

DROPING CONSTRAINT 
===================
ALTER TABLE <TABLE NAME > DROP <CONSTRAINT NAME>;
/
ALTER TABLE EMP_DUP DROP CONSTRAINT EMP_DUP_MGR_FK;--HERE WE DROP THE CONSTRAINT
ALTER TABLE EMP_DUP DROP CONSTRAINT EMP_DUP_NO_PK;--HERE ALSO
ALTER TABLE EMP_DUP DROP FOREIGN KEY(MGR);-- ERROR  MISSING KEYWORD

ALTER TABLE <TABLE_NAME> DROP PRIMARY KEY;
--ONLY WE CAN DROP PRIAMRY KEY CONSTRAINT USING CONSTRAINT TYPE 
--BUT THIS ONE POSSIBLE FOR ONLY PRIMARY KEY NOTHING ELSE.

--WE CAN ALSO DROP MULTIPLE CONSTRAINT AT A TIME :
--==================================================
--SYNTAX :
--==========
ALTER TABLE < TABLE_NAME > DROP CONSTRAINT_1 DROP CONSTRAINT2;

DROP PARENT TABLE
===================
DROP TABLE TODAY  CONSTRAINT  CASCADE;

CASCADE 
========
ALTER TABLE EMP_DUP DROP CONSTRAINT EMP_DUP_MGR_PK CASCADE;
ALTER TABLE EMP_DUP DROP CONSTRAINT PRIMARY KEY (MGR)CASCADE;-- ERROR   INVALID ALTER TABLE OPTION

ON DELETE CASCADE
=================
CREATE TABLE PARENT11(PARENT_ID NUMBER CONSTRAINT PARENT11_ID_PK PRIMARY KEY, 
                        PARENT_NAME VARCHAR2(10));
INSERT INTO PARENT11 VALUES(100, 'KRISHNA');
INSERT INTO PARENT11 VALUES(200, 'KRISHNA');
COMMIT;
SELECT * FROM PARENT11;

CREATE TABLE CHILD11(PARENT_ID NUMBER,
                      CHILD_ID NUMBER,
                      CHILD_NAME VARCHAR2(10),
                      CONSTRAINT CHILD11_ID_FK FOREIGN KEY(PARENT_ID) REFERENCES PARENT11(PARENT_ID)
                      ON DELETE CASCADE);
INSERT INTO CHILD11 VALUES (100, 1, 'HARI');
INSERT INTO CHILD11 VALUES (100, 2, 'HARISH');
INSERT INTO CHILD11 VALUES (200, 1, 'SURESH');
INSERT INTO CHILD11 VALUES (200, 2, 'SUMIT');
COMMIT;
SELECT * FROM CHILD11;
DELETE FROM PARENT11 WHERE PARENT_ID = 100;-- HERE DELETE PARRENT COLUMN WITH THEIR CHILD
SELECT * FROM PARENT11;
SELECT * FROM CHILD11;

CREATE TABLE X (ID NUMBER CONSTRAINT X_ID_PK PRIMARY KEY, NAME VARCHAR2(10) );
INSERT INTO X VALUES (1, 'NIEL');
INSERT INTO X VALUES (2, 'CHINU');
INSERT INTO X VALUES (3, 'NIEL');
CREATE TABLE Y (ID NUMBER, NAME VARCHAR2(10), CONSTRAINT Y_ID_FK FOREIGN KEY(ID) REFERENCES X (ID)
                ON DELETE CASCADE);
INSERT INTO Y VALUES(1, 'BABY');
INSERT INTO Y VALUES(2, 'BABY2');
ALTER TABLE X DROP CONSTRAINT X_ID_PK ;
SELECT * FROM X;

ON DELETE SET NULL
==================== 
CREATE TABLE PARENT111 (PARENT_ID NUMBER CONSTRAINT PARENT111_NO_PK PRIMARY KEY,
                        PARENT_NAME VARCHAR2(10));
INSERT INTO PARENT111 VALUES(100, 'KRISHNA')                        ;
INSERT INTO PARENT111 VALUES(200, 'SHYAM')                        ;
COMMIT;
SELECT * FROM PARENT111;

CREATE TABLE CHILD111(PARENT_ID NUMBER, 
                      CHILD_ID NUMBER,
                      CHILD_NAME VARCHAR2(10),
                      CONSTRAINT PARENT111_NO_FK FOREIGN KEY(PARENT_ID) REFERENCES PARENT111(PARENT_ID)
                      ON DELETE SET NULL);
INSERT INTO CHILD111 VALUES(100, 1, 'HARI');
INSERT INTO CHILD111 VALUES(100, 2, 'HARISH');
INSERT INTO CHILD111 VALUES(200, 1, 'SURESH');
INSERT INTO CHILD111 VALUES(200, 2, 'SUMIT');
COMMIT;
DELETE FROM PARENT111 WHERE PARENT_ID = 100;--HERE IN PARENT TABLE DATA WILL BE DELETED AND CHILD TABLE WHICH 
                                              --HAVE RELATION THEY ARE NULL
SELECT * FROM PARENT111;
SELECT * FROM CHILD111;

DISABLE CONSTRAINT
====================
ALTER TABLE EMP_DUP DISABLE CONSTRAINT EMP_DUP_MGR_PK CASCADE;
ALTER TABLE EMP_DUP DISABLE CONSTRAINT EMP_DUP_MGR_FK;

ENABLE CONSTRAINT
==================
ALTER TABLE EMP_DUP ENABLE CONSTRAINT EMP_DUP_MGR_PK ;
ALTER TABLE EMP_DUP ENABLE CONSTRAINT EMP_DUP_MGR_FK;

--DICTIONARY TABLE OF CONSTRAINT
=================================
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMP_DUP';


NORMALIZATION
=============
CREATE TABLE TABLE3 (SALUTATION_ID NUMBER CONSTRAINT TABLE3_SID_PK PRIMARY KEY,
                      SALUTATION VARCHAR2(10));
INSERT INTO TABLE3 VALUES(1, 'MR')                      ;
INSERT INTO TABLE3 VALUES(2, 'MS')                      ;
INSERT INTO TABLE3 VALUES(3, 'MRS')                      ;
INSERT INTO TABLE3 VALUES(4, 'DR')                      ;
SELECT * FROM TABLE3;

CREATE TABLE TABLE1(MEMBERSHIP_ID NUMBER CONSTRAINT TABLE1_MID_PK PRIMARY KEY ,
                    FULL_NAME VARCHAR2(10), 
                    PHYSICAL_ADDRESS VARCHAR2(50),
                    SALUTATION_ID NUMBER CONSTRAINT TABLE_1_SID_FK REFERENCES TABLE3(SALUTATION_ID));
INSERT INTO TABLE1 VALUES(1, 'JANET JONE', 'FIRST STREET PLOT NO 4',1 );                    
INSERT INTO TABLE1 VALUES(2, 'ROBERT PHI', '3RD STREET 34',2 );
INSERT INTO TABLE1 VALUES(3, 'ROBERT PHI', '5TH AVENUE',3 );                    
SELECT * FROM TABLE1;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'TABLE1';

CREATE TABLE TABLE2 (MEMBERSHIP_ID NUMBER CONSTRAINT TABLE2_MID_FK REFERENCES TABLE1(MEMBERSHIP_ID),
                      MOVIES_RENTED VARCHAR2(50));
INSERT INTO TABLE2 VALUES(1,'PIRATES OF THE CARIBBEAN' );
INSERT INTO TABLE2 VALUES(1, 'CLASH OF TITANS');
INSERT INTO TABLE2 VALUES(2, 'FORGETTING SARAH MARSHAL');
INSERT INTO TABLE2 VALUES(2, 'DADDYS LITTLE GIRL');
INSERT INTO TABLE2 VALUES(3, 'CLASH OF THE TITANS');
INSERT INTO TABLE2 VALUES(1, 'IT''S MY WORLD'); .
SELECT * FROM TABLE2;



















E R MODEL-- (ENTITY RELATIONSHIP MODEL)
=========


















JOIN :
============

CREATE TABLE NIEL26 (ID NUMBER, FIRST VARCHAR2(10), LAST VARCHAR2(10));
INSERT INTO NIEL26 VALUES (1, 'NIEL' ,'SAHU');
INSERT INTO NIEL26 VALUES (2, 'NITIN', 'SAHU');
INSERT INTO NIEL26 VALUES(3, 'MUKESH', 'BEHERA');
INSERT INTO NIEL26 VALUES(4, 'RAKESH', 'PANDA');
INSERT INTO NIEL26 VALUES(5, 'BIKASH', 'NAHAK');
COMMIT; 
SELECT * FROM  NIEL26;

CREATE TABLE CLASS (ID NUMBER, CNAME VARCHAR2(10), COLLEGE VARCHAR2(30));
INSERT INTO CLASS VALUES (1, 'ORACLE', 'GIST');
INSERT INTO CLASS VALUES (5, 'C++', 'GIST');
INSERT INTO CLASS VALUES (10, 'C', 'ROLAND');
INSERT INTO CLASS VALUES (12, 'JAVA', 'NIST');
COMMIT;
SELECT * FROM NIEL26;
SELECT * FROM CLASS;

CROSS JOIN 
=============
/
SELECT E.ENAME, D.DNAME FROM EMP E CROSS JOIN DEPT D;--ANSI STANDARD
SELECT E.ENAME AS "1", D.DNAME AS "2" FROM EMP E , DEPT D;--ORA STANDARD
SELECT NIEL26.* FROM NIEL26;
SELECT * FROM NIEL26;
SELECT * FROM CLASS;
SELECT CNAME FROM NIEL26 CROSS JOIN CLASS ;--20 RECORD
SELECT C.ID FROM NIEL26 N ,  CLASS C;--ORA FORMAT


INNER JOIN 
/
SELECT * FROM NIEL26 INNER JOIN CLASS ON NIEL26.ID = CLASS.ID;-- OP ONLY ID 1,5
SELECT NIEL26.* FROM NIEL26 INNER JOIN CLASS ON NIEL26.ID= CLASS.ID;

Q.DISPLAY EMPNO, ENAME, DEPTNO, DNAME, LOC OF SCOTT AND KING AND WHO ARE WORKING IN RESEARCH DEPT 
SELECT E. EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DNAME , D.LOC, D.DEPTNO AS DDEPT 
    FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO WHERE ENAME IN ('SCOTT', 'KING')
    AND D.DNAME = 'RESEARCH';
CREATE TABLE DEPT_ADDR_JOIN (DEPTNO NUMBER, ADDRESS VARCHAR2(20))    ;
INSERT INTO DEPT_ADDR_JOIN VALUES (20, 'BAM TULSI NAGAR');
COMMIT;
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DNAME, D.LOC, D.DEPTNO AS DEPT, A. ADDRESS
    FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
    INNER JOIN DEPT_ADDR_JOIN A ON  A.DEPTNO = D.DEPTNO ;
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DNAME, D.LOC, D.DEPTNO AS DEPT, A. ADDRESS
    FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
    INNER JOIN DEPT_ADDR_JOIN A ON  A.DEPTNO = D.DEPTNO WHERE E.ENAME = 'ADAMS';
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DNAME, D.LOC, D.DEPTNO AS DDEPT 
    FROM EMP E INNER JOIN DEPT D ON E.ENAME = D.LOC;--OP BLANK COZ HERE NO MATCHING VALUE
SELECT E.ENAME, E.JOB, D.DEPTNO FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE D.DEPTNO IN (10,20) 
    AND E.ENAME = 'KING';
SELECT ENAME, DEPTNO FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;--ERROR    column ambiguously defined
SELECT * FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE COMM IS NULL AND SAL BETWEEN 1100 AND 2500;
SELECT D.LOC, COUNT(*) 
    FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO WHERE D.LOC = 'NEW YORK' GROUP BY (D.LOC);
SELECT D.LOC, COUNT(*) 
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO WHERE D.LOC IN ('NEW YORK', 'CHICAGO') GROUP BY D.LOC;
SELECT E.ENAME, D.LOC, E.SAL,E.DEPTNO ,COUNT(*)
    FROM EMP E INNER JOIN DEPT D
    ON (D.DEPTNO = E.DEPTNO) 
    INNER JOIN DEPT_ADDR_JOIN A ON D.DEPTNO = A.DEPTNO 
    WHERE D.LOC IN ('NEW YORK', 'CHICAGO', 'DALLAS')--1ST FILTER
    AND E.SAL BETWEEN 1000 AND 3000--2ND FILTER
    GROUP BY D.LOC,E.ENAME, E.SAL, E.DEPTNO;

SELECT E.SAL , S.GRADE FROM EMP E INNER JOIN SALGRADE S 
    ON E.SAL BETWEEN S.LOSAL AND S. HISAL;

LEFT JOIN
/
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DEPTNO AS DDEPT, D.DNAME, D.LOC
    FROM EMP E LEFT JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;--ANSI STANDARD
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DEPTNO AS DDEPT, D.DNAME, D.LOC
    FROM EMP E , DEPT D
    WHERE E.DEPTNO = D.DEPTNO(+);--ORA STANDARD
SELECT * FROM A LEFT JOIN B ON A.ID = B.ID;
SELECT E.EMPNO, E.ENAME, D.DEPTNO FROM EMP E LEFT JOIN DEPT D ON E.DEPTNO = D.DEPTNO;
SELECT * FROM EMP E LEFT JOIN DEPT_ADDR_JOIN A ON E.DEPTNO = A.DEPTNO;
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT , D.DEPTNO AS DDEPT FROM EMP E LEFT JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO;
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT , D.DNAME, D.LOC, D.DEPTNO AS DDEPT, A.DEPTNO AS ADEPT
    FROM EMP E LEFT JOIN DEPT D  ON E.DEPTNO = D.DEPTNO
    LEFT JOIN DEPT_ADDR_JOIN A  ON E.DEPTNO = A.DEPTNO;
    
RIGHT JOIN 
/
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DEPTNO AS DDEPT, D.DNAME, D.LOC
    FROM EMP E RIGHT JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;--ANSI STANDARD
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DEPTNO AS DDEPT, D.DNAME, D.LOC
    FROM EMP E , DEPT D
    WHERE E.DEPTNO(+) = D.DEPTNO;--ORA STANDARD
SELECT * FROM A RIGHT JOIN B ON A.ID = B.ID;
SELECT E.EMPNO, E.ENAME, D.DEPTNO FROM EMP E RIGHT JOIN DEPT D ON E.DEPTNO = D.DEPTNO;
SELECT * FROM EMP E RIGHT JOIN DEPT_ADDR_JOIN A ON E.DEPTNO = A.DEPTNO;
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT , D.DEPTNO AS DDEPT 
    FROM EMP E RIGHT JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO;
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT , D.DNAME, D.LOC, D.DEPTNO AS DDEPT, A.DEPTNO AS ADEPT
    FROM EMP E RIGHT JOIN DEPT D  ON E.DEPTNO = D.DEPTNO
    RIGHT JOIN DEPT_ADDR_JOIN A  ON E.DEPTNO = A.DEPTNO;

FULL JOIN 
/
SELECT E.EMPNO, E.ENAME, E.DEPTNO AS EDEPT, D.DEPTNO AS DDEPT, D.DNAME, D.LOC
    FROM EMP E FULL JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;--ANSI STANDARD
SELECT * FROM A FULL JOIN B ON A.ID = B.ID;
SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT D.DNAME, COUNT(* ) AS CNT
    FROM EMP E FULL JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO GROUP BY D.DNAME;--OP DNAME WITH COUNT(*)
SELECT D.DNAME, COUNT(*) AS CNT
    FROM EMP E FULL JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO GROUP BY (D.DNAME) HAVING COUNT(*)>3;
SELECT D.LOC, COUNT(*) 
    FROM EMP E FULL JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO WHERE D.LOC = 'NEW YORK' GROUP BY (D.LOC);
SELECT N.FIRST, N.LAST , C.COLLEGE, N.ID, C.ID FROM NIEL26 N FULL JOIN CLASS C 
    ON N.ID = C.ID;
    
NON EQUI JOIN
/
SELECT * FROM SALGRADE;
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
    FROM EMP E INNER JOIN SALGRADE S
    ON E.SAL BETWEEN S.LOSAL AND S.HISAL;--OP GRADE OF ALL EMP'S SAL
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
    FROM EMP E , SALGRADE S
    WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;--ORA STANDARD
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
    FROM EMP E INNER JOIN SALGRADE S
    ON E.SAL >= S.LOSAL  AND E.SAL <= S.HISAL;--SAME OP
    
SELF JOIN 
/
SELECT * FROM EMP;
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS MANAGER 
    FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO;
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS MANAGER 
    FROM EMP E1 INNER JOIN EMP E2 
    ON E1.MGR = E2.EMPNO;
SELECT E1.ENAME , E2.MGR AS MANAGER FROM EMP E1 INNER JOIN EMP E2 ON E1.EMPNO = E2.MGR;
SELECT E1.ENAME, E2.ENAME AS MANAGER FROM EMP E1 ,  EMP E2 WHERE   E1.MGR = E2. EMPNO;

--Q.WHICH EMPLOYEE SAL IS GREATER THAN FROM THEIR MGR SAL ?
SELECT E.ENAME , E.SAL , E2.ENAME, E2.SAL FROM EMP E INNER JOIN EMP E2 
        ON E.MGR = E2.EMPNO
        WHERE E.SAL > E2.SAL;
        
NATURAL JOIN 
/
SELECT ENAME, DEPTNO, DNAME,LOC FROM EMP NATURAL JOIN DEPT;--OP LIKE SAME WORK AS INNER JOIN
SELECT ENAME, DEPTNO, DNAME, LOC FROM EMP JOIN DEPT USING (DEPTNO);

/
SELECT SAL FROM EMP WHERE  ENAME = 'SMITH';
SELECT * FROM EMP WHERE SAL = 800;
SELECT MAX(SAL) FROM EMP;
SELECT ENAME FROM EMP WHERE SAL =5000;
SELECT ENAME, MAX(SAL ) FROM EMP GROUP BY (ENAME);
SELECT * FROM EMP AS E1 WHERE SAL = (SELECT MAX(SAL) FROM EMP)




SUB QUERY
/
SELECT * FROM EMP WHERE SAL = (SELECT MAX(SAL) FROM EMP);--HERE WE GET MAX(SAL) DETAILS
SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'SMITH');--HERE GET HIGHEST SAL FROM SMITH
SELECT * FROM EMP WHERE SAL > 
    (SELECT SAL FROM EMP WHERE ENAME = 'SMITH' ORDER BY);--HERE ORDER BY CLAUSE CAN'T USE IN INLINE 
SELECT * FROM EMP WHERE SAL > 
    (SELECT SAL FROM EMP WHERE ENAME = 'SMITH' )ORDER BY ENAME;
    
Q.WHO IS GETTING MORE SALARY THEN ALLEN'S SALARY?'
SELECT * FROM EMP WHERE SAL >(
    SELECT SAL FROM EMP WHERE ENAME = 'ALLEN');
 
Q.FIND IN EMP TABLE WHICH EMPLOYESS DATE AND MONTH EQUAL IN HIREDATE ?''
SELECT * FROM EMP WHERE  TO_CHAR(HIREDATE, 'DD MM') =(
SELECT TO_CHAR(HIREDATE, 'DD MM') FROM EMP GROUP BY (TO_CHAR(HIREDATE, 'DD MM'))  HAVING COUNT(*)>1)  ;

Q. WHO IS GETTING LESS SALARY THEN ALLEN'S' SALARY?
SELECT * FROM EMP WHERE SAL < (
    SELECT SAL FROM EMP WHERE ENAME = 'ALLEN');
    
Q.DISPLAY ENAME, SAL , JOB, FOR THOSE EMPLOYEES WHO ARE GETTING MORE SALARY THEN 7566 ?
SELECT ENAME, SAL, JOB FROM EMP WHERE SAL > (
    SELECT SAL FROM EMP WHERE EMPNO = 7566);
    
Q.DISPLAY ENAME, SAL, JOB FOR THOSE EMPLOYEES WHO IS WORKING WITH SMITH'S JOB ?'
SELECT ENAME, SAL, JOB FROM EMP WHERE JOB = (
    SELECT JOB FROM EMP WHERE ENAME = 'SMITH');
    
Q.WHO IS WORKING UNDER SALES DEPARTMENT ?
SELECT * FROM EMP WHERE DEPTNO = (
    SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');
SELECT E.* 
    FROM EMP E INNER JOIN DEPT D     
    ON E.DEPTNO = D.DEPTNO
    WHERE D.DNAME = 'SALES';--INNER JOIN
    
Q.DISPLAY MONTHLY INCOME OF ALL EMPLOYEE WHO ARE WORKING AT DALLAS LOCATION ?
SELECT EMPNO, ENAME, SAL, COMM, SAL + NVL(COMM, 0) AS MONTHLY_INCOME FROM EMP WHERE DEPTNO = (
    SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');
    
SELECT E.EMPNO, E.ENAME, E.SAL, E.COMM , E.SAL+NVL(E.COMM,0) AS MONTHLY_INCOME
    FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO
    WHERE D.LOC = 'DALLAS';

SELECT E.EMPNO, E.ENAME, E.SAL, E.COMM , E.SAL+NVL(E.COMM,0) AS MONTHLY_INCOME
    FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO
    WHERE D.LOC = 'BAM';--HERE OP BLANK COZ NO MATCHING VALUE 
    
Q.WHO IS GETTING HIGHEST SALARY DISPLAY THE PERSON'S' NAME JOB ,SALARY?    
SELECT ENAME, JOB, SAL FROM EMP WHERE SAL = (
    SELECT MAX(SAL) FROM EMP);
    
Q.WHO IS GETTING LOWEST SALARY DISPLAY THE PERSON'S' NAME JOB ,SALARY?    
SELECT ENAME, JOB, SAL FROM EMP WHERE SAL = (
    SELECT MIN(SAL) FROM EMP);
    
Q. WHO IS 1ST EMPLOYEE HIRING ON EMP?
SELECT * FROM EMP WHERE HIREDATE = (
    SELECT MIN(HIREDATE) FROM EMP);
    
Q. WHO IS LAST EMPLOYEE HIRING ON EMP?
SELECT * FROM EMP WHERE HIREDATE = (
    SELECT MAX(HIREDATE) FROM EMP);
    
Q.SHOW WHOSE EMPLOYEES ARE JOINED BEFORE JONES ?
SELECT * FROM EMP WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'JONES');

Q.WHO IS GETTING SECOND HIGHEST SALARY;
SELECT * FROM EMP   WHERE SAL =(
SELECT MAX(SAL) FROM EMP WHERE SAL < (
SELECT MAX(SAL) FROM EMP));

Q.WHO IS GETTING MORE SALARY THEN ALL EMPLOYEES AVERAGE SALARY ?
SELECT * FROM EMP WHERE SAL > (
    SELECT AVG(SAL) FROM EMP);

Q.DISPLAY DEPTNO AND MINIMUM SAL GROUPS , HAVING MINIMUM SALARY GREATER THAN DEPARTMENT 20'S' MINIMUM SALARY ?
SELECT DEPTNO, MIN (SAL) FROM EMP GROUP BY DEPTNO HAVING MIN (SAL)> (
    SELECT MIN(SAL) FROM EMP WHERE DEPTNO = 20);
        
Q.DISPLAY THE JOB GROUPS HAVING TOTAL SALARY GREATER THEN THE MAXIMUM SALARY FOR MANAGER ?
SELECT JOB FROM EMP GROUP BY JOB HAVING SUM(SAL) > (
    SELECT MAX (SAL) FROM EMP WHERE JOB = 'MANAGER'); 

Q. WHO ARE WORKING AS A MANAGER , DISPLAY MANAGER'S' INFORMATION ?
SELECT * FROM EMP WHERE ENAME IN (SELECT ENAME FROM EMP WHERE JOB  = 'MANAGER');

SELECT * FROM EMP WHERE EMPNO IN (
SELECT MGR FROM EMP);

Q.DISPLAY THE JOB GROUPS HAVING TOTAL SALARY GREATER THAN THE MAXIMUM SALARY FOR WORKING AS A MANAGER ?
SELECT JOB FROM EMP GROUP BY JOB HAVING SUM(SAL) > (
    SELECT MAX(SAL) FROM EMP WHERE EMPNO IN (
    SELECT MGR FROM EMP));

Q.IS JONES A MANAGER OR NOT ?
  WHO ALL ARE WORKING UNDER  JONES ?
SELECT * FROM EMP WHERE MGR = (
  SELECT EMPNO FROM EMP WHERE  ENAME  = 'JONES');
  
Q.DISPLAY JONES MANAGER DETAILS ?
SELECT * FROM EMP WHERE EMPNO = (
    SELECT MGR FROM EMP WHERE ENAME = 'JONES');

Q.FIND THOSE EMPLOYEES WHO GET HIGHER SALARY THAN THE EMPLOYEE WHO DON'T' HAVE MGR ?
SELECT ENAME, MAX(SAL) FROM EMP GROUP BY ENAME, EMPNO  HAVING EMPNO =(
    SELECT EMPNO FROM EMP WHERE MGR IS NULL);
    
    
MULTIPLE ROW SUB QUERIES 
/
IN
/
Q. DISPLAY THE NAMES OF THE EMPLOYEES WHO EARN HIGHEST SALARY IN THEIR RESPECTIVE DEPARTMENT ?
SELECT ENAME FROM EMP WHERE SAL IN (
    SELECT MAX(SAL) FROM EMP  GROUP BY DEPTNO);   
    
Q.DISPLAY THE NAMES OF EMPS WHO EARN HIGHEST SALARIES IN THEIR RESPECTIVE JOB GROUPS ?
SELECT ENAME FROM EMP WHERE SAL IN (
    SELECT MAX(SAL) FROM EMP GROUP BY JOB); 
    
Q.LIST THE DEPARTMENT NAME THAT HAVING AT LEAST ONE EMPLOYEE ?
SELECT DNAME FROM DEPT WHERE DEPTNO IN (
    SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*)>=1);
    
Q.DISPLAY MANAGER'S'NAME ?
SELECT ENAME FROM EMP WHERE EMPNO IN (
    SELECT MGR FROM EMP);
    
< ANY (LESS THAN ANY)    
/
LESSR THAN THE GREATEST NO. RETURN FROM THE SUB QUERY
/
SELECT * FROM EMP WHERE DEPTNO < ANY (20,30);--HERE WE GET LESSER THAN NO. OF MAX NO. ALL VALUE
SELECT * FROM EMP WHERE DEPTNO <ANY (20);--ONLY 10 DEPT'S DETAIL
Q.DISPLAY ALL THE EMPLOYEES WHO ARE EARNING LESS THAN ANY OF THE SALESMAN ?
SELECT * FROM EMP WHERE SAL < ANY(
    SELECT SAL FROM EMP WHERE JOB = 'SALESMAN')  AND JOB <> 'SALESMAN';

Q.DISPLAY ALL THE EMPLOYEES WHO ARE EARNING LESS THAN ANY OF THE DEPARTMENT 20 ?
SELECT ENAME FROM EMP WHERE SAL < ANY (
    SELECT SAL FROM EMP WHERE DEPTNO = 20) ;

>ANY 
GREATER THAN SMALLEST VALUE 
SELECT * FROM EMP WHERE DEPTNO > ANY (20);--HERE WE ONLY GET 30 DEPTNO DETAILS
SELECT * FROM EMP WHERE DEPTNO > ANY(10,20);--20 AND UP DEPTNO

Q.DISPLAY ALL EMPLOYEES WHO ARE EARNING GREATER THAN ANY OF THE SALESMAN ?
SELECT * FROM EMP WHERE SAL > ANY (
    SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');--SMALLEST VALUE OF SALESMAN IS 1250 THEN IT SHOWS UPWARD TO THEIR CONDN.

SELECT * FROM EMP WHERE SAL > ANY (500, 1100);
SELECT * FROM EMP WHERE COMM > ANY (NULL, 300);-- HERE NULL IS UNDEFINED SO IT STARTS FROM FILTER TO 300


> ALL OPERATOR
/
IT MEANS GREATER THAN THE GREATEST NO. RETURN FROM THE SUB QUERY
/
SELECT * FROM EMP WHERE DEPTNO > ALL (10,20);-- HERE ONLY WE GET 30 DEPTNO DETAILS

Q.DISPLAY ALL THE EMPLOYEES WHO EARN MORE THAN ALL THE MANAGER JOB
SELECT * FROM EMP WHERE SAL > ALL (
    SELECT SAL FROM EMP WHERE JOB = 'MANAGER');-- HERE WE GET THE MAX VALUE OF MANAGER IS 2850 IT WILL SHOW
                                                --AFTER ALL GREATEST VALUE FROM COND.

Q.DISPLAY ALL THE EMPLOYEES WHO EARN MORE THAN MANAGER SALARY ?
SELECT * FROM EMP WHERE SAL > ALL(
SELECT SAL FROM EMP WHERE JOB = 'MANAGER');
--OR
SELECT * FROM EMP WHERE SAL >(
SELECT MAX(SAL) FROM EMP GROUP BY JOB HAVING JOB = 'MANAGER');

< ALL OPERATOR
/
IT MEANS LOWER THAN THE LOWEST NO RETURN FROM SUB QUERY
/
SELECT * FROM EMP WHERE DEPTNO < ALL (20,30);--ONLY 10 DEPTNO'S DETAILS

Q.DISPLAY ALL THE EMPLOYEES WHO EARN LESS THAN ALL MANAGER SALARY ?
SELECT * FROM EMP WHERE SAL < ALL(
    SELECT SAL FROM EMP WHERE JOB = 'MANAGER');--LOWER 
--OR 
SELECT * FROM EMP WHERE SAL < (
    SELECT MIN(SAL) FROM EMP GROUP BY JOB HAVING JOB = 'MANAGER');

Q.DISPLAY DETAILS MAX SAL DEPT WISE ?


SELECT * FROM EMP WHERE (DEPTNO, SAL) IN (
    SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);
    
PAIR WISE COMPARISON
/
Q.DISPLAY DEPARTMENT WISE MAXIMUM SALARY GETTING EMPLOYEE INFORMATION ?
SELECT * FROM EMP WHERE (DEPTNO, SAL) IN (
    SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);
--OR
SELECT * FROM EMP WHERE SAL IN (
    SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
    
CREATE TABLE SET_TEST1 (ID NUMBER, NAME CHAR );
INSERT INTO  SET_TEST1 VALUES (1,'A');
INSERT INTO  SET_TEST1 VALUES (2,'B');
INSERT INTO  SET_TEST1 VALUES (3,'C');
INSERT INTO  SET_TEST1 VALUES (4,'D');
INSERT INTO  SET_TEST1 VALUES (5,'X');
INSERT INTO  SET_TEST1 VALUES (6,'w');
SELECT * FROM SET_TEST1;

CREATE TABLE SET_TEST2 (ID NUMBER, NAME CHAR );
INSERT INTO  SET_TEST2 VALUES  (1,'A');
INSERT INTO  SET_TEST2 VALUES (2,'B');
INSERT INTO  SET_TEST2 VALUES (6,'P');
INSERT INTO  SET_TEST2 VALUES (7,'Q');
INSERT INTO  SET_TEST2 VALUES (5,'Z');
INSERT INTO  SET_TEST2 VALUES (6,'W');
SELECT * FROM SET_TEST2;
COMMIT;

Q.TO IDENTIFY THE TABLE1 RECORDS WHICH ARE NOT AVAILABLE IN TABLE 2 ?
SELECT * FROM SET_TEST1 WHERE ID NOT IN (
    SELECT ID FROM SET_TEST2 ) OR NAME NOT IN (SELECT NAME FROM SET_TEST2);
--OR    
SELECT * FROM SET_TEST1 WHERE (ID, NAME) NOT IN (SELECT ID, NAME FROM SET_TEST2);


NON - PAIR WISE COMPARISON
/
Q. WRITE A QUERY TO DISPLAY ALL THE EMPLOYEES WHOSE JOB NOT SAME AS ALLEN AND SALARY IS GREATER THAN MARTIN ?
SELECT * FROM EMP WHERE JOB <>(
    SELECT JOB FROM EMP WHERE ENAME = 'ALLEN')
    AND SAL >(SELECT SAL FROM EMP WHERE ENAME = 'MARTIN');
    
Q.LIST THE EMPLOYEES WHO ARE LOCATED IN CHICAGO AND THEIR COMMINSION IS ZERO ?
SELECT * FROM EMP WHERE DEPTNO =(
    SELECT DEPTNO FROM DEPT WHERE LOC ='CHICAGO') AND COMM = 0;

Q.LIST EMPLOYEES WHO ARE WORKING IN RESEARCH DEPARTMENT AND THEY ARE MANAGER ?
SELECT * FROM EMP WHERE DEPTNO IN(
    SELECT DEPTNO FROM DEPT WHERE DNAME= 'RESEARCH' )
    AND  EMPNO IN (
    SELECT MGR FROM EMP);

Q.SHOW WHICH EMPLOYEES JOB IS CLERK AND THEY ARE WORKING AT DALLAS ?
SELECT * FROM EMP WHERE DEPTNO =(
    SELECT DEPTNO FROM DEPT WHERE LOC IN 'DALLAS')
    AND JOB =  'CLERK';
    
    
HANDLING NULL VALUES IN SUB QUERY
/
Q.DISPLAY EMPLOYEE NAME WHO ARE NO MAAN
SELECT E.ENAME FROM EMP E WHERE E.EMPNO NOT IN (
    SELECT M. MGR FROM EMP M);-- BLANK COZ IN MGR HAVE A NULL VALUE
SELECT E.* FROM EMP E WHERE E.EMPNO NOT IN (
    SELECT M.MGR FROM EMP M WHERE M.MGR IS NOT NULL);
--OR
SELECT E.* FROM EMP E WHERE EMPNO NOT IN (
    SELECT NVL(M.MGR, 0) FROM EMP M);
    
    
CREATE TABLE ABC (COL1 NUMBER , COL2 NUMBER, COL3 NUMBER);
INSERT INTO ABC VALUES (10,20,30);
INSERT INTO ABC VALUES (100,200,300);
INSERT INTO ABC VALUES(1000,3000,2000);
COMMIT; 

Q. DISPLAY HIGHEST VALUE IN 3 COLUMN ?
SELECT GREATEST (MAX(COL1), MAX(COL2), MAX(COL3))AS GREATEST_VALUE FROM ABC;
--OR
SELECT MAX(GREATEST (COL1, COL2, COL3)) FROM ABC;

Q.DISPLAY THE DEPTNO , DEPARTMENT WISE SALARY PERCENTAGE ? (DEP_SAL/TOTAL SAL *100)
SELECT E.DEPTNO, ROUND(D.DEPT_SAL / 
      (SELECT SUM(SAL)FROM EMP)*100) || ' %' AS PERCETAGE FROM EMP E,
      (SELECT DEPTNO, SUM(SAL) AS DEPT_SAL FROM EMP GROUP BY DEPTNO)  D 
      WHERE E.DEPTNO = D.DEPTNO ORDER BY DEPTNO;
--OR
SELECT DEPTNO, ROUND(SUM(SAL) / (SELECT SUM(SAL) FROM EMP)*100) ||  '%' AS SAL_PER
    FROM EMP GROUP BY DEPTNO ORDER BY SAL_PER;
    
Q.DISPLAY EMPLOYE NAME , SALARY PERCENTAGE FOR EMPLOYEE WISE
SELECT ENAME , ROUND(SAL/(SELECT SUM(SAL) FROM EMP)*100) || '%' AS PERCENTAGE FROM EMP 
ORDER BY TO_NUMBER(RTRIM(PERCENTAGE, '%'));
/

APPLY SUB QUERY IN FROM CLAUSE / INLINE VIEW
/
SELECT * FROM (
    SELECT ENAME, EMPNO, SAL FROM EMP);
SELECT E.*  FROM (
    SELECT EMPNO, SAL, ENAME FROM EMP) E;
SELECT DEPTNO, ENAME , SAL FROM (
    SELECT ENAME ,EMPNO, SAL, COMM FROM EMP);--ERROR  DEPTNO NOT FIND
SELECT E.EMPNO , E.ENAME FROM (
    SELECT T.EMPNO, T.ENAME, T.SAL FROM EMP T)E;
SELECT EMPNO, ENAME, SAL*12 AS ANNUAL_SAL FROM EMP WHERE ANNUAL_SAL =60000;--ERROR  ANNUAL_SAL
SELECT * FROM (
    SELECT EMPNO, ENAME, SAL *12 AS ANNUAL_SAL FROM EMP) WHERE ANNUAL_SAL =60000;
SELECT EMPNO, ENAME, SAL*12 AS ANUUAL_SAL FROM (
    SELECT EMPNO, ENAME , SAL, COMM FROM EMP);--GET ANNUAL SALARY OF ALL EMPLOYEE
    
SUB-SELECT STATEMENT
/
--HERE WRITE SUB QUERY AFTER SELECT STATEMENT
SELECT ENAME , SAL ,
    (SELECT MAX (SAL) FROM EMP) "MAX_SAL", 
    (SELECT MIN (SAL) FROM EMP)"MIN_SAL" FROM EMP;
    
Q.DISPLAY NO OF RECORDS COUNT AND TOTAL RECORD COUNT, LOWEST AND HIGHEST RECORD COUNT IN EMP, DEPT, SALGRADE TABLE?
SELECT EMP_CNT, DEPT_CNT, SALGRADE_CNT,
    EMP_CNT+DEPT_CNT+SALGRADE_CNT AS TOTAL_CNT, 
    LEAST(EMP_CNT,DEPT_CNT,SALGRADE_CNT) AS LEAST_CNT, 
    GREATEST (EMP_CNT,DEPT_CNT,SALGRADE_CNT) FROM
    (SELECT COUNT(*)AS EMP_CNT FROM EMP) T1,
    (SELECT COUNT(*) AS DEPT_CNT FROM DEPT)T2,
    (SELECT COUNT(*) AS SALGRADE_CNT FROM SALGRADE)T3;
    
Q.DISPLAY THE EMPNO, ENAME, SAL AND DEPT WISE AVG SAL ?
SELECT E.EMPNO, E.ENAME , E.SAL, E.DEPTNO, D.DEPTNO, D.AVGSAL FROM EMP E, 
    (SELECT DEPTNO, AVG(SAL) AS AVGSAL FROM EMP  GROUP BY DEPTNO) D
    WHERE E.DEPTNO = D.DEPTNO AND E.SAL > D.AVGSAL;

SELECT EMPNO , ENAME, (SELECT MAX(SAL) FROM EMP ) AS MAX_SAL FROM EMP;

SELECT EMPNO , ENAME , (SELECT MAX(SAL) FROM EMP) AS MAX_SAL, (SELECT AVG(SAL) FROM EMP ) AS AVG_SAL FROM EMP;

SELECT EMPNO, ENAME, DEPTNO, (SELECT DNAME FROM DEPT D WHERE D.DEPTNO = E.DEPTNO )
DNAME FROM EMP E;
/
    
Q.DISPLAY ENAME ,SAL WHOSE SALARY GREATER THAN MINIMUM SALARY OF DEPARTMENT OF NEW YORK LOCATION ?
SELECT ENAME , SAL FROM  EMP WHERE SAL >
    (SELECT MIN(SAL) FROM EMP WHERE DEPTNO =
    (SELECT DEPTNO FROM DEPT WHERE LOC = 'NEW YORK'))ORDER BY SAL;
  
CO-RELATED SUB QUERY 
/
Q.DISPLAY DEPT TABLE WHICH ARE EQUAL TO EMP TABLE ?
SELECT DEPTNO , DNAME FROM DEPT D-- 2 TIMES OUTER QUERY EXECUTE
    WHERE DEPTNO IN 
    (SELECT DEPTNO FROM EMP E WHERE E.DEPTNO = D.DEPTNO );
--OR
SELECT DEPTNO, DNAME FROM DEPT D
    WHERE  EXISTS (SELECT * FROM EMP E WHERE E.DEPTNO = D.DEPTNO);--1ST WORK OUTER , THEN INNER COND.CHECK, 
                                                                  --THEN OUTER DISPLAY
--OR    
SELECT DEPTNO, DNAME FROM DEPT D 
    WHERE EXISTS (SELECT DEPTNO FROM EMP E WHERE E.DEPTNO = D.DEPTNO);
--OR    
SELECT DEPTNO, DNAME FROM DEPT D 
    WHERE EXISTS(SELECT 1 FROM EMP E WHERE E.DEPTNO = D.DEPTNO);
    
SELECT EMPNO, ENAME , DNAME , E.DEPTNO FROM EMP E INNER JOIN DEPT D
    ON  E.DEPTNO = D.DEPTNO
    AND JOB = 'SALESMAN'
    AND E.SAL BETWEEN 1000 AND 3000
    AND EXISTS (SELECT 1 FROM DEPT_ADDR_JOIN A 
    WHERE A.DEPTNO = D.DEPTNO);--BLANK HERE DATA DOESN'T MATCH
    
SELECT EMPNO, ENAME , DNAME , E.DEPTNO, E.SAL, E.JOB FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    WHERE E.JOB = 'ANALYST'
    AND E.SAL BETWEEN 1000 AND 3000
    AND EXISTS (SELECT * FROM DEPT_ADDR_JOIN A WHERE E.DEPTNO = D.DEPTNO);
    
Q.DISPLAY ENAME  WHERE DEPTNO COLUMN ARE MATCH BETWEEN EMP AND DEPT ?
    SELECT ENAME  FROM EMP E WHERE EXISTS (SELECT * FROM DEPT D WHERE E.DEPTNO = D.DEPTNO);
    
Q. DISPLAY DEPARTMENT DETAILS WHICH ARE NOT IN EMP TABLE ?
SELECT * FROM DEPT E WHERE NOT EXISTS (SELECT * FROM EMP D WHERE D.DEPTNO = E.DEPTNO);
--OR
SELECT DEPTNO , DNAME FROM DEPT D 
    WHERE DEPTNO NOT IN 
    (SELECT DEPTNO FROM EMP E WHERE E.DEPTNO = D.DEPTNO);
  
Q.DISPLAY WHO ARE NOT IN MGR COLUMN IN  "CO RELATED SUB QUERY" ?    
SELECT ENAME FROM EMP A WHERE EXISTS (SELECT * FROM EMP B WHERE A.EMPNO = B. MGR);
/

















/
--SET OPERATOR
--===================
/
CREATE TABLE SET1 (ID NUMBER ,NAME VARCHAR2(10));
INSERT INTO SET1 VALUES (1,'S1');
INSERT INTO SET1 VALUES (1,'S1');
INSERT INTO SET1 VALUES (2,'S11');
INSERT INTO SET1 VALUES (3,'S111');
INSERT INTO SET1 VALUES (4,'S1111');
INSERT INTO SET1 VALUES (NULL,'S');

COMMIT;
SELECT * FROM SET1;
/
CREATE TABLE SET2 (ID NUMBER ,NAME VARCHAR2(10));
INSERT INTO SET2 VALUES (1,'S2');
INSERT INTO SET2 VALUES (1,'S2');
INSERT INTO SET2 VALUES (2,'S22');
INSERT INTO SET2 VALUES (3,'S222');
INSERT INTO SET2 VALUES (5,'S22222');
INSERT INTO SET2 VALUES (6,'S222222');
INSERT INTO SET2 VALUES (NULL,'S2');
ALTER TABLE SET2 RENAME COLUMN ID TO SLNO;--HERE COLUMN NAME CHNGE USING ALTER
COMMIT;
SELECT * FROM SET2;

CREATE TABLE SET3 (ID NUMBER ,NAME VARCHAR2(10));
INSERT INTO SET3 VALUES (1,'S3');
INSERT INTO SET3 VALUES (2,'S33');
INSERT INTO SET3 VALUES (3,'S333');
INSERT INTO SET3 VALUES (10,'S10');
COMMIT;
    
SELECT * FROM SET1; 
SELECT * FROM SET2;
SELECT * FROM SET3;

/
UNION OPERATOR
--==================
--COMBINES THE RESULT AND REMOVE THE DUPLICATE VALUE
SELECT ID FROM SET1 UNION SELECT SLNO FROM  SET2;
SELECT SLNO FROM SET2 UNION SELECT ID FROM SET1;
SELECT SLNO FROM SET2 UNION SELECT ID FROM SET3;
SELECT SLNO, NAME FROM SET2 UNION SELECT ID,NAME FROM SET1;
SELECT ID FROM SET1 UNION
    SELECT SLNO FROM SET2 UNION 
    SELECT ID FROM SET3;
SELECT ID FROM SET1 UNION
    (SELECT SLNO FROM SET2 UNION
    SELECT ID FROM SET3);
SELECT DEPTNO FROM EMP UNION SELECT DEPTNO FROM DEPT;
SELECT DEPTNO, ENAME  FROM EMP UNION SELECT DEPTNO, DNAME FROM DEPT;
SELECT DEPTNO FROM EMP UNION SELECT DEPTNO FROM DEPT_ADDR_JOIN ;
SELECT ID,NAME FROM SET1 UNION SELECT SLNO, NAME FROM SET2;
SELECT * FROM EMP WHERE DEPTNO = 10 UNION SELECT * FROM EMP WHERE DEPTNO =20;
SELECT * FROM EMP WHERE DEPTNO = 10 
    UNION 
    SELECT * FROM EMP WHERE DEPTNO =20;--ORDER BY EMPNO, ENAME , ...
SELECT 1 FROM DUAL
    UNION
    SELECT 4 FROM DUAL;
    
Q.DISPLAY EMPLOYEES WHO ARE WORKING IN SALES AND ACCOUNTING ORDERING WITH THEIR EMPNO ?
SELECT EMPNO, ENAME ,JOB FROM EMP 
    WHERE DEPTNO = (SELECT DEPTNO FROM  DEPT WHERE DNAME = 'SALES')
    UNION
    SELECT EMPNO, ENAME , JOB FROM EMP WHERE DEPTNO = (SELECT DEPTNO FROM  DEPT WHERE DNAME = 'ACCOUNTING')
    ORDER BY 1;  
     
Q.DISPLAY ALL JOBS IN DEPT 20 AND 30 ?
SELECT JOB FROM EMP WHERE DEPTNO = 20
    UNION
    SELECT JOB FROM EMP WHERE DEPTNO = 30;
    
UNION ALL OPERATOR
/
--COMBINES THE RESULT AND SHOW OP INCLUDING DUPLICATE
SELECT ID FROM SET1 UNION ALL SELECT SLNO FROM SET2 ;
SELECT SLNO FROM SET2 UNION ALL SELECT ID FROM SET3;
SELECT SLNO FROM SET2 UNION ALL SELECT ID FROM SET1 UNION SELECT ID FROM SET3;
--HERE 1ST WORK BETN. 2 AND 1 IN UNION ALL OPERATOR THEN WORK IN UNION OPERATOR WITH 3
SELECT ID FROM SET1
    UNION ALL 
    SELECT SLNO FROM SET2
    ORDER BY ID;--HERE SHOW IN ORDER BY CLAUSE
SELECT ID FROM SET1 ORDER BY ID
    UNION ALL 
    SELECT SLNO FROM SET2;--ERROR , ORDER BY ALWAYS LAST STATEMENT OF QUERY
SELECT ID FROM SET1
    UNION ALL 
    SELECT SLNO FROM SET2
    ORDER BY SLNO;--ERROR, ALWAYS IN SET OPERATOR ORDER BY WORK IN THE 1ST STATEMENT
        
SELECT ID, NAME  FROM SET1
    UNION ALL 
    SELECT SLNO, NAME FROM SET2
    ORDER BY ID, NAME ;--ORDER BY IN MULTIPLE COLUMN IF IN ID COLUMN WHERE DULICATE VALUE FOUND THEN IT WORK ON
                      --NAME COLUMN.
SELECT * FROM EMP WHERE DEPTNO = 10
    UNION ALL
    SELECT * FROM EMP WHERE DEPTNO = 20;--HERE NO ORDER BY WORK
SELECT * FROM EMP WHERE DEPTNO IN 
    (SELECT 40 FROM DUAL
    UNION ALL 
    SELECT 20 FROM DUAL
    UNION 
    SELECT 10 FROM DUAL);    
    
INTERSECT OPERATOR 
/
--RETURNS ONLY THOSE ROWS ARE MATCHING 
SELECT ID FROM SET1 INTERSECT SELECT SLNO FROM SET2;--MATCHING VALUE SHOW
SELECT ID FROM SET1 UNION
    SELECT SLNO FROM SET2 INTERSECT
    SELECT ID FROM SET3;
SELECT DEPTNO FROM EMP UNION
    SELECT DEPTNO FROM DEPT INTERSECT
    SELECT DEPTNO FROM DEPT_ADDR_JOIN ;
SELECT EMPNO, ENAME, (SELECT DNAME FROM DEPT D WHERE D.DEPTNO = E.DEPTNO) FROM EMP E
    WHERE EMPNO IN (SELECT EMPNO FROM EMP INTERSECT
    SELECT MGR FROM EMP); --DISPLAY WHO ARE IN MGR
SELECT T1.*, T2.DNAME FROM 
    (SELECT EMPNO, ENAME, DEPTNO FROM EMP E WHERE EMPNO IN
    (SELECT EMPNO FROM EMP INTERSECT SELECT MGR FROM EMP )) T1, DEPT T2
    WHERE T1.DEPTNO = T2.DEPTNO;
SELECT DEPTNO, JOB FROM EMP WHERE DEPTNO = 10 INTERSECT 
    SELECT DEPTNO, JOB FROM EMP WHERE DEPTNO= 30;--BLANK DATA MISMATCH
    
Q.WHICH JOB PROFILES ARE SIMILAR IN DEPT 10 AND 30 ?
SELECT JOB FROM EMP WHERE DEPTNO = 10 INTERSECT 
    SELECT JOB FROM EMP WHERE DEPTNO =30;
SELECT ID ,NAME FROM SET1 INTERSECT SELECT ID, NAME FROM SET3; --BLANK DATA MISMATCH

Q.DISPLAY THE COMMON EMPLOYEE WORKING IN DEPTNO 10 AND 30 ?
SELECT ENAME FROM EMP WHERE DEPTNO = 10
    INTERSECT 
    SELECT ENAME FROM EMP WHERE DEPTNO =30;-- BLANK, DATA MISMATCH
    
MINUS OPERATOR 
/
--SHOW 1ST STATEMENT WHICH ARE NOT AVAILABLE IN 2ND STATEMENT
SELECT SLNO FROM SET2 MINUS SELECT ID FROM SET3;--NON MATCHING VALUE SHOW
SELECT SLNO FROM SET2 MINUS SELECT ID FROM SET1;
SELECT SLNO FROM SET2 MINUS SELECT NAME FROM SET1;--DATATYPE MISMATCH
SELECT SLNO AS SERIAL_NO FROM SET2 MINUS SELECT ID AS SERIAL_NO1 FROM SET1;--SHOW 1ST STATEMENT'S ALIAS NAME
SELECT SLNO AS SERIAL_NO,NAME  FROM SET2 MINUS SELECT ID AS SERIAL_NO1 FROM SET1;
--ERROR NO. OF STATEMENT SHOULD MISMATCH
SELECT SLNO AS SERIAL_NO , NAME FROM SET2 MINUS SELECT ID AS SERIAL_NO1 , NAME FROM SET1;
SELECT DEPTNO FROM DEPT MINUS SELECT DEPTNO FROM EMP;
SELECT DEPTNO FROM DEPT MINUS 
    SELECT DEPTNO FROM EMP INTERSECT
    SELECT DEPTNO FROM DEPT_ADDR_JOIN ;--DATA MISMATCH
        
Q.DISPLAY JOB WHICH IS AVAILABLE IN DEPT 20 BUT NOT IN 10 ?
SELECT JOB FROM EMP WHERE DEPTNO = 20
    MINUS 
    SELECT JOB FROM EMP WHERE DEPTNO = 10;
/

--VIEW
/
--============
--CREATE VIEW
--============
CREATE VIEW VW_EMP AS
    SELECT * FROM EMP;--CREATE VIEW
SELECT * FROM VW_EMP;--SHOW RESULT FROM VIEW NAME 

/
CREATE OR REPLACE VIEW
--=====================
CREATE OR REPLACE VIEW VW_EMP AS 
    SELECT * FROM EMP WHERE DEPTNO =10;--REPLACE OVER EXISTING VIEW 
    
SELECT * FROM VW_EMP;    
SELECT * FROM USER_VIEWS WHERE VIEW_NAME = 'VW_EMP';--DICTIONARY OF VIEW
CREATE OR REPLACE VIEW VW_EMP AS 
    SELECT EMPNO, ENAME, JOB, MGR , HIREDATE, SAL FROM EMP;
SELECT * FROM VW_EMP WHERE ENAME = 'SMITH';
SELECT EMPNO, ENAME  FROM VW_EMP;
CREATE VIEW VW_ANNUALSAL AS 
    SELECT EMPNO, ENAME , SAL , SAL*12 AS ANNUAL FROM EMP;
SELECT * FROM VW_ANNUALSAL;
INSERT INTO VW_ANNUALSAL VALUES (9999,'NIEL', 1200,120000);
--ERROR VIRTUAL COLUMN NOT ALLOWED HERE .

INSERT INTO VW_ANNUALSAL(EMPNO, ENAME , SAL ) VALUES(1051, 'SUSANT', 12000 ); 
SELECT * FROM VW_ANNUALSAL;
CREATE OR REPLACE VIEW VW_EMP20 AS
    SELECT EMPNO , ENAME, SAL FROM EMP WHERE DEPTNO = 20;
SELECT * FROM VW_EMP20;    
SELECT * FROM VW_EMP;
INSERT INTO VW_EMP VALUES(2222, 'ABC', 'PRESALES', 7566, '17-NOV-81', 300);--BASE TABLE ALSO CHANGE HERE
SELECT * FROM EMP;
INSERT INTO VW_EMP VALUES(2222, 'ABC', 'PRESALES', 7566, '17-NOV-81', 300);--CONSTRAINT VIOLATED

/
--COMPLEX VIEW
--=============
CREATE OR REPLACE VIEW VW_AGGREGATION AS 
    SELECT DEPTNO, SUM(SAL)AS SUM_SAL, MAX(SAL) AS MX_SAL, MIN(SAL) AS MN_SAL FROM EMP GROUP BY DEPTNO;
    SELECT * FROM VW_AGGREGATION;
SELECT EMPNO, ENAME , SAL FROM VW_EMP WHERE SAL = 
    (SELECT MAX(SAL) FROM EMP);    
SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL = 
    (SELECT MAX(SAL) FROM EMP);
SELECT EMPNO, ENAME, SAL, GRADE FROM VW_EMP E INNER JOIN SALGRADE S
    ON E.SAL BETWEEN S.LOSAL AND S.HISAL;
CREATE OR REPLACE VIEW VW_MAX AS 
    SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO;--ERROR, MUST HAVE NAME EXPRESSION WITH COLUMN ALIAS
CREATE OR REPLACE VIEW VW_MAX AS 
    SELECT DEPTNO, MAX(SAL)AS MAXX FROM EMP GROUP BY DEPTNO;
DELETE FROM EMP WHERE DEPTNO IS NULL;
SELECT * FROM VW_MAX;
SELECT * FROM USER_VIEWS WHERE  VIEW_NAME = 'VW_MAX';

/
--FORCE VIEW 
--===========
CREATE OR REPLACE FORCE VIEW VW_TEST AS 
    SELECT * FROM NARAYAN;--BASE TABLE NOT HERE BUT FORCE FULLY WE CREATE A VIEW
SELECT * FROM USER_VIEWS;    
SELECT * FROM VW_TEST;
CREATE TABLE NARAYAN (ID NUMBER);--NOW THIS TABLE GO TO UNDER LAST VIEW
CREATE VIEW VW_DEPT AS 
    SELECT DEPTNO AS DEPARTMENTNO , DNAME AS DEPARTMENTNAME , LOC AS LOCATION FROM DEPT;
SELECT * FROM VW_DEPT;
SELECT * FROM VW_DEPT WHERE DEPTNO = 10;--ERROR INVALID
SELECT * FROM VW_DEPT WHERE DEPARTMENTNO = 10;
SELECT * FROM VW_DEPT WHERE LOCATION = 'BOSTON';
SELECT * FROM DEPT;
ALTER TABLE DEPT ADD ADDR VARCHAR2(10);--NEW COLUMN ADD 
SELECT * FROM DEPT;--HERE NEW COLUMN ADD
SELECT * FROM VW_DEPT;--HERE SHOW LAST UPDATE OF BASE TABLE 
CREATE OR REPLACE VIEW VW_DEPT AS
    SELECT * FROM DEPT;
SELECT * FROM  VW_DEPT;
CREATE VIEW VW_EMP_SALINFO AS 
    SELECT EMPNO, ENAME , SAL, SAL*12 AS ANNUAL_SAL, (SAL+NVL(COMM,0))*12 AS TOTAL_PKG FROM EMP;
SELECT * FROM VW_EMP_SALINFO;
SELECT * FROM NARAYAN;
DROP TABLE NARAYAN;
CREATE  FORCE VIEW FORCEFULLY AS 
    SELECT * FROM NIEL99;
SELECT * FROM NIEL99;
CREATE TABLE NIEL99 (ID NUMBER );
INSERT INTO NIEL99 VALUES(1);
COMMIT;
SELECT * FROM FORCEFULLY;
DROP TABLE NIEL99;
SELECT * FROM FORCEFULLY;
CREATE TABLE NIEL99 AS SELECT * FROM VW_EMP20 ;
SELECT * FROM NIEL99;

/
--NO FORCE VIEW
--==============
CREATE OR REPLACE NOFORCE VIEW NO_FORCE1 AS 
    SELECT * FROM EMP;--HERE WORK LIKE NORMAL VIEW CREATE 
CREATE OR REPLACE NOFORCE VIEW NO_FORCE AS 
SELECT * FROM EMDFVP;--TABLE OR VIEW DOES NOT EXIST
CREATE TABLE REAL (ID NUMBER);
CREATE VIEW REAL_VIEW AS
    SELECT * FROM REAL;
SELECT * FROM REAL_VIEW;
CREATE VIEW AGN_REAL_VIEW AS SELECT * FROM REAL_VIEW;
--OVER VIEW ANOTHER VIEW 
SELECT * FROM AGN_REAL_VIEW;
ALTER TABLE REAL ADD ADDR VARCHAR2(10);--NEW COLUMN ADD 
CREATE TABLE REAL (ID NUMBER);
CREATE OR REPLACE VIEW REAL_VIEW AS
    SELECT * FROM REAL;--HERE SHOW NEW COLUMN
SELECT * FROM REAL_VIEW;    
CREATE VIEW EMPGRADES AS 
    SELECT E.ENAME AS NAME , E.SAL AS BASIC , S.GRADE AS GRADE FROM EMP E , SALGRADE S
    WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
    ORDER BY S.GRADE;
SELECT * FROM EMPGRADES;
CREATE OR REPLACE VIEW EMPMANAGERS AS 
    SELECT RoWNum AS SERIALNO , INITCAP(E.ENAME) || ' WORKS UNDER' || M.ENAME AS "EMPLOYEE AND MANAGERS" 
    FROM EMP E INNER JOIN EMP M
    ON E.MGR = M.EMPNO;
SELECT * FROM EMPMANAGERS;

VIEWS IN DATA DICTIONARY
/
SELECT VIEW_NAME , TEXT FROM USER_VIEWS;
SELECT VIEW_NAME , TEXT FROM USER_VIEWS WHERE VIEW_NAME = 'EMPMANAGERS';--VIEW NAME AND TEXT OF A VIEW
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'DEPT';--TO KNOW THE TABLE DETAILS 
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'EMPMANAGERS';
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'VW_EMP';

CREATE OR REPLACE VIEW VW_DEPT AS 
    SELECT * FROM DEPT;
SELECT * FROM VW_DEPT;
CREATE OR REPLACE VIEW VW_DEPTNO AS 
    SELECT * FROM DEPT;--WE CAN TAKE SAME BASE TABLE BUT MULTIPLE VIEW
SELECT * FROM VW_DEPTNO;    

CREATING VIEW WITH COLUMN DECLARATION 
/
CREATE OR REPLACE VIEW DEPTSALSUMMARY
    (DEPARTMENT_NAME, MINIMUMSALARY, MAXIMUMSALARY, AVERAGESALARY, SALARYSUM) AS
    SELECT D.DNAME, 
    MIN(E.SAL), 
    MAX(E.SAL),
    AVG(E.SAL),
    SUM(E.SAL)
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    GROUP BY D.DNAME;
SELECT * FROM DEPTSALSUMMARY;
CREATE VIEW DEPTSALSUMMARY
    (DEPARTMENT_NAME, MINIMUMSALARY, MAXIMUMSALARY, AVERAGESALARY) AS
    SELECT D.DNAME, 
    MIN(E.SAL), 
    MAX(E.SAL),
    AVG(E.SAL),
    SUM(E.SAL)
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    GROUP BY (D.DNAME);--ERROR  INVALID NO. OF COLUMN SPECIFIED
CREATE VIEW DEPTSALSUMMARY
    (DEPARTMENT_NAME, MINIMUMSALARY, MAXIMUMSALARY, AVERAGESALARY, SALARYSUM) AS
    SELECT D.DNAME, 
    MIN(E.SAL), 
    MAX(E.SAL),
    SUM(E.SAL)
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    GROUP BY (D.DNAME);--INVALID NO. OF COLUMN SPECIFIED
    
CREATING A TABLE WITH DATA USING A VIEW 
/
SELECT * FROM DEPTSALSUMMARY;
SELECT * FROM USER_VIEWS WHERE VIEW_NAME = 'DEPTSALSUMMARY' ;
CREATE TABLE DEPT10 AS
    SELECT * FROM DEPTSALSUMMARY;
SELECT * FROM DEPT10;

DROPPING A VIEW
/
DROP VIEW <VIEW NAME >;
CREATE OR REPLACE VIEW AAJKAVIEW AS
    SELECT * FROM EMP WHERE SAL BETWEEN 1200 AND 5000;
SELECT * FROM AAJKAVIEW;    
DROP VIEW AAJKAVIEW;

PERFORMING A DML OPERATIONS ON A VIEW
/
SELECT * FROM DEPTSALSUMMARY;
INSERT INTO DEPTSALSUMMARY VALUES ('HR', 1800, 2800, 3000, 5000);--CAN'T WORK ON DML OPERATION ON COMPLEX VIEW
CREATE OR REPLACE VIEW EMPVW30 AS
    SELECT * FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMPVW30;
INSERT INTO EMPVW30(EMPNO, ENAME, DEPTNO) VALUES (7777, 'PQR', 10);
SELECT * FROM EMP;

INSERTING DATA INTO DEPT TABLE USING THE  VIEW 
/
CREATE OR REPLACE VIEW INSERTDEPT AS 
    SELECT * FROM DEPT;
SELECT * FROM INSERTDEPT;
INSERT INTO INSERTDEPT VALUES(50, 'ADMINSTRATOR', 'DALLAS');
SELECT * FROM DEPT;

UPDATING DATA IN DEPT TABLE USING THE  VIEW ?
/
INSERT INTO INSERTDEPT VALUES(60, 'RECOVERY', 'ASKA');
SELECT * FROM DEPT;
UPDATE  INSERTDEPT SET LOC = 'DELHI' WHERE DEPTNO = 60;
SELECT * FROM INSERTDEPT;

DELETING DATA FROM DEPT TABLE USING THE VIEW ? 
/
DELETE FROM INSERTDEPT WHERE  DEPTNO = 60;
SELECT * FROM INSERTDEPT;

CONSTRAINTS ON VIEW
/
CREATE OR REPLACE VIEW EMPVW30 AS
    SELECT * FROM EMP WHERE DEPTNO = 30
    WITH CHECK OPTION;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME  = 'EMPVW30';    
INSERT INTO EMPVW30 (EMPNO, ENAME, DEPTNO) VALUES (8888, 'PQR', 10);--ERROR VIEW WITH CHECK OPTION IN WHERE CLAUSE
INSERT INTO EMPVW30 (EMPNO, ENAME, DEPTNO) VALUES (8888, 'PQR', 30);
CREATE OR REPLACE VIEW EMPVW31 AS
    SELECT * FROM EMP WHERE DEPTNO = 30 AND SAL BETWEEN 1000 AND 2000 WITH CHECK OPTION CONSTRAINT EDEPT31CHKVW;
INSERT INTO EMPVW31 (EMPNO, SAL, DEPTNO) VALUES (1437, 3000, 30);--CHECK OPTION VIOLATED
INSERT INTO EMPVW31 (EMPNO, SAL, DEPTNO) VALUES (9821, 2000, 30);



APPLYING WITH READ ONLY OPTION 
/
CREATE OR REPLACE VIEW EDEPTREAD (EMPID, NAME, DESIGNATION) AS
    SELECT EMPNO, ENAME, JOB FROM EMP WITH READ ONLY ;
SELECT * FROM EDEPTREAD;
INSERT INTO EDEPTREAD VALUES(2222, 'NUEK', ' DBBDHB');--DML OPERATION NO WORK IN READ ONLY
INSERT INTO EMP (EMPNO, ENAME, DEPTNO ) VALUES(4445,'VDGFV', 10);


CONSTRAINT DICTIONARY OF VIEW
/
SELECT DISTINCT CONSTRAINT_TYPE FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONSTRAINTS WHERE CONSTRAINT_TYPE IN ('O', 'V');
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPVW31';
COMMIT;
/

--MATERIALIZED VIEW / SNAPSHOT
--================================
/
CREATE MATERIALIZED VIEW "1ST TIME" AS
    SELECT * FROM EMP;--insufficient privileges
    
CREATE MATERIALIZED VIEW "1ST TIME" AS
    SELECT * FROM EMP;    
    
SELECT * FROM "1ST TIME";

CREATE MATERIALIZED VIEW MV_EMP_DEPTINFO AS
    SELECT E.ENAME, D.DNAME, D.LOC  FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;
    
    DROP  TABLE  MV_EMP_DEPTINFO;
    
SELECT * FROM MV_EMP_DEPTINFO;

CREATE MATERIALIZED VIEW MV_EMP_DEPTNO_SAL AS
    SELECT E.ENAME , D.DNAME , D.LOC, E.SAL * 12 AS ANNUALSAL FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;
    
SELECT * FROM MV_EMP_DEPTNO_SAL;

SELECT * FROM MV_EMP_DEPTNO_SAL WHERE ANNUALSAL = 60000;

/
BUILD IMMEDIATE
/
CREATE MATERIALIZED VIEW MV_DEPT_TEST 
    BUILD IMMEDIATE 
    AS
    SELECT * FROM DEPT;
    
SELECT * FROM MV_DEPT_TEST; 

CREATE MATERIALIZED VIEW MV_DEPT_TEST2
    BUILD IMMEDIATE
    AS 
    SELECT * FROM DEPT;--ONE BASIC TABLE WE CAN MAKE DIFFERENT MVIEW.
    
SELECT * FROM MV_DEPT_TEST2;--HERE INSERT SOME RECORD THROUGH OPEN DECLARATION BUT THIS MV CAN'T CHANGE ANYTHING
/
BUILD DEFERRED
/
CREATE MATERIALIZED VIEW MV_DEPT_TEST21 
    BUILD DEFERRED
    AS 
    SELECT * FROM DEPT;
SELECT * FROM MV_DEPT_TEST21;
--HERE OP SHOW BLANK COZ IN BUILD DEFERRED REQUIRE A COMPLETE REFRESH , AFTER THAT IT WILL 
                              --BE SHOW THE MATERIALIZED VIEW
EXEC DBMS_MVIEW.REFRESH('MV_DEPT_TEST21', 'C');--REFRESH
SELECT * FROM MV_DEPT_TEST21;--NOW IT WILL BE SHOW

CREATE TABLE NNN (ID NUMBER) ;
INSERT INTO NNN VALUES (1);
CREATE MATERIALIZED VIEW LOG ON NNN;
ALTER TABLE NNN ADD PRIMARY KEY(ID);
CREATE MATERIALIZED VIEW NNN2
    BUILD DEFERRED
    AS
    SELECT * FROM NNN;
SELECT * FROM NNN2;
EXEC DBMS_MVIEW.REFRESH ('NNN2', 'F');--ERROR , WE HAVE GIVE MUST COMPLETE REFRESH AND FORCEFULLY
/
REFRESH
/
FAST REFRESH (F)
/
CREATE MATERIALIZED VIEW LOG ON EMP;--LOG WILL WORK FOR STORE LATEST DATA INTERNALLY IN FAST REFRESH
                                    --BUT IN OP SAME AS COMPLETE REFRESH..
SELECT * FROM USER_MVIEW_LOGS;--LOG DICTIONARY TABLE
CREATE MATERIALIZED VIEW MV_EMP_FAST AS 
    SELECT * FROM EMP;
SELECT * FROM MV_EMP_FAST;    
EXEC DBMS_MVIEW.REFRESH ('MV_EMP_FAST', 'F');
SELECT * FROM MV_EMP_FAST;
SELECT * FROM USER_MVIEWS;

CREATE MATERIALIZED VIEW SNDFJS AS 
    SELECT * FROM DEPT;   
CREATE MATERIALIZED VIEW LOG ON DEPT;
SELECT * FROM SNDFJS;
EXEC DBMS_MVIEW.REFRESH ('SNDFJS', 'F');--ERROR, COZ LOG TABLE CREATE AFTER MATERIALIZED TABLE 

CREATE TABLE LOGKA (ID NUMBER);
INSERT INTO LOGKA VALUES(1);
COMMIT;
CREATE MATERIALIZED VIEW LOG ON LOGKA;--ERROR, IN BASE TABLE THERE IS NO PRIMARY KEY CONSTRAINT

CREATE MATERIALIZED VIEW ABC123
    REFRESH FAST
    AS 
    SELECT * FROM LOGKA;--ERROR,  PRIMARY KEY NOT AVAILABLE

--TO DROP A MATERIALIZED VIEW LOG 
--=================================
DROP MATERIALIZED VIEW LOG ON <BASE_TABLE>;
DROP MATERIALIZED VIEW LOG ON EMP;
/
COMPLETE REFRESH
/
CREATE MATERIALIZED VIEW MV_DEPT_COMP AS
    SELECT * FROM DEPT;    
EXEC DBMS_MVIEW.REFRESH('MV_EMP_FAST', 'C');
SELECT * FROM DEPT;
INSERT INTO DEPT VALUES(60,'JFJ','KNFDG');
SELECT * FROM MV_DEPT_COMP ;--HERE NO CHANGES OF LATEST DML OPERATION
EXEC DBMS_MVIEW.REFRESH('MV_DEPT_COMP', 'C');--COMPLETE REFRESH DONE
SELECT * FROM MV_DEPT_COMP;--HERE SHOW THE LATEST DML OPERATION

CREATE MATERIALIZED VIEW AAAABBBB 
REFRESH COMPLETE 
AS
SELECT * FROM DEPT;--COMPLETE
SELECT * FROM AAAABBBB;
INSERT INTO DEPT VALUES(70,'JFJ','HHFD');
COMMIT;
SELECT * FROM AAAABBBB;
EXEC DBMS_MVIEW.REFRESH ('AAAABBBB');
SELECT * FROM AAAABBBB;
/
FORCE REFRESH
/
CREATE TABLE FORCE_TABLE_CHK (ID NUMBER );
INSERT INTO FORCE_TABLE_CHK VALUES (1);

CREATE MATERIALIZED VIEW MV_FORCE_CHK AS
    SELECT * FROM FORCE_TABLE_CHK;
SELECT * FROM MV_FORCE_CHK;    
INSERT INTO FORCE_TABLE_CHK VALUES(2);
SELECT * FROM MV_FORCE_CHK;--AFTER DML OPERATION THERE IS NO CHANGING, WE HAVR TO REFRESH
EXEC DBMS_MVIEW.REFRESH('MV_FORCE_CHK', 'F');---THERE IS NO OP, COZ WE CAN'T CREATE LOG
EXEC DBMS_MVIEW.REFRESH('MV_FORCE_CHK');--AUTOMATIC COMPLETE REFRESH WORK
SELECT * FROM MV_FORCE_CHK;
INSERT INTO FORCE_TABLE_CHK VALUES(3);
EXEC DBMS_MVIEW.REFRESH('MV_FORCE_CHK', '?');--HERE FORCE REFRESH WORK

CREATE TABLE BISWAL (ID NUMBER PRIMARY KEY);
CREATE MATERIALIZED VIEW LOG ON BISWAL;
CREATE MATERIALIZED VIEW BISWAL1 AS SELECT * FROM BISWAL;
SELECT * FROM BISWAL;
INSERT INTO BISWAL VALUES(1);
EXEC DBMS_MVIEW.REFRESH('BISWAL1');--WE CREATE LOG BUT, NOT MENTION WHAT TYPE OF REFRESH SO HERE COMPLETE WORK
/

--REFRESH ON COMMIT
--====================


CREATE MATERIALIZED VIEW MV_DEPT_TEST 
    REFRESH ON COMMIT
    AS 
    SELECT * FROM DEPT;
    
COMMIT;

INSERT INTO DEPT(DEPTNO) VALUES(50);

SELECT * FROM MV_DEPT_TEST;
--HERE DML OPERATION NOT DISPLAY

COMMIT;
--THIS COMMIT FOR REFRESH 

SELECT * FROM MV_DEPT_TEST;
--HERE SHOW THE UPDATED DML OPERATION

/
--REFRESH ON DEMAND
--====================


CREATE MATERIALIZED VIEW MV_DEPT_TEST
    REFRESH ON DEMAND
    AS
    SELECT * FROM DEPT;
    
SELECT * FROM MV_DEPT_TEST;

INSERT INTO DEPT (DEPTNO) VALUES (90);

SELECT * FROM MV_DEPT_TEST;

EXEC DBMS_MVIEW.REFRESH ('MV_DEPT_TEST', '?');

DROP MATERIALIZED VIEW  NIEL;

CREATE TABLE NIEL (ID NUMBER);

CREATE MATERIALIZED VIEW NIELMV
    REFRESH  COMPLETE
    ON DEMAND
    AS 
    SELECT * FROM NIEL;
    
INSERT INTO NIEL VALUES(1);

EXEC DBMS_MVIEW.REFRESH('NIELMV');--HERE REFRESH DONE WHAT U GIVE ON CREATION TIME 

SELECT * FROM NIELMV;

/
WE CAN REFRESH MATERIALIZED VIEW  ON TIME INTERVAL
/
--AFTER INSERT RECORD COMPULSARY TO COMMIT;
ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH:MI:SS P.M.';

SELECT SYSDATE FROM DUAL;

CREATE TABLE NIEL3 (ID NUMBER);

CREATE MATERIALIZED VIEW NIELMV2
    REFRESH COMPLETE
    NEXT SYSDATE + 2/24/60
    AS
    SELECT * FROM DEPT;
    
INSERT INTO DEPT(DEPTNO) VALUES(60);

COMMIT;
--COMMIT COMPULSARY FOR UPDATE DML

SELECT * FROM DEPT;

SELECT * FROM NIELMV2;

COMMIT;

/
ENABLE QUERY REWRITE
/

SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO HAVING MAX(SAL) > 3000;

CREATE MATERIALIZED VIEW MV_EMP_GROUP
    AS
    SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO HAVING MAX(SAL) > 3000;
    
SELECT * FROM MV_EMP_GROUP;--HERE WORK PERFOMANCE SPEED ONLY MATERIALIZED VIEW

CREATE MATERIALIZED VIEW MV_DEPT_TEST5
    ENABLE QUERY REWRITE
    AS
    SELECT D.DEPTNO , D.DNAME , COUNT(*) FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO
    GROUP BY D.DEPTNO , D.DNAME ;
    
SELECT * FROM MV_DEPT_TEST5;--WHEN WE GIVE ENABLE REWRITE THEN UNDER MATERIALIZED VIEW QUERY PEROFAMANCE SAME
                            --IF U RUN THIS QUERY IN OUTSIDE

/
DISABLE QUERY REWRITE
/

CREATE MATERIALIZED VIEW  MO_ICHA 
    DISABLE QUERY REWRITE
    AS 
    SELECT E.ENAME , D.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO;
SELECT * FROM MO_ICHA;--THIS ONE OPPOSITE OF ENABLE QUERY REWRITE, HERE CAN'T WORK PERFORMANCE OF THIS QUERY     
                      --OUTSIDE 
NOTE
/

CREATE MATERIALIZED VIEW TESTAT AS 
    SELECT * FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;--COLUMN NAME SHOULD BE UNIQUE IN MV
    
INSERT INTO MV_TEST_500 VALUES(50,'RAHA', 'BE');--DML OPERATION NOT ALLOWED IN MATERIALIZED VIEW    

/

TO SEE THE MERIALIZED INFORMATION
/
SELECT * FROM USER_MVIEWS;
COMMIT;
/
WE CAN ADD CONSTRAINT THROUGH MATERIALIZED VIEW ALSO
/
CREATE TABLE NAR (ID NUMBER);
CREATE MATERIALIZED VIEW NARAYAN
    AS SELECT ID  FROM NAR;
ALTER MATERIALIZED VIEW NARAYAN MODIFY ID NOT NULL;


/
--INDEX--EXPLAIN PLAN (F10)
--=============================
--ALL INDEXES CAN BE UNUSABLE AND REBUILD.

--BASE TABLE : CREATE 
--VIEW : ERROR
--MATERIALIZED VIEW : CREATE.
--SYNONYM : CREATE , BUT FOR DICTIONARY SPECIFY BASE TABLE NAME .
/

--B-TREE INDEX (BALANCED TREE INDEX) / NON - UNIQUE INDEX
--=========================================================
--IT IS USED WHERE MINIMAL DUPLICACY (HIGH CARDINALITY / LESS DUPLICATE)
--EX. EMPNO IN EMP, STUDENT REGISTRATION, CUSTOMER ID IN BANK, AADHAR CARD, PAN CARD ETC...
--IF WE DOING ANY FILTER THEN INDEX ROWID WORK OTHERWISE NOT.

CREATE TABLE EMP_BKP10 AS SELECT * FROM EMP;

SELECT * FROM EMP_BKP10;
--HERE WE EXPLAIN PLAN THEN IT SCAN FULL TABLE .

CREATE INDEX IDX_EMP_BKP10_EMPNO ON 
    EMP_BKP10(EMPNO);
    
SELECT * FROM USER_INDEXES;
--USER INDEX DICTIONARY   

SELECT * FROM USER_INDEXES WHERE INDEX_NAME = 'IDX_EMP_BKP10_EMPNO';
--INDEX DICTIONARY OF A PARTICULAR INDEX  

SELECT EMPNO FROM EMP_BKP10;
--HERE INDEX CAN'T WORK, COZ HERE SCAN WHOLE COLUMN, where clause require for index scan.

SELECT * FROM EMP_BKP10 WHERE EMPNO = 7369 ;
--WHEN WE GIVE ANY FILTER THEN IT SCAN BY ROWID
--BY INDEX ROWID TAKE LESS TIME / PERFORMANCE IS FAST

SELECT * FROM EMP_BKP10 WHERE EMPNO IN (7369,7654);
--SCAN THROUGH INDEX ROW ID .

/
--BITMAP INDEXES
--===============
--THIS INDEX USES WHERE LESS NO. OF DISTINCT VALUE PRESENT / LOW CARDIANALITY / MORE DUPLICATE VALUE
--EX. GENDER (M,F), STATUS (ACTIVE, INACTIVE)ETC...

CREATE TABLE STUDENT_INFO_IDX (STD_ID NUMBER, STD_NAME VARCHAR2(10), ROLLNO CHAR, MOBILE_NO NUMBER,
    GENDER CHAR, STATUS VARCHAR2(10));
    
SELECT * FROM STUDENT_INFO_IDX;

CREATE BITMAP INDEX IDX_GENDER ON
    STUDENT_INFO_IDX(GENDER);
    
SELECT * FROM STUDENT_INFO_IDX WHERE GENDER = 'M';
--HERE BITMAP INDEXES ROWID WORK

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'STUDENT_INFO_IDX';

CREATE BITMAP INDEX IDX_BITMAP_EMP_BKP10 ON
    EMP_BKP10 (DEPTNO);
    
SELECT * FROM EMP_BKP10 WHERE DEPTNO = 10;    
--HERE ALSO BITMAP INDEXES WORK

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'IDX_BITMAP_EMP_BKP10';

SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'EMP_BKP10';

SELECT * FROM USER_INDEXES;

SELECT * FROM USER_IND_COLUMNS;

/
--FUNCTION BASED INDEXES 
--========================
--THIS INDEX USED WHEN WE USE FREQUENTLY ANY FUNCTION 
--EX. LOWER(ENAME), UPPER(ENAME), INITCAP(ENAME), SUBSTR, INSTR .........

SELECT * FROM EMP_BKP10 WHERE LOWER(ENAME) = 'king';
--BEFORE CREATE INDEX, FULL ACCESS TABLE .

CREATE INDEX IDX_FUN_EMP_BKP10_ENAME ON
    EMP_BKP10 (LOWER(ENAME));
    
SELECT * FROM EMP_BKP10 WHERE LOWER(ENAME) = 'king';
--HERE INDEX RANGE SCAN DONE

SELECT * FROM EMP_BKP10 WHERE UPPER(ENAME) = 'KING';
--HERE INDEX NOT WORK COZ FUNCTION ARE CHANGED.

SELECT * FROM EMP_BKP10 WHERE SUBSTR(ENAME, 1,1) = 'K';
--IT WILL TAKES FULL ACCESS FOR EXECUTE.

CREATE INDEX FUN_EMP_BKP10 ON EMP_BKP10 (SUBSTR(ENAME,1,1));

SELECT * FROM EMP_BKP10 WHERE SUBSTR(ENAME, 1,1) = 'K';
--NOW HERE PERFORMANCE WORK THROUGH ROWID.

/
--REVERSE FUNCTION
--=================
--HERE WE FILTER DATA IN REVERSE ORDER.
--MOSTLY THIS INDEX USED IN FILTER IN HIGHEST VALUE.
--IN THIS INDEX ROWID STORED IN REVERSE ORDER.
SELECT * FROM EMP_BKP10 WHERE SAL = 5000;

SELECT * FROM EMP_BKP10 WHERE SAL = 800;
--BEFORE INDEX APPLY

CREATE INDEX IDX_EMP_BKP10_SAL_REVERSE ON
    EMP_BKP10 (SAL) REVERSE;
--AFTER REVERSE INDEX APPLY  

SELECT * FROM EMP_BKP10 WHERE SAL = 5000;
--HERE FILTER HIGHEST VALUE IN REVERSE ORDER

SELECT * FROM EMP_BKP10 WHERE SAL = 800;
--HERE INDEX DOESN'T WORK PROPERLY COZ, THIS ONE IS SMALLEST VALUE, BUT SEARCH USING INDEX ROWID.

/
--COMPOSITE INDEXES
--===================
--WHEN WE WANT CREATE A INDEX MORE THAN ONE COLUMN THIS INDEX CALLED AS COMPOSITE INDEXES

CREATE TABLE EMPNIEL AS SELECT * FROM EMP;

CREATE INDEX BTREE ON EMPNIEL(EMPNO, ENAME);

CREATE BITMAP INDEX BITMAP ON EMPNIEL(EMPNO, SAL);

CREATE INDEX REVERSE ON EMPNIEL (SAL, MGR) REVERSE;

CREATE INDEX FUNCTION ON EMPNIEL  IN (LOWER  (ENAME, JOB));--ERROR

CREATE INDEX FUNCTION ON EMPNIEL (LOWER(ENAME), UPPER(JOB));
SELECT * FROM EMPNIEL WHERE LOWER(ENAME)= 'king';
SELECT * FROM EMPNIEL WHERE upper(JOB)= 'PRESIDENT';

CREATE INDEX FUNCTION ON EMPNIEL LOWER(ENAME, JOB);

SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'EMPNIEL';

SELECT * FROM HONOR;
CREATE INDEX FUN999 ON HONOR (LOWER(ENAME),UPPER(JOB));
SELECT * FROM HONOR WHERE LOWER(ENAME) = 'king';
SELECT * FROM HONOR WHERE UPPER(job) = 'PRESIDENT';
SELECT * FROM HONOR WHERE LOWER(ENAME) = 'king' AND UPPER(JOB) = 'PRESIDENT';
SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'HONOR';
/
--UNIQUE INDEXES :
--==================
--IF WE WANT TO CREATE A UNIQUE INDEX ON A COLUMN HAVING ONLY UNIQUE VALUE
--WHEN A COLUMN HAVE A PRIMARY KEY, UNIQUE KEY THEN THEY HAVE AUTOMATIC UNIQUE INDEX .
CREATE UNIQUE INDEX UNIQUEALL ON EMPNIEL (JOB);--ERROR , COZ DUPLICATE VALUE ARE THERE
CREATE UNIQUE INDEX UNIQUEALL ON EMPNIEL (EMPNO);
SELECT * FROM EMPNIEL WHERE EMPNO = 7369;
--HERE UNIQUE INDEX WORK
/
--DROP A INDEX
--==============
--DROP INDEX <INDEX_NAME>;
DROP INDEX FUNCTION;--INDEX ARE DROPPED 
/
DISABLE INDEX / UNUSABLE INDEX
/
--ONLY FUNCTION BASED INDEX WE WILL "DISABLE".
--EXCEPT FUNCTION BASED INDEX (B-TREE,BITMAP, REVERESE, COMPOSITE, UNIQUE ) WE USE "UNUSABLE" FOR DISABLE.
--ALTER INDEX <INDEX_NAME> DISABLE ;--ONLY FUNCTION INDEX
--ALTER INDEX <INDEX_NAME> UNUSABLE;--ONLY B-TREE,BITMAP, REVERESE, COMPOSITE, UNIQUE INDEX
ALTER INDEX IDX_FUN_EMP_BKP10_ENAME DISABLE;
SELECT * FROM USER_INDEXES WHERE INDEX_NAME = 'IDX_FUN_EMP_BKP10_ENAME' ;
--WE CHECK FUNCIDX_STATUS COLUMN ON INDEX DICTIONARY AND IT SHOW US "DISABLED"
ALTER INDEX BITMAP UNUSABLE;
SELECT * FROM USER_INDEXES WHERE INDEX_NAME = 'BITMAP';
--WE CHECK STATUS COLUMN ON INDEX DICTIONARY IT SHOW US "UNUSABLE"
/
ENABLE INDEX / REBUILD INDEX
--ONLY FUNCTION BASED INDEX WE WILL "ENABLE".
--EXCEPT FUNCTION BASED INDEX (B-TREE,BITMAP, REVERESE, COMPOSITE, UNIQUE ) WE USE "REBUILD" FOR ENABLE
--ALTER INDEX <INDEX_NAME> ENABLE;--ONLY FUNCTION INDEX
--ALTER INDEX <INDEX_NAME> REBUILD;--ONLY B-TREE,BITMAP, REVERESE, COMPOSITE, UNIQUE INDEX
ALTER INDEX IDX_FUN_EMP_BKP10_ENAME ENABLE;
--WE CHECK FUNCIDX_STATUS COLUMN ON INDEX DICTIONARY AND IT SHOW US "ENABLED".
ALTER INDEX BITMAP REBUILD;
--WE CHECK STATUS COLUMN ON INDEX DICTIONARY IT SHOW US "VALID"
SELECT * FROM USER_INDEXES WHERE INDEX_NAME = 'BITMAP' ;--DICTIONARY TABLE OF INDEX
/
CAN WE CREATE A PRIMARY KEY WITH HAVING DUPLICATE VALUE
/
CREATE TABLE DUP_PK (ID NUMBER);
INSERT INTO DUP_PK VALUES (1);
INSERT INTO DUP_PK VALUES (1);
INSERT INTO DUP_PK VALUES (1);
COMMIT;
ALTER TABLE DUP_PK ADD PRIMARY KEY (ID);--CAN'T ADD PRIAMRY KEY, COZ THEIR ALREADY DUPLICATE VALUE STORED.
CREATE INDEX IDX_DUP_PK ON DUP_PK (ID);--BTREE INDEX WILL BE CREATED ON ID COLUMN OF TABLE = "DUP_PK"
ALTER TABLE DUP_PK ADD PRIMARY KEY (ID) USING INDEX IDX_DUP_PK ENABLE NOVALIDATE;
--HERE WE ADD PRIMARY KEY OF "DUP_PK" TABLE WHICH HAVE ALREADY DUPLICATE VALUE USING INDEX AND ENABLE NOVALIDATE.
INSERT INTO DUP_PK VALUES (1);--ERROR, DUPLICATE VALUE NOT ALLOW BUTTTTT,
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'DUP_PK';--HERE WE CHECK PRIMARY KEY WILL BE THERE.







/
--HIERARCHICAL KEY
--====================
/
--IT IS USED TO GET DATA WHEN THEY HAVE HIERARCHICAL DATA INFORMATION OR PARENT CHILD RELATIONSHIP.
--"START WITH" = STARTING POINT / ROOT (COMPULSARY)
--"CONNECT BY" = HERE WE GIVE PK AND FK RELATIONSHIP
--"PRIOR'" = PRIORITY (IMPORTANT BUT NOT COMPLUSARY), IF WE DONT TAKE PRIOR THEN IT DISPLAY ONLY START WITH VALUE.
--                            BUT PRIOR PLAYS VITAL (MAIN) ROLE IN HIERARCHICAL DATA DISPLAY.
--IF PRIOR UPON PRIMARY KEY THEN IT DISPLAY TOP TO BOTTOM .
--IF PRIOR UPON FOREIGN KEY THEN IT DISPALY BOTTOM TO TOP.
--IF , CONNECT BY PRIOR PK = FK (TOP TO BOTTOM)          
--      CONNECT BY FK = PRIOR PK (TOP TO BOTTOM)
--      CONNECT BY PRIOR FK = PK (BOTTOM TO TOP)
--      CONNECT BY PK = PRIOR FK (BOTTOM TO TOP)
--"WHERE" = AFTER WHERE CLAUSE IT RETURNS ONLY THIS CLAUSE INFORMATION, WITH OUT AFFECTING OTHER ROWS.
/
SELECT  EMPNO, ENAME FROM EMP
    START WITH ENAME = 'FORD'
    CONNECT BY EMPNO = MGR ;
--HERE DON'T MENTION PRIOR SO HERE RESULT ONLY FORD (START WITH VALUE)
--                                      SO,PRIOR IS IMPORTANT TO MAKE A RELATIONSHIP 

SELECT EMPNO , ENAME FROM EMP
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR EMPNO = MGR;
--HERE WE GET HIERARCHY EMP DETAILS (WHOSE EMP UNDER WHOSE MGR)
                        --(IT LOOK FROM LEFT TO RIGHT HIERARCHY)
                        --(PRIOR IS PK SO IT SHOW TOP TO BOTTOM)                                  
SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR EMPNO = MGR
    ORDER BY LEVEL DESC;
--HERE WE MENTION LEVEL (PSUEDO COLOMN), IT SHOW LEVEL WISE HIERARCHY KEY LIKE NO 1,2,3......

SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR MGR = EMPNO
    ORDER BY LEVEL;--KING
--HERE WE GET HIERARCHY EMP DETAILS (WHOSE MGR UNDER WHOSE EMPNO), HERE WE  GET BACKWARD (BOTTOM TO TOP)
                                                                                                                                                                                         --(PRIOR IS FK SO IT SHOW BOTTOM TO TOP)                                  
SELECT LEVEL , EMPNO, ENAME, SAL FROM EMP
    START WITH ENAME = 'FORD'
    CONNECT BY EMPNO = PRIOR MGR
    ORDER BY LEVEL;--FORD -- JONES  -- KING
--HERE WE GET HIERARCHY START FROM FORD (FORD UNDER WHOSE EMP WITH HIERARCHY , BACKWARD)

SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH JOB = 'PRESIDENT'
    CONNECT BY MGR = PRIOR EMPNO 
    ORDER BY LEVEL;
--HERE LOOK WHO IS PRESIDENT UNDER THAT WHOSE ARE WORKING (HIERARCHY WISE)
    
SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH JOB = 'PRESIDENT'
    CONNECT BY PRIOR EMPNO = PRIOR MGR
    ORDER BY LEVEL;
--HERE LOOK WHO IS PRESIDENT AND PRSIDENT WORK UNDER WHOSE EMPNO(HIERARCHY WISE)
    
SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH JOB = 'PRESIDENT'
    CONNECT BY EMPNO = PRIOR MGR;--BACKWARD
    
SELECT LEVEL, EMPNO, ENAME FROM EMP;--ERROR 
--CONNECT BY CLAUSE REQUIRE

SELECT EMPNO, ENAME FROM EMP
    START WITH ENAME = 'KING';--ERROR 
--CONNECT BY CLAUSE REQUIRE

SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH SUBSTR(ENAME,1,1) = 'J'
    CONNECT BY MGR = PRIOR EMPNO
    ORDER BY LEVEL;
--HERE WE GET HIERARCHY THROUGH SUBTR
    
SELECT LEVEL, EMPNO, ENAME FROM EMP
    START WITH SAL = (SELECT MAX(SAL) FROM EMP)
    CONNECT BY PRIOR EMPNO = MGR
    ORDER BY LEVEL;
--HERE WE GET HIERARCHY WITH AGGREAGATE FUNCTION
    
SELECT LEVEL, E.* FROM EMP E
    START WITH SAL = (SELECT MAX(SAL) FROM EMP WHERE SAL < 
                        (SELECT MAX(SAL) FROM EMP))
    CONNECT BY PRIOR EMPNO = MGR
    ORDER BY LEVEL;
--HERE WE GET 2ND HIGHEST SAL EMPLOYEES HIERARCHY STRUCTURE
--OR 
SELECT LEVEL, E.* FROM EMP E 
    START WITH SAL IN (SELECT SAL FROM(SELECT SAL,
            DENSE_RANK () OVER (ORDER BY SAL DESC) DR FROM EMP) WHERE DR=2)
    CONNECT BY PRIOR EMPNO = MGR;

SELECT LEVEL, E.* FROM EMP E WHERE DEPTNO = 20
    START WITH ENAME = 'JONES'
    CONNECT BY PRIOR EMPNO = MGR
    ORDER BY LEVEL;
--HERE WE GET HIERARCHY ON DEPTNO = 20 AND ROOT IS JONES

SELECT LEVEL, E.* FROM EMP E WHERE DEPTNO = 10
    START WITH ENAME = 'SMITH'
    CONNECT BY PRIOR EMPNO = MGR 
    ORDER BY LEVEL;--BLANK , 
--VALUE NOT FOUND (SMITH UNDER DEPTNO = 20)

SELECT LEVEL, E.* FROM EMP E 
    START WITH ENAME = 'SMITH'
    CONNECT BY PRIOR EMPNO = MGR 
    ORDER BY LEVEL;
--HERE WE GET ONLY SMITH RECORD COZ UNDER SMITH NO ONE WORKING 
    
SELECT LEVEL, E.* FROM EMP E WHERE DEPTNO = 20
    START WITH ENAME = 'SMITH'
    CONNECT BY  EMPNO = PRIOR MGR 
    ORDER BY LEVEL;--HERE SHOW BACKWARD ONLY IN 20 DEPTNO AND ROOT IS SMITH
    
SELECT LEVEL, E.* FROM EMP E 
    START WITH SAL = (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 
                      (SELECT DEPTNO FROM DEPT WHERE DNAME = 'ACCOUNTING'))
    CONNECT BY PRIOR EMPNO = MGR
    ORDER BY LEVEL;
--USING SUB-QUERY HIERARCHY 

SELECT LEVEL,E.ENAME , E.SAL, D.DNAME , D.LOC FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    START WITH D.DNAME = 'ACCOUNTING'
    CONNECT BY E.EMPNO = E.MGR
    ORDER BY LEVEL;
--HERE START WITH ACCOUNTING SO HERE ALL ACCOUNTING ARE ROOT 

SELECT LEVEL, EMPNO, ENAME FROM EMP
    CONNECT BY PRIOR EMPNO = MGR
    START WITH ENAME = 'KING'
    ORDER BY LEVEL;
--DON'T NEED TO MENTION IN A SEQUENCE ORDER OF HIERARCHY CONCEPT..
/
SYS_CONNECT_BY_PATH FUNCTION 
/
--SINGLE ROW FUNCTION
--THIS ONE RETURNS PATH OF COLUMN FROM ROOT TO NODE (ENDING)
--THE 2ND ARG. SHOULD BE CHARACTER, NUMBER, SPECIAL CHARACTER ALSO

SELECT ENAME,
    SYS_CONNECT_BY_PATH (ENAME , '/') "PATH"
    FROM EMP
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR EMPNO = MGR;
--IT SHOW IN ROW BASIC ORDER HIERARCHY LIKE 'KING/ JONES/SCOTT'

SELECT LEVEL , EMPNO, ENAME,
    SYS_CONNECT_BY_PATH (ENAME , '-')
    FROM EMP
    START WITH ENAME = 'JONES'
    CONNECT BY PRIOR MGR = EMPNO
    ORDER BY LEVEL;--`-JONES-KING
     
SELECT LEVEL , EMPNO, ENAME,
    SYS_CONNECT_BY_PATH (ENAME , '+')
    FROM EMP
    START WITH ENAME = 'JONES'
    CONNECT BY  MGR = PRIOR EMPNO
    ORDER BY LEVEL;--`JONES +FORD......
     
SELECT LEVEL , EMPNO, ENAME,
    SYS_CONNECT_BY_PATH (ENAME , '&')
    FROM EMP
    START WITH ENAME = 'JONES'
    CONNECT BY  MGR = PRIOR EMPNO
    ORDER BY LEVEL;--`JONES  & FORD......
    
SELECT LEVEL , EMPNO, ENAME,
    SYS_CONNECT_BY_PATH (ENAME , ' 143DEPEND  ')
    FROM EMP
    START WITH ENAME = 'JONES'
    CONNECT BY  MGR = PRIOR EMPNO
    ORDER BY LEVEL;--`IT WORKS WITH ALPHA BETIC ALSO

SELECT LEVEL, EMPNO, ENAME, 
    SYS_CONNECT_BY_PATH (SAL , '  -->  ') FROM EMP
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR EMPNO = MGR
    ORDER BY LEVEL;--   KING -->  JONES
/
--PSEUDO COLUMN
--==============
/
--PSEUDO COLUMN BEHAVE A LIKE A TABLE COLUMN BUT NOT IS ACTUALLY STORED IN A TABLE.
--UPON PSEUDO COLUMN ONLY SELECT STATEMENT CAN BE IMPLEMENTED NOTHING ELSE (INSERT, UPDATE , DELETE CAN'T DO)
--PSEUDO COLUMN ARE AVAILABLE ARE     1.CURRVAL (RETURNS THE CUURENT VALUE OF THE SEQUENCE)
--                                    2.NEXTVAL (INCREMENT THE SEQUENCE AND RETURNED THE NEXT VALUE)                                  
--                                    3.LEVEL
--                                    4.ROWID
--                                    5.ROWNUM
--CURRVAL AND NEXTVAL USED ONLY IN    SELECT STATEMENT
--                                    INSERT STATEMENT
--                                    UPDATE STATEMENT
--CURRVAL AND NEXTVAL CAN'T BE USED IN  A SUB QUERY
--                                      A VIEW OR MATERAILZED VIEW(SNAPSHOT)
--                                      SELECT WITH DISTINCT OPTION
--                                      SELECT WITH GROUP BY OR ORDER BY CLAUSE
--                                      SELECT STAEMENT WITH ALL SET OPEARTOR
--                                      WHERE CLAUSE OF A SELECT STATEMENT
--                                      DEFAULT OPTION TO CREATE TABLE OR ALTER TABLE STATEMENT
--                                      CONDITION OF CHECK CONSTRAINT
CREATE SEQUENCE SEQ1 ;
--HERE WE CREATE A SEQUENCE
SELECT * FROM USER_SEQUENCES;
--DICTIONARY TABLE OF SEQUENCE
--HERE WE GET   SEQUENCE_NAME
--              MIN_VALUE
--              INCREMENTED BY
--              CYCLE_FLAG
--              ORDER_FLAG
--              CACHE_SIZE
--              LAST_NUMBER
--DEFAULT ORDRER OF SEQUENCE    START WITH WILL BE 1 
--                              INCREMENTED WLL BE POSTIVE
--                              SEQUENCE IS NO CYCLE
--                              THE CACHE VALUE WILL BE 20 
--                              SEQUENCE IS NO ORDER
/
PSEUDO COLUUMN IN SELECT STATEMENT
/
SELECT SEQ1. CURRVAL FROM DUAL;--ERROR, 
--WHEN A CREATE A SEQUENCE THEN FIRST TIME CURRVAL DOESN'T WORK
--             WE HAVE TO SELECT WITH NEXTVAL ONLY.
SELECT SEQ1 . NEXTVAL FROM DUAL;
--BY DEFAULT 1 SO HERE NEXTVAL IS 1
SELECT SEQ1.NEXTVAL FROM DUAL;
-- THEN INCREMENTED BY 1 BY DEFAULT
SELECT SEQ1.CURRVAL FROM DUAL;
--AGAIN WE CHECK WHAT IS THE CURRENT VALUE
SELECT SQ.NEXTVAL , EMPNO, ENAME FROM EMP;
--AUTOMATIC SHOW 14 RECORD OF EMP IN NEXTVALUE 
SELECT 'OD' || SQ.NEXTVAL , EMPNO, ENAME FROM EMP;
SELECT 'OD' || SUBSTR(ENAME ,1,1) || SQ.NEXTVAL FROM EMP;
--HERE WE GET ENAME 1ST LETTER WITH NEXTVAL 
--IT LOOK LIKE VEHICLE NO.

/
PSEUDO COLUMN IN INSERT STATEMENT
/
CREATE TABLE CHECKIT (ID NUMBER) SEGMENT CREATION IMMEDIATE;
SELECT * FROM CHECKIT;
--SEGMENT CREATION IMMEDIATE IS USED FOR WHEN WE 
         --INSERT ANY VALUE THEN IT START FROM 1 OTHERWISE IT INSERT 2 AUTOMATICALLY.
         
CREATE SEQUENCE SEQCHK2 ;
INSERT INTO CHECKIT VALUES (SEQCHK2.NEXTVAL);
COMMIT;
SELECT * FROM CHECKIT;

CREATE TABLE SEQCHK (ID NUMBER);
CREATE SEQUENCE SQ ;
SELECT SQ.NEXTVAL FROM DUAL;--1
INSERT INTO SEQCHK VALUES (SQ.CURRVAL);--1
INSERT INTO SEQCHK VALUES (SQ.NEXTVAL);--2
INSERT INTO SEQCHK VALUES (SQ.NEXTVAL);--3
COMMIT;
SELECT * FROM SEQCHK;--HERE RETURN RESULT ORDERING LIKE 1,2,3
/
PSEUDO COLUUMN IN UPDATE STATEMENT
/
INSERT INTO SEQCHK VALUES (10);
COMMIT;
SELECT * FROM SEQCHK;
UPDATE SEQCHK SET ID = SQ.NEXTVAL WHERE ID = 10;
--HERE AUTOMATIC UPDATED NO NEED TO COMMIT
SELECT * FROM SEQCHK;
--HERE UPDATED, WHERE ID = 10 IT UPDATED TO NEXTVAL MEAN 4
SELECT SQ.CURRVAL FROM DUAL;
/
SEQUENCE SCHEMA OBJECT--(CHECK SEQUENECE FROM ONE USER TO ANOTHER USER) 
/
GRANT CREATE SEQUENCE TO SCOTT;--NOW SCOTT USER CREATE SEQUENCE (IN DBA TO SCOTT)
GRANT SELECT ANY SEQUENCE TO SCOTT;--NOW SCOTT USER SELECT ANY SEQUENCE (IN DBA TO SCOTT)
/
FOR SEQUENCE IN OTHER SCHEMA --(CHECK SEQUENECE FROM ONE USER TO ANOTHER USER) 
/
SELECT SCOTT.SQ.CURRVAL FROM DUAL;--IN ANOTHER USER (DEV) (57)
SELECT SCOTT.SQ.NEXTVAL FROM DUAL;--IN DEV USER (58)
SELECT SQ.CURRVAL FROM DUAL;--(57)IN SCOTT , COZ ON THIS USER LAST SEQUENCE IS 57
SELECT SQ.NEXTVAL FROM DUAL;--(59)IN SCOTT,COZ WE INCREASE SEQUENCE IN DEV USER 
/
FOR SEQUENCE IN REMOTE DATABASE --ONE DOMAIN TO ANOTHER DOMAIN FETCH DATA
/
SCHEMA_NAME. SEQUENCE_NAME. CURRVAL @ DBLINK
SCHEMA_NAME. SEQUENCE_NAME. NEXTVAL @ DBLINK
/
START WITH CLAUSE
--WHERE WE WANT START THE SEQUENCE 
--BY DEFAULT START WITH VALUE IS 1
--IN START WITH WE TAKE ONLY INTEGER NOT DECIMAL VALUE
--WE CAN START WILL BE 0 ALSO.
CREATE SEQUENCE SEQ2
    START WITH 10;
    
SELECT SEQ2.NEXTVAL FROM DUAL;--10
SELECT SEQ2.NEXTVAL FROM DUAL;--DEFAULT 1 INCREMENT
SELECT SEQ2.NEXTVAL+0.5 FROM DUAL;
--HERE WE ALSO USE ARITHMATIC OPERATION ON OVER SEQUENCE

CREATE SEQUENCE SEQ3
    START WITH 1.5;--ERROR 
--WE CAN'T TAKE DECIMAL VALUE IN START WITH, START WITH MUST BE A INTEGER
    
CREATE SEQUENCE SEQ3 
    START WITH 6
    MINVALUE 7;--ERROR , 
--ALWAYS START WITH GREATER THAN AND EQUAL TO MIN VALUE
/
INCREMENT BY CLAUSE
--IT SPECIFIES THE INTERVAL BETWEEN SEQUENCE NUMBER
--IF INCREMENT VALUE IS POSITIVE THEN IT IS INCREMENTED
--IF INCREMENT VALUE IS NEGATIVE THEN IT IS DECREMENTED
--BUT , INCREMENT VALUES CAN'T BE 0.
--IN DECREMENT WE HAVE TO MENTION MAXVALUE AND MAXVALUE > START WITH

CREATE SEQUENCE SEQ3 
    START WITH 7
    INCREMENT BY 2;
SELECT SEQ3.NEXTVAL FROM DUAL;--7
SELECT SEQ3.NEXTVAL FROM DUAL;--9 --INCREMENTED (POSITIVE)

CREATE SEQUENCE SEQ20
    START WITH 4
    INCREMENT BY -2 ;--ERROR , 
--MAXVALUE  >= START WITH,
--WHEN WE DECREMENT THEN WE HAVE TO MENTION MAXVALUES

CREATE SEQUENCE SEQ4
    START WITH 4
    INCREMENT BY -2
    MAXVALUE 4;
SELECT SEQ4.NEXTVAL FROM DUAL;--4    
SELECT SEQ4.NEXTVAL FROM DUAL;--2
SELECT SEQ4.NEXTVAL FROM DUAL;--0
SELECT SEQ4.NEXTVAL FROM DUAL;---   -2  , -4,-6,-8,-10.................  

CREATE SEQUENCE SEQ21
    START WITH -10
    INCREMENT BY -2
    MAXVALUE -1
    MINVALUE -20;
SELECT SEQ21.NEXTVAL FROM DUAL;--   -10
SELECT SEQ21.NEXTVAL FROM DUAL;--   -12   (UPTO -20)
SELECT SEQ21.CURRVAL FROM DUAL;--   -20

CREATE  SEQUENCE SEQ11
    START WITH -20
    MINVALUE -30
    MAXVALUE -12;
--ALWAYS MAXVAL > START WITH, MINVAL 
--START WITH > MINVAL
SELECT SEQ11.NEXTVAL FROM DUAL;--    -20 , -19............UPTO -12
    
CREATE SEQUENCE SEQ6
    START WITH 3
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 5;
SELECT (SEQ6.NEXTVAL) FROM DUAL;--START FROM 3 UPTO 5

CREATE SEQUENCE SEQ8
    START WITH 12 
    INCREMENT BY 5;
SELECT SEQ8.NEXTVAL FROM DUAL;--INCREASED WITH INCREMENT BY CLAUSE    

CREATE SEQUENCE SEQ20
    START WITH 5
    INCREMENT BY -1
    MAXVALUE 5;
SELECT SEQ20.NEXTVAL FROM DUAL;--   5........-1..........

CREATE SEQUENCE SEQ22
    START WITH -6
    INCREMENT BY -1
    MAXVALUE -5;
SELECT SEQ22.NEXTVAL FROM DUAL;--   -6, -7.............
/
MINVALUE / NOMINVALUE
--USING MINVALUE WE SET THE LOWER BOUNDARY OF A SEQUENCE.
--MINVALUE <= START WITH
--MINVALUE < MAXVALUE
--AFTER MAXVALUE ,IF WE MENTION CYCLE THEN IT WILL START FROM MIN VALUE
--BY DEFAULT  NOMINVALUE IS SET
--            MINVALUE IS 1
--            NOMNINVALUE IS EQUAL TO START WITH VALUE WHEN YOU DON'T MENTION CYCLE.

CREATE SEQUENCE SEQ15
    START WITH 2
    MINVALUE 3;--ERROR 
--ALWAYS START > MIN VALUE

CREATE SEQUENCE SEQ16
    START WITH 4 
    MINVALUE 3;
SELECT SEQ16.NEXTVAL FROM DUAL;--START FROM 4 HERE MINVAL NO WORK 

CREATE SEQUENCE SEQ17
    START WITH 4
    MAXVALUE 8
    CYCLE 
    NOCACHE ;
SELECT SEQ17.NEXTVAL FROM DUAL;
--BY DEFAULT MIN VALUE IS 1 SO AFTER MAX VALUE IT CYCLE FROM 1

CREATE SEQUENCE SEQ12
    START WITH 5
    MINVALUE 4
    CYCLE  
    INCREMENT BY 1
    MAXVALUE 10
    CACHE 5;
SELECT SEQ12.NEXTVAL FROM DUAL;
--HERE STARTING VALUE IS 5 UPTO 10 , THEN IT CYCLE AND START FROM 4 (MIN V)    

CREATE SEQUENCE SEQ13
    START WITH 2
    NOMINVALUE
    MAXVALUE 8;
SELECT SEQ13.NEXTVAL FROM DUAL;
--START FROM 2 UPTO 8
--BUT HERE BY DEFAULT MIN VALUE IS 1.

CREATE SEQUENCE SEQ14
    START WITH 5 
    MINVALUE 2
    MAXVALUE 10
    CYCLE 
    NOCACHE;
SELECT SEQ14.NEXTVAL FROM DUAL;
--START FROM 5, UPTO 10, AFTER 10 IT CYCLE FROM 2 (MIN VALUE)    
/
MAXVALUE / NOMAXVALUE CLAUSE 
/

--WHEN WE SPECIFY THE MAXVALUE THEN IT WILL GENERATED
--IF WE DON'T CONSIDER MAXVALUE THEN IT AUTOMATICALLY  CONSIDER NOMAX VALUE 
--THE LIMITATION OF MAXVALUE IS 10 TO POWER 27 (9999999999999999999999999999)
--ALWAYS MAXVALUE > START WITH VALUE

CREATE SEQUENCE SEQ18 
    START WITH 4 
    MAXVALUE 9;
SELECT SEQ18.NEXTVAL FROM DUAL;--4 TO 9

CREATE SEQUENCE SEQ19
    START WITH -10
    MAXVALUE -5
    MINVALUE -15;
SELECT SEQ19.CURRVAL FROM DUAL;
--START WITH -10 AND END IN -5

CREATE SEQUENCE SEQ23
    START WITH 3
    NOMAXVALUE;
SELECT * FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'SEQ23'; 
--MAXVALUE = 9999999999999999999999999999                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
/

CYCLE / NOCYCLE CLAUSE
/
--IF WE SPECIFY CYCLE CLAUSE IN A SEQUENCE THEN, IT WILL CONTINUE GENERATE THE SEQUENCE VALUE AFTER MAXVAL
--IF WE DON'T SPEICIFIED CYCLE CLAUSE IN A SEQUENCE THEN, IT TAKEN BY DEFAULT NOCYCLE 
--WHEN WE USE CYCLE THEN MUST REQUIRE MAX VALUE
    
CREATE SEQUENCE SEQ10 
    START WITH 5
    MINVALUE 4
    CYCLE;--ERROR,  
--WHEN WE USE CYCLE THEN MUST REQUIRE MAX VALUE

CREATE SEQUENCE SEQ24
    START WITH 3
    MINVALUE 4
    MAXVALUE 10
    CYCLE ;--ERROR , 
--ALWAYS START WITH > MINVALUE 

CREATE SEQUENCE SEQ25 
    START WITH 3
    MINVALUE 2
    MAXVALUE 7
    CYCLE ;--ERROR, ALWAYS CACHE = MINVAL TO MAXVALUE
    
CREATE SEQUENCE SEQ26
    START WITH 3
    MINVALUE 2
    MAXVALUE 9
    CYCLE 
    CACHE 2;
SELECT SEQ26.NEXTVAL FROM DUAL;
--START FROM 3 THEN AFTER REACH MAXVAL THEN IT CYCLE FROM MINVAL

CREATE SEQUENCE SEQ27
    START WITH 8
    MAXVALUE 10
    MINVALUE 2
    NOCYCLE ;
SELECT SEQ27.NEXTVAL FROM DUAL;
--START FROM 8 TO 10, AFTER THAT IT WILL STOPPED(BY DEFAULT)    

/
CACHE / NOCACHE CLAUSE 
/
--IN ORACLE SERVER PRE ALLOCATES SOME SEQUENCES IN MAIN MEMORY AND CACHE MEMORY
--CACHE PROVIDE FASTER ACCESS FOR GENERATE SEQUENCE VALUES
--WHEN WE SPECIFIED CACHE SOME VALUES THEN THOSE VALUES ARE ALLOCATE TO CACHE MEMORY
--BY DEFAULT CACHE MEMORY IS 20
--ALWAYS CACHE < MAXVALUE
--IF WE USE CYCLE IN A SEQUENCE THEN AFTER REACHING MAXVALUE CACHE REMOVE ALL CACHE THEN AGAIN RELAOD CACHE .
--IF WE DON'T WANT TO PROVIDE CACHE IN A SEQUENCE THEN WE CAN ALSO PROVIDE NOCACHE CLAUSE.
--ALWAYS CACHE = MINVAL TO MAXVALUE RANGE

CREATE SEQUENCE SEQ28 
    START WITH 3
    MINVALUE 2
    MAXVALUE 7
    CYCLE ;--ERROR, 
--ALWAYS CACHE = MINVAL TO MAXVALUE RANGES

CREATE SEQUENCE SEQ28
    START WITH 3
    MINVALUE 2
    MAXVALUE 5
    CYCLE
    CACHE 2;
SELECT SEQ28.NEXTVAL FROM DUAL;
--START FROM 3 UPTO 5, THEN IT WILL CYCLE FROM 2

CREATE SEQUENCE SEQ29 
    START WITH 5 
    MINVALUE 3 
    MAXVALUE 9
    INCREMENT BY 3
    CYCLE 
    NOCACHE;
SELECT SEQ29.NEXTVAL FROM DUAL;
--HERE CACHE MEMORY NOT WORKED..

CREATE SEQUENCE SEQ9 
    START WITH 5
    MINVALUE 4
    CYCLE
    MAXVALUE 10;--ERROR
--ERROR CACHE ARE GREATER THAN THE VALUE RANGE

/
ORDER CLAUSE
/
--IT GUARRENTIES THE SEQUENCE NO. TO BE GENERATED IN THE ORDER OF REQUEST
/
NOORDER CLAUSE
/
--IT DOESN'T GUARRENTY THE SEQUENCE NO. TO BE GENERATED IN THE ORDER OF REQUESTED

/
MODIFYING A SEQUENCE 
/
--USING ALTER COMMAND WE CAN MODIFY PRESENT STATUS OF SEQUENCE
--ALTER COMMAND ONLY USED FOR INCREMENT VALUE, MAXVALUE,MINVALUE, CYCLE , CACHE
--WHEN ALTER ANY SEQUENCE THEN IT ONLY AFFECTED FUTUTRE SEQUENCES.
--START WITH VALUE WE CAN'T ALTER 
--IF WE WANT TO CHANGE MAXVALUE USING ALTER THEN IT SHOULD BE GREATER THAN THE CURRENT SEQUENCE VALUE.

CREATE SEQUENCE SEQ30
    START WITH 3
    MINVALUE 2
    MAXVALUE 10
    INCREMENT BY 2
    NOCYCLE
    CACHE 8;
SELECT * FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'SEQ30';    

ALTER SEQUENCE SEQ30
    MAXVALUE 25
    INCREMENT BY 3
    CYCLE ;

SELECT * FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'SEQ30';--ALTERED    
    
/ 

LEVEL PSEUDO COLUMN 
/
--IT PSEUDO COLUMN WHICH DOESN'T STORE PHYSICAL IN A TABLE 
--LEVEL PSEUDO COLUMN TO MAKE A HIERARCHICAL KEY BETWEEN PARENT AND CHILD
--TO ESTABLISH A HIERARCHICAL KEY RELATIONSHIP WITH LEVEL WE REQUIRED CONNECT BY CLAUSE

/
--ROOT :
--=========
-- IT IS THE HIGHEST NODE OF A HIERARCHICAL KEY 
--FROM ROOT THE RELATIONSHIP WAS START

PARENT
/
--THIS IS THE NODE WHERE IT HAS CHILDREN

LEAF
/
--LEAF IS THE LAST RELATIONSHIP IN A TREE
--IT DOESN'T CONTAIN ANY OTHER CHILDREN 
--START WITH PLACE A VITAL ROLE TO MAKE REALTIONSHIP FROM A PARTICULAR BRANCH / NODE .
/
SELECT ENAME , LEVEL FROM EMP;--ERROR
-- WHEN WE USE LEVEL PSEUDO COLUMN THEN WE HAVE MUST SPECIFED CONNECT BY CLAUSE.

SELECT LEVEL FROM DUAL;--ERROR 
--CONNECT BY CLAUSE REQUIRED .

SELECT LEVEL FROM DUAL 
    CONNECT BY LEVEL ;--ERROR  
--INVALID RELATION OPEARATOR.

SELECT LEVEL FROM DUAL 
    CONNECT BY LEVEL <= 7;
--IT PRINTS 1 TO 7 NO .

SELECT LEVEL FROM DUAL 
    CONNECT BY LEVEL = 7;
--OP ONLY 1 COZ
--LEVEL ALWAYS START FROM 1 AND HERE WE MENTION ONLY ONE VALUE = 7

SELECT LEVEL +1 FROM DUAL
    CONNECT BY LEVEL = 7;
--OP ONLY 2 , COZ HERE LEVEL+1 
    
SELECT LEVEL +2 FROM DUAL
    CONNECT BY LEVEL <= 7;--3 TO 9

SELECT LEVEL FROM DUAL 
    CONNECT BY LEVEL+1 <=7;
--1 TO 6
--1ST LEVEL WORK AS FROM WHICH VALUE WE WANT START 
--2ND LEVEL WORK AS HOW MANY LEVEL WE WANT TO SEE

SELECT LEVEL, LEVEL+1 FROM DUAL
    CONNECT BY LEVEL <= 7;
    
SELECT LEVEL FROM DUAL
    CONNECT BY LEVEL > 9;--1
--IF WE SPECIFY GRATER THAN IT WILL CONSIDER ONLY 1 VALUE NOTHING ELSE
    
SELECT SYSDATE FROM DUAL;--29-JUL-22
SELECT TRUNC(SYSDATE, 'MON') FROM DUAL;--01-JUL-22

--Q.DISPLAY FIRST 6 DATE OF CURRENT MONTH IN SQL WITHOUT USING LOOP ?
SELECT TRUNC(SYSDATE, 'MON')+ LEVEL-1 FROM DUAL
    CONNECT BY LEVEL <= 6;--HERE WE GET 1ST 6 DATE OF OF THIS MONTH
    
--Q.DISPLAY THE LAST 10 DAYS OF NEXT MONTH ?    
SELECT LAST_DAY(ADD_MONTHS (TRUNC(SYSDATE, 'MON'),1))-LEVEL+1 FROM DUAL
    CONNECT BY LEVEL <= 10;
--LAST 10 DAY OF NEXT MONTH
    
SELECT LPAD ('KING', 6) FROM DUAL;
--HERE WE GET BEFORE KING 2 SPACE ADD USING LPAD

SELECT LEVEL , LPAD(ENAME , LEVEL + LENGTH(ENAME), '  ') FROM EMP
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR EMPNO = MGR;--HERE WE GET LEVEL WISE HIREARCHY WITH PSEUDO COLUMN

SELECT LEVEL , LPAD(' ', 2*(LEVEL - 1)) || ENAME AS ORG_CHART , EMPNO, MGR, JOB, SAL FROM EMP    
    START WITH ENAME = 'KING'
    CONNECT BY PRIOR EMPNO = MGR;
        
SELECT LPAD ('*', LEVEL , '*') FROM DUAL
    CONNECT BY LEVEL <= 5;
--    *
--    **
--    ***
--    ****
--    *****
--OR
SELECT LPAD ('*',1, '*' ) FROM DUAL
    UNION ALL
    SELECT LPAD ('*', 2, '*') FROM DUAL
    UNION ALL
    SELECT LPAD ('*', 3, '*') FROM DUAL
    UNION ALL
    SELECT LPAD ('*', 4, '*') FROM DUAL
    UNION ALL
    SELECT LPAD ('*', 5, '*') FROM DUAL;--IT WORKS LIKE THIS BT THIS ONE IS WRONG APPROACH
    
SELECT RPAD ('*', LEVEL*2-1, '*') FROM DUAL
    CONNECT BY LEVEL <=  5;
--    *
--    ***
--    *****
--    *******
--    *********    


/
TASK 1
/
SELECT LPAD(LPAD('*', LEVEL*2-1, '* ') , 5 , ' ') FROM DUAL
    CONNECT BY LEVEL <=3;
--        *
--      * *
--    * * *    
/
TASK 2
/
SELECT LPAD (LPAD ('*', LEVEL*2, ' *'), 10+LEVEL, ' ') FROM DUAL
    CONNECT BY LEVEL <= 3;
--              *
--             * *
--            * * *    
    
TASK 4
/
SELECT SUBSTR('WELCOME', LEVEL,1 ) FROM DUAL
    CONNECT BY LEVEL <= LENGTH ('WELCOME');
--    W
--    E
--    L
--    C
--    O
--    M
--    E
/
TASK 5
/
--DISPLAY EVEN RECORDS FROM EMP TABLE ?
SELECT * FROM 
    (SELECT ROWNUM AS SLNO , EMPNO , ENAME FROM EMP) WHERE MOD (SLNO, 2)= 0;

/

--Q. DISPLAY ALL MONTHS WITHOUT USING ADD MONTHS ADD TRUNC ?
SELECT TO_CHAR(TO_DATE (LEVEL, 'MM'), 'MONTH') AS MONTHS FROM DUAL CONNECT BY LEVEL<=12;
--JANUARY  
--FEBRUARY 
--MARCH    
--APRIL    
--MAY      
--JUNE     
--JULY     
--AUGUST   
--SEPTEMBER
--OCTOBER  
--NOVEMBER 
--DECEMBER 
/

ROWNUM PSEUDO COLUMN
/
--IT DOESN'T STORE DATA PHYSICAL IN A TABLE , IT STORES DATA LOGICALLY.
--THROUGH THIS PSEUDO COLUMN WE GET INCREMENTAL SEQUENCE NO OF EACH ROW.
--THE 1ST ROW IS 1 , 2ND ROW IS 2 AND SO ON.............
--IT ALWAYS START FROM 1 UPTO N.............
--THROUGH THIS PSEUDO COLUMN WE GET WHAT ARE THE LIMIT OF ROWS IN A TABLE .
--THIS PSEUDO COLUMN ALWAYS CHECK CONDITION WITH EQUAL TO 1 , IF ROWNUM IS NOT SATISFIED WITH 1 , THEN IT 
                                                                                    --DISPLAY BLANK RECORD.
--THROUGH THIS PSEUDO COLUMN WE FIND THE NTH RECORD .
--IT IS SUPPORTED WHEN NO DUPLICATE IS PRESENT.
/
SELECT ROWNUM , EMPNO, ENAME FROM EMP;
--HERE WE GET THE ROWNUM WITH DATA .
SELECT ROWNUM , E.* FROM EMP E WHERE DEPTNO = 10;
--HERE WE GET ROWNUM AND DATA OF DEPT 10 EMPLOYEES.
SELECT ROWNUM,E.* FROM EMP E WHERE ROWNUM = 1;
--1ST RECORD OF EMP TABLE
SELECT * FROM EMP WHERE ROWNUM =1;
SELECT * FROM EMP WHERE ROWNUM = 2;
--BLANK COZ ROWNUM ALWAYS START FROM 1 VALUE.
SELECT * FROM EMP WHERE ROWNUM >1;
--HERE ALSO BLANK , COZ ROWNUM ALWAYS START FROM 1 AND WE SPECIFIED > 1.
SELECT * FROM EMP WHERE ROWNUM = 0;
--ROWNUM CAN'T BE 0, COZ IT WAS ALWAYS START FROM 1.
SELECT * FROM EMP WHERE ROWNUM > 0;
--GET ALL RECORD.
SELECT * FROM EMP WHERE ROWNUM <= 10;
--FIRST 10 RECORD.
SELECT * FROM EMP WHERE ROWNUM = 15-14;
--1ST RECORD 
SELECT * FROM EMP WHERE ROWNUM = 10/2;
--BLANK , COZ ALWAYS START FROM 1.
SELECT ROWNUM+2, E.* FROM EMP E ORDER BY ROWNUM ;
--WE DO ARITHMATIC OPERATION UPON ROWNUM
SELECT * FROM
    (SELECT * FROM EMP ORDER BY SAL DESC )WHERE ROWNUM <= 5;
--HERE WE GET TOP 5 HIGHEST PAID EMPLOYEE
--THIS IS THE NOT A RIGHT APPROACH COZ HERE DUPLICATE VALUES ARE STORED 
SELECT * FROM
    (SELECT * FROM EMP ORDER BY SAL) WHERE ROWNUM <= 3 ;
--TOP 3 EMPLOYEE WHO GET LOWEST SAL

SELECT ROWNUM, T.* FROM 
    (SELECT * FROM EMP ORDER BY SAL) T;
    
SELECT * FROM 
    (SELECT ROWNUM AS RN, E.* FROM EMP E  ) WHERE RN = 2;    
--HERE WE GET THE 2ND RECORD OF EMP TABLE

SELECT * FROM 
    (SELECT ROWNUM AS RN, T.*FROM 
    (SELECT * FROM EMP ORDER BY SAL ) T) WHERE RN = 2;
--HERE WE GET THE ONLY EMPLOYEE WHO GET 2ND LOWEST SAL

SELECT * FROM EMP WHERE ROWNUM <= 
    (SELECT COUNT(*)/2 FROM EMP );
--HERE WE GET HALF RECORD OF EMP TABLE .

SELECT AVG(SAL) FROM EMP WHERE ROWNUM <=7 GROUP BY DEPTNO;
--HERE 1ST ROWNUM FIND THEN DEPTNO WISE GET THE AVG SAL .

SELECT * FROM (
SELECT ENAME , SAL FROM EMP ORDER BY SAL DESC) WHERE ROWNUM <=3;

--Q. DISPLAY EVEN RECORDS FROM EMP TABLE ?
SELECT * FROM 
    (SELECT ROWNUM AS SLNO , E.* FROM EMP E) WHERE MOD (SLNO, 2)= 0;

/
ROWID PSEUDO COLUMN
/
--ROWID STORES DATA AND RETURN ROW ADDRESS IN A HEXADECIMAL FORMAT.
--ROWID IS THE FASTEST WAY OF ACCESSING IN A SINGLE ROW FUNCTION
--ROWID IS AUTO GENERATED BY ORACLE AND IT DEPENDS UPON A PARTICULAR ROW.
--ROWID = 18 DIGIT (HEXA DECIMAL).
--IT DOESN'T STORED IN TABLE COLUMN PHYSICALLY.
--ROWID ARE ALWAYS UNIQUE IN A DATABASE
--A ROWID CAN NEVER CHANGE DURING THE LIFETIME OF ITS ROWS.
--IF A ROW IS DELETED THEN, ORACLE MAY RE-ASSIGN ITS ROWID TO A NEW ROW THAT IS INSERTED.
--A ROWID NEVER WE INSERTED, UPDATED, DELETED.


SELECT ROWID , E.* FROM EMP E ;
--HERE WE GET ALL ROWID WITH DATA.
SELECT * FROM EMP WHERE ROWID = 'AAAR3sAAEAAAACXAAI';
--HERE WE FIND KING THOROUGH ROWID.
SELECT LENGTH(ROWID) FROM EMP;
--18 DIGIT ROWID DIGIT.
SELECT ROWID, E.* FROM EMP E WHERE ROWID <= 'AAAR3sAAEAAAACXAAI';
--LESS THAN / EQUAL OF KING ROWID .
SELECT ROWID , E.DEPTNO, D.DEPTNO FROM EMP E INNER JOIN DEPT D 
    ON E.DEPTNO = D.DEPTNO;--ERROR
--COLUMN AMBIGUOUSLY (ROWID)

SELECT E.ROWID, D.ROWID, E.ENAME, D.DNAME, E.DEPTNO, D.DEPTNO FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO 
    ORDER BY D.DEPTNO;
--HERE WE GET ALL UNIQUE ROWID OF EMP TABLE
--THEN SAME TIME WE GET ALL UNIQUE ROWID OF DEPT WISE OF DEPT TABLE

SELECT ROWID, DEPTNO FROM EMP WHERE DEPTNO = 10;
--HERE WE GET RECORD WISE(DEPTNO =10) ROWID..

--HOW WE DELETE A DUPLICATE DATA USING ROWID :
--===================================================
CREATE TABLE DUPLICATE (ID NUMBER, NAME VARCHAR2(10));
SELECT * FROM DUPLICATE;
SELECT ROWID, D.* FROM DUPLICATE D ;
--HERE WE SEE ALL UNIQUE ROWID WITH DATA 
SELECT MAX(ROWID) FROM DUPLICATE ;
--GET THE MAX ROWID LETTER WISE
SELECT MIN (ROWID) FROM DUPLICATE;
--GET THE MIN ROWID LETTER WISE
SELECT * FROM DUPLICATE WHERE ROWID NOT IN 
    (SELECT MAX (ROWID) FROM DUPLICATE GROUP BY ID );
--HERE WE FIND THE DUPLICATE VALUE .
DELETE FROM DUPLICATE WHERE ROWID NOT IN 
    (SELECT MAX (ROWID) FROM DUPLICATE GROUP BY ID );
--HERE WE DELETE THE DUPLICATE VALUE .

SELECT * FROM DUPLICATE;

CREATE TABLE DUP_DEL (ID NUMBER);
INSERT INTO DUP_DEL VALUES (1);
INSERT INTO DUP_DEL VALUES (1);
INSERT INTO DUP_DEL VALUES (2);
INSERT INTO DUP_DEL VALUES (2);
INSERT INTO DUP_DEL VALUES (3);
SELECT * FROM DUP_DEL;

DELETE FROM DUP_DEL D WHERE ROWID < 
    (SELECT MAX(ROWID) FROM DUP_DEL D2 WHERE D.ID = D2.ID);
    
SELECT * FROM DUP_DEL;    

/


--OLAP FEATURES IN ORACLE  (ONLINE ANALYTICAL PROCESS)
--======================================================
--THIS CONCEPT ARE USED IN DATA WAREHOUSE AND DATA MART.
--BY USING OLAP FEATURES WE CAN PERFORM DATA ANALYSIS IN A EFFICIENT WAY.
--IT COLLECT DATA FROM DIFFERENT DATABASE STORE AND TOGETHER IN ONE DATABSE.
--THE OLAP FEATURES ARE PERFORMANCE ENHANCEMENT :
--          * TOP_N QUERIES
--          * GROUP BY
--          * CUBE
--          * ROLLUP
/

ROLLUP

/
--IT IS A GROUP BY OPERATION 
--IT IS USED TO GENERATE GRAND TOTAL BASED ON SUB TOTAL.
--ROLLUP ALWAYS USED WITH GROUPING FUNCTION
--IT WILL DISPLAY THE ONLY COMBINATION OF COLUMN.
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO 
    UNION ALL
    SELECT NULL, SUM(SAL) FROM EMP;
--WE GET THIS TYPE OF VALUE BEFORE ROLLUP USING UNION ALL SET OPERATOR
--NOW WE SEE THE BENEFITS OF ROLLUP .

SELECT DEPTNO, SUM (SAL) FROM EMP 
    GROUP BY ROLLUP (DEPTNO);
--HERE WE GET GRAND TOTAL OF ALL SUM(SAL) LIKE AS UNION ALL

SELECT NVL(TO_CHAR(DEPTNO), 'GRAND TOTAL')AS DEPTNO , SUM (SAL) FROM EMP 
    GROUP BY ROLLUP (DEPTNO);
--HERE WE USE TO-CHAR , NVL FUNCTION FOR ADDING A MESSAGE / EXPRESSION
--OR
SELECT DECODE(DEPTNO, NULL, 'GRAND', DEPTNO) AS ALL_DATA, 
        SUM(SAL) FROM EMP 
        GROUP BY ROLLUP( DEPTNO);
        
SELECT DEPTNO, COUNT(*) FROM EMP
    GROUP BY ROLLUP (DEPTNO);
--HERE GET THE GRAND COUNT ALL DEPTNO 

SELECT NVL(JOB,'GRAND TOTAL OF ALL JOB'), SUM(SAL) FROM EMP
    GROUP BY ROLLUP (JOB);
--HERE WE COVERED NULL VALUE WITH NVL FUNCTION

SELECT DEPTNO , JOB , SUM(SAL) FROM EMP
    GROUP BY ROLLUP (DEPTNO, JOB)
    ORDER BY DEPTNO;
--HERE 1ST PRIORIRY 1ST GROUP BY COLUMN THEN 2ND.
--DEPTNO WISE IT WLL FIND THE JOB, IF ANY JOB IS DUPLICATE BUT THEY ARE SAME DEPTNO THEN IT WILL MAKE SUB-TOTAL.

SELECT DEPTNO , JOB , SUM(SAL) FROM EMP
    GROUP BY ROLLUP (JOB ,DEPTNO )
    ORDER BY JOB;
--HERE SAME WORK PROGRESS BT 1ST PRIORIY IS JOB WISE

SELECT NVL (JOB, 'GRAND TOTAL'), DEPTNO, SUM(SAL) FROM EMP 
    GROUP BY ROLLUP (JOB,DEPTNO); 

--Q.DISPLAY DEPARTMENT WISE MAX OF SAL ALONG HIGHEST MAX SAL 
SELECT DEPTNO, MAX(SAL) FROM EMP
    GROUP BY ROLLUP (DEPTNO);
--HERE WE GET THE ALL MAX SAL DEPT WISE AND BETWEEN THEM WHICH ONE IS MAX      

SELECT ENAME , DEPTNO , SUM (SAL) FROM EMP
  GROUP BY ROLLUP (DEPTNO, ENAME );
--HERE 1ST SUB TOTAL OF ALL DEPTNO WISE EMPLOYEE THEN, AGAIN MAKE GRAND TOTAL TO TAKE ALL SUB TOTAL VALUES.

SELECT ENAME , DEPTNO , SUM (SAL) FROM EMP
  GROUP BY ROLLUP (ENAME, DEPTNO);
--HERE 1ST SUB TOTAL ALL EMPLOYEE WISE THEN, MAKE GRAND TOTAL TO TAKE ALL SUB TOTAL VALUES.

--Q.DISPLAY ALL MAX SAL DEPT WISE AND WHAT ARE THE OP MAKE SUM OF THIS MAX VALUE .
SELECT SUM(MAXX) FROM(
    SELECT DEPTNO, MAX(SAL)AS MAXX FROM EMP GROUP BY DEPTNO) 
    GROUP BY ROLLUP (DEPTNO) ;

SELECT D.DNAME , SUM(E.SAL)  FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    GROUP BY ROLLUP (D.DNAME);
--DNAME WISE SUMSAL WITH GRAND TOTAL    
/
CUBE
--IT IS A EXTENSION SIMILAR TO ROLLUP.
--IT WILL DISPLAY SUB TOTAL AND GRAND TOTAL FOR COMBINATION OF ALL POSSIBLE OF COLUMNS.
--IT ALWAYS WORKS WITH GROUP BY CLAUSE .

SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;
--NORMAL AGGREGATE FUNCTION

SELECT JOB, DEPTNO , SUM(SAL) FROM EMP 
    GROUP BY DEPTNO , JOB
    ORDER BY DEPTNO;
--NORMAL AGGREGATE FUNCTION

SELECT DEPTNO, SUM(SAL) FROM EMP
    GROUP BY CUBE (DEPTNO)
    ORDER BY DEPTNO;
--WORKS LIKES AS A ROLLUP , MAIN DIFFERENCE WE GET WHEN WE TAKE MULTIPLE COLUMN

SELECT DEPTNO, JOB, SUM(SAL) FROM EMP
    GROUP BY CUBE (DEPTNO, JOB)
    ORDER BY DEPTNO;
--HERE MAKE A SUB TOTAL 1ST GROUP BY COLUMN , THEN 2ND , AFTER THAT MAKE GRAND TOTAL TO TAKE SUBTOTAL OF 1ST 
--                                                                                     GROUP BY COLUMN

SELECT JOB, DEPTNO , SUM(SAL)FROM EMP
    GROUP BY CUBE (JOB, DEPTNO)
    ORDER BY JOB;
--HERE ALSO SAME WORK BT HERE 1ST PRIORITY IS JOB, THEN, DEPTNO.   

/ 
GROUPING FUNCTION
--IT ACCEPT ONLY ONE ARGUMENT.
--GROUPING FUNCTION ACCEPT A COLUMN AND RETURNED 0 AND 1 VALUE.
--GROUPING FUNCTION RETURNS 1 WHEN THE COLUMN VALUE IS NULL.
--GROUPING FUNCTION RETURNS 0 WHEN THE COLUMN VALUE IS NOT NULL.
--THIS FUNCTION ONLY USED UPON QUERIES THAT USE ROLLUP AND CUBE.

SELECT GROUPING (DEPTNO), DEPTNO , SUM(SAL) FROM EMP GROUP BY ROLLUP (DEPTNO);
--HERE FIND DEPTNO VALUE , WHERE DEPTNO VALUE IS NOT NULL THEN IT DISPLAY IN GROUPING COLUMN IS 0 AND..
--WHERE FIND NULL IN DEPTNO COLUMN THEN IT DISPLAY 1 .

SELECT GROUPING (DEPTNO), DEPTNO, SUM (SAL) FROM EMP GROUP BY CUBE (DEPTNO);
--HERE ALSO SAME WORK PROGRESS..

SELECT GROUPING (DEPTNO) AS DEPT_GRP, GROUPING (JOB) AS JOB_GRP, DEPTNO, JOB, SUM(SAL) FROM EMP 
    GROUP BY CUBE (DEPTNO, JOB)
    ORDER BY DEPTNO;
--HERE WE SPECIFY 2 GROUPING FUNCTION , AND WORK AS SAME.
--WHERE DEPTNO COLUMN IS NULL IT DISPLAY 1 AND OTHER WISE 0
--WHERE JOB COLUMN IS NULL IT DISPLAY 1 AND OTHER WISE 0

SELECT GROUPING (DEPTNO, JOB) FROM EMP GROUP BY JOB, DEPTNO;--ERROR
--GROUPING FUNCTION ONLY ACCEPT 1 ARGUMENT 

SELECT GROUPING (DEPTNO) , GROUPING (JOB), DEPTNO, JOB, SUM(SAL) FROM EMP 
    GROUP BY ROLLUP (DEPTNO , JOB);
--WHERE A VALUE IS NOT NULL THEN IT DISPLAY  0
--WHERE A VALUE IS NULL IT DISPLAY 1.
    
/
DECODE
/
--IT IS A SINGLE ROW FUNCTION.
--IT WORKS LIKE "IF THEN ELSE" CONDITION.
--WHEN IF CONDITION SATISFIED THEN IT WILL GIVE THE RESULT AND NOT SATISFIED THEN IT WILL GO TO ELSE PART.
--IF WE DON'T PASS ELSE CONDITION THEN IT WILL DISPLAY NULL.
--THE 1ST PARAMETER IS ALWAYS THE NAME OF COLUMN WHICH IS GOING TO BE DECODED.
--THIS FUNCTION CAN BE USED IN SELECT CLAUSE AND WHERE CONDITION.
--IT ACCEPT MIN. 3 ARGUMENT AND MAX. N NUMBER OF ARGUMENT.
--HERE NO DATATYPE RESTRICTION.
--WE CAN'T COMPARE MULTIPLE COLUMN/VALUES IN DECODE.
--1ST RESULT COLUMN / 3RD PARAMETER SHOULD BE CHARACTER WHEN WE COMPARE WITH CHARACTER OR NUMBER.
--DECODE FUNCTION WE CAN APPLY IN WHERE CONDITION AND ORDER BY CLAUSE .

--SYNTAX :-
--DECODE (VALUE, SEARCH_VALUE, RESULT_VALUE, DEFAULT_VALUE)

SELECT DECODE ('NIEL', 'NIEL', 'YES THIS ONE MATCHING', 'NO MATCHING VALUE FIND') AS DECODE FROM DUAL;
--HERE COMPARE 1ST ARG. TO 2ND ARG. , BOTH ARE SATISFY SO IT DISPLAY 3RD ARG.

SELECT DECODE ('NIEL', 'nIEL', 'YES THIS ONE MATCHING', 'NO MATCHING VALUE FIND') AS DECODE FROM DUAL;
--HERE COMPARE 1ST ARG. TO 2ND ARG. ,BOTH ARE NOT SATISFY  SO IT DISPLAY 4TH ARG.

SELECT DEPTNO, DECODE (DEPTNO, 10, 'ACCOUNT') FROM EMP
    ORDER BY DEPTNO;
--HERE 1ST AND 2ND ARE SATISFY SO OP IS 3RD ARG. REST OF ALL DISPLAY NULL.

SELECT DEPTNO, DECODE (DEPTNO, 10, 'ACCOUNT', 'SORRY NOT FOUND') FROM EMP
    ORDER BY DEPTNO;
--HERE 1ST AND 2ND ARE SATISFY SO OP IS 3RD ARG. REST OF ALL 4TH ARG.

SELECT DEPTNO, DECODE (DEPTNO, 10, 'ACCOUNT', 20, 'RESEARCH', 'SORRY NOT FOUND') FROM EMP
    ORDER BY DEPTNO;
--HERE WE 1ST 2 ARG. IS STAISFY THN OP IS 3RD ARG.
--THEN 1ST ARG. , 4TH ARG. IS SATISY THN OP 5TH ARG.
--AND REST OF ALL 6TH ARG.

SELECT DEPTNO, DECODE (DEPTNO, 10, 'ACCOUNT', 20) FROM EMP
    ORDER BY DEPTNO;
--HERE IT TAKES 4TH ARG LIKE ELSE PART

SELECT DEPTNO , DECODE (DEPTNO, 10) FROM EMP;--ERROR
--DECODE FUNCTION ACCEPT MIN. 3 ARG. AND MAX. N NO. OF ARG.

SELECT DEPTNO, DECODE (DEPTNO, 10, (SELECT MAX (SAL) FROM EMP GROUP BY DEPTNO HAVING DEPTNO =10) ,
                        20, (SELECT MAX (SAL) FROM EMP GROUP BY DEPTNO HAVING DEPTNO = 20),
                        30, (SELECT MAX (SAL) FROM EMP GROUP BY DEPTNO HAVING DEPTNO = 30))AS DECODE FROM EMP
                        ORDER BY DEPTNO;
--HERE WE DECODE DEPTNO WISE MAX (SAL)

SELECT DEPTNO, DECODE (DEPTNO IN (10,20), 'ACCOUNT' , 'OTHERS') FROM EMP;--ERROR
--WE CAN'T TAKE MULTIPLE VALUES AT A TIME .

SELECT DEPTNO, DECODE (DEPTNO, (10,20), 'ACCOUNT') FROM EMP;--ERROR
--WE CAN'T TAKE MULTIPLE VALUES AT A TIME .

SELECT DEPTNO, DECODE (DEPTNO, 10, JOB, 'BENCH') FROM EMP
    ORDER BY DEPTNO;
--HERE 1ST AND 2ND ARG. ARE SATISY SO HERE DISPLAY THEIR JOB AND
--REST OF ALL DISPLAY BENCH

SELECT DEPTNO ,
      DECODE (DEPTNO, 10, 'ACCOUNT', 'OTHERS') AS DEPT_DESC,
      JOB, 
      DECODE (JOB, 'ANALYST', 'DATA ANALYST', 'MANAGER', 'PROJECT MANAGER', 'DEVELOPER') AS DESIGNATION
      FROM EMP
      ORDER BY DEPTNO;
--HERE WE SPECIFY MULTIPLE DECODE FUNCTION.

SELECT DEPTNO , DECODE (DEPTNO, 100, '1', 'NOT FOUND') FROM EMP;
--HERE ANY ARG. ARE NOT SATISFIED SO HERE DISPLAY ELSE PART IN ALL VALUE.

SELECT DEPTNO, DECODE (DEPTNO, 10, 'A', 20, 'B', 'C'),
    DECODE (DEPTNO, 100, 'A', 20, 'B', 'C'),
    DECODE (DECODE (DEPTNO, 100, 'A', 20, 'B', 'C'), 'A', 'A+', 'B', 'B+', 'C+')FROM EMP
    ORDER BY DEPTNO;
--HERE MULTIPLE DECODE USING

SELECT EMPNO, ENAME , DEPTNO, SAL FROM EMP 
    WHERE DECODE (DEPTNO, 10, 'ACCOUNT')= 'ACCOUNT';
--HERE CONDITION CHECK , IF CONDITION ARE SATISFIED THEN DISPLAY THE RECORD OTHER WISE BLANK

SELECT EMPNO, ENAME, DEPTNO, SAL, 
    DECODE (DEPTNO, 10, DEPTNO, DEPTNO) AS DECODED FROM EMP
    ORDER BY DECODED ;
--HERE TO USE DEPTNO WE DISPLAY A DECODE.
    
SELECT DECODE (DEPTNO, NULL, 'GRAND TOTAL', DEPTNO),
    SUM(SAL)
    FROM EMP 
    GROUP BY ROLLUP (DEPTNO);

SELECT DECODE (GROUPING (DEPTNO), 0, 'SUB TOTAL '|| DEPTNO, 'GRAND TOTAL'), SUM(SAL) FROM EMP
    GROUP BY ROLLUP (DEPTNO);

SELECT DECODE (DEPTNO,NULL , 'ALL DETAILS', DEPTNO),
    DECODE (GROUPING (DEPTNO), 0, 'SUB TOTAL', 'GRAND TOTAL'),
    SUM(SAL)FROM EMP 
    GROUP BY ROLLUP (DEPTNO);



TASK 1
--DISPLAY EMPNO, ENAME , ROWNUM AS RNK, WHEN 1 ONE ,2 TWO , SO ON...AS DESCRIPTION ONLY FOR 5 RECORDS
SELECT EMPNO, ENAME , ROWNUM AS RNK , 
    DECODE (ROWNUM, 1, 'ONE', 2, 'TWO', 3, 'THREE', 4, 'FOUR', 5, 'FIVE' ) AS DESCRIPTION
    FROM EMP WHERE ROWNUM<= 5;
/   
TASK-2
--DEPTNO10SUMSAL, DEPTNO20SUMSAL, DEPTNO30SUMSAL 8750,9400,10875
SELECT SUM(DECODE (DEPTNO, 10, SAL)) AS DEPT10SUMSAL,
        SUM(DECODE (DEPTNO,20, SAL )) AS DEPT20SUMSAL,
        SUM(DECODE (DEPTNO, 30, SAL)) AS DEPT30SUMSAL 
        FROM EMP ;

/
GROUPING SETS
--GROUPING SETS CLAUSE IS USED TO GET SUB TOTAL ROWS.
--IT DISPLAY SUB TOTAL IN SEPARATE SEPARATE ROWS.

SELECT DEPTNO, JOB, SUM(SAL) FROM EMP 
    GROUP BY JOB, DEPTNO;
--NORMAL GROUP BY FUNCTION

SELECT DEPTNO, SUM(SAL) FROM EMP
    GROUP BY GROUPING SETS (DEPTNO);
    
SELECT DEPTNO, JOB, SUM(SAL) FROM EMP
    GROUP BY GROUPING SETS (JOB, DEPTNO) 
    ORDER BY DEPTNO;
--WORKS IN GROUPING WISE SUB TOTAL 


SELECT DECODE (DEPTNO,NULL, 'JOB SUB TOTAL', DEPTNO)AS DEPTNO,
    DECODE (JOB, NULL , 'DEPT SUBTOTAL', JOB) AS JOB,
    SUM(SAL) FROM EMP
    GROUP BY GROUPING SETS (JOB, DEPTNO) 
    ORDER BY DEPTNO;
--SAME GROUP WISE RITH DECODE 

SELECT DEPTNO, JOB, SUM(SAL) FROM EMP
    GROUP BY GROUPING SETS(DEPTNO, JOB)
    ORDER BY DEPTNO;
    
SELECT JOB, DEPTNO, SUM(SAL) FROM EMP
    GROUP BY GROUPING SETS (DEPTNO, JOB)
    UNION ALL 
    SELECT 'GRAND TOTAL', NULL, SUM(SAL) FROM EMP;
--IN GROUPING SETS WE CAN'T SPECIFY GRAND TOTAL SO, IN THIS CASE UNION ALL USED HERE..    

/
CASE EXPRESSION / CASE STATEMENT
/
--CASE EXPRESSION ALSO WORK IN "IF THEN ELSE" LOGIC.
--CASE IS SIMILAR TO DECODE BUT THIS ONE IS ANSI STANDARD (AMERICAN NATIONAL STANDARD INSTITUTE)
--IT USES FOR RANGE BASED COMAPARISION.
--CASE EXPRESSION ARE EASIER TO READ IN COMPARISION TO DECODE.
--ELSE PART ARE OPTIONAL .
--IF WE DONT SPECIFY ELSE PART THEN IT BY DEFAULT DISPLAY "NULL"
--CASE EXPRESION ARE DIVIDED INTO 2 PARTS     1. SIMPLE CASE EXPRESSION
--                                            2. SEARCHED CASE EXPRESSION
--CASE STATEMENT WE CAN APPLY IN WHERE CONDOTION AND ORDER BY CLAUSE ALSO .

--SYNTAX :  CASE "SEARCH_EXPRESSION"
--                WHEN "INPUT_EXPRESSION 1" THEN "RESULT 1"
--                WHEN "INPUT_EXPRESSION 2" THEN "RESULT 2"
--                  ................................
--                  ................................
--                WHEN "INPUT_EXPRESSION N" THEN "RESULT N"
--          ELSE "ELSE RESULT"
--          END

--1. SIMPLE CASE EXPRESSION
--  ========================
--BY USING SIMPLE CASE WE CAN RETURN SOME VALUES IN A CONDITIONAL BASICS.
--HERE WE CAN SPECIFY ONLY SINGLE COLUMN.
--BASED UPON ONLY ONE SEARCH COLUMN IT WILL MATCH THE VALUES.

SELECT CASE 'NIEL'
      WHEN 'NITIN' THEN 'FALSE'
      WHEN 'MUKESH' THEN 'FALSE'
      WHEN 'NIEL' THEN 'TRUE'
      WHEN 'NIEL' THEN 'YES TRUE'
      WHEN 'niel' THEN 'I DONT KNOW'
      END AS "DEMO FOR TEST"
      FROM DUAL;
--HERE 1ST WHEN COND. SATISFY SO ONLY OP TRUE

SELECT CASE 'NIeL'
      WHEN 'NITIN' THEN 'FALSE'
      WHEN 'MUKESH' THEN 'FALSE'
      WHEN 'NIEL' THEN 'TRUE'
      WHEN 'NIEL' THEN 'YES TRUE'
      WHEN 'niel' THEN 'I DONT KNOW'
      ELSE 'KYA YAAR'
      END AS "DEMO FOR TEST"
      FROM DUAL;
--HERE NO CONDN. WAS SATISFY SO OP IS "KYA YAAR".

SELECT ENAME , DEPTNO, 
      CASE DEPTNO
      WHEN 10 THEN 'ACCOUNTS'
      WHEN 20 THEN 'RESEARCH'
      WHEN 30 THEN 'SALES'
      WHEN 40 THEN 'OPEARTION'
      ELSE 'NOT FOUND'  
      END AS CASE
    FROM EMP
    ORDER BY DEPTNO;
--HERE WE GET CASE VALUES IN DEPTNO WISE    

SELECT ENAME , DEPTNO, 
    CASE DEPTNO
      WHEN 10 THEN 'ACCOUNT'
      WHEN 20 THEN 'RESEARCH'
      ELSE 'NOT FOUND'
      END AS CASE
    FROM EMP 
    ORDER BY DEPTNO;
--HERE DEPTNO 10 SHOW CASE "ACCOUNT" , 20 "RESEARCH", REST ALL "NOT FOUND"    

SELECT ENAME , DEPTNO ,
    CASE DEPTNO
      WHEN 10 THEN 'ACCOUNT'
      WHEN 20 THEN 'RESEARCH'
      END AS CASE
    FROM EMP
    ORDER BY DEPTNO;
--ELSE ARE OPTIONAL.    
--HERE ELSE PART BY DEFAULT DISPLAY NULL    

SELECT ENAME , DEPTNO,
    CASE DEPTNO 
      WHEN 10 THEN 'ACCOUNT'
      WHEN 20 THEN 'RESEARCH'
      ELSE 'OTHERS'
    FROM EMP
    ORDER BY DEPTNO;--ERROR
--END CLAUSE COMPULSARY IN CASE.

SELECT ENAME , DEPTNO,
    CASE JOB
      WHEN 'ANALYST' THEN 'DATA ANALYST'
      WHEN 'MANAGER' THEN 'PROJECT MANAGER'
      ELSE 'DEVELOPER' 
      END AS ROLES
    FROM EMP
    ORDER BY DEPTNO;

SELECT EMPNO, ENAME , DEPTNO,
    CASE DEPTNO 
      WHEN DEPTNO = 10 THEN 'ACCOUNTING'
      WHEN DEPTNO = 20 THEN 'RESEARCH'
      ELSE 'OTHERS'
      END AS DNAME 
    FROM EMP 
    ORDER BY DEPTNO;--ERROR
--WE CANT SPECIFY COLUMN NAME IN SIMPLE CASE , HERE WE CAN PROVIE ONLY VALUES OF CASE COLUMN.

SELECT ENAME , JOB, MGR, 
    DECODE (CASE MGR 
        WHEN MGR THEN MGR
        END, NULL, 'VALUE IS NULL', MGR) AS "MGR CASE "
      FROM EMP
      ORDER BY DEPTNO;
--CASE WITH DECODE 

SELECT E.*,
    DECODE (CASE COMM
        WHEN COMM THEN COMM
        END, NULL , 'COMM IS NULL', 0, 'COMM IS ZERO', COMM) AS "CASE WITH DECODE "
      FROM EMP E 
      ORDER BY DEPTNO;
--HERE WE USE BOTH DECODE AND CASE ALSO.    

--2. SEARCHED CASE EXPRESSION
--  ===========================
--IT IS ALMOST SIMILAR TO DECODE .
--IT HELPS TO WRITING MULTIPLE CONDITION FOR EXECUTION
--WE CAN ALSO PROVIDE IN OPEARTOR , BETWEEN OPERATOR AND ANY OPERATOR AND ANY COMPARISON OPERATOR FOR RANGE OF 
--                                                                                                  ANALYSIS.
--SYNTAX :    CASE
--            WHEN "CONDITION1" THEN "RESULT1"
--            WHEN "CONDITION2" THEN "RESULT2"
--            ................................
--            ................................
--            WHEN "CONDITION N" THEN "RESULT N"
--            ELSE "ELSE RESULT N" 
--            END

SELECT ENAME , EMPNO, DEPTNO, 
    CASE
      WHEN DEPTNO = 10 THEN 'ACCOUNT'
      WHEN DEPTNO = 30 THEN 'RESEARCH'
      WHEN DEPTNO = 30 THEN 'SALES'
      ELSE 'OTHERS'
      END AS "DNAME IN SEARCH CASE"
    FROM EMP
    ORDER BY DEPTNO;
--HERE WE TAKE SPECIFIC DEPTNO AFTER CASE CLAUSE

SELECT EMPNO, ENAME , DEPTNO , 
    CASE
      WHEN DEPTNO IN (10,20) THEN 'ACCOUNTING AND RESEARCH'
      WHEN DEPTNO = 30 THEN 'SALES'
      ELSE 'OTHERS'
      END
    FROM EMP
    ORDER BY DEPTNO;
--HERE WE TAKE MULTIPLE VALUE AT A TIME , AND THIS ONE ONLY POSSIBLE SEARCHED CASE EXPRESSION

SELECT ENAME , JOB, SAL , DEPTNO,
    CASE 
      WHEN SAL BETWEEN 0 AND 999 THEN 'LOW RANGE'
      WHEN SAL BETWEEN 1000 AND 2000 THEN 'MID RANGE'
      WHEN SAL >= 2001 THEN 'HIGH RANGE'
      END AS "SALARY SLAB"
    FROM EMP
    ORDER BY DEPTNO;
--HERE WE USE SEARCH CASE IN RANGE BASIC

SELECT E.* , 
    CASE WHEN SAL BETWEEN 0 AND 1000 THEN 'LOW SAL' END AS LOWSAL,
    CASE WHEN SAL BETWEEN 1001 AND 2000 THEN 'MID SAL' END AS MIDSAL,
    CASE WHEN SAL > 2001 THEN 'HIGH SAL' END AS HISAL
    FROM EMP E
    ORDER BY SAL;
--HERE WE GET SEARCH CASE (IN DIFFERENT COLUMN WISE).

SELECT E.EMPNO, E.ENAME , 
    CASE 
      WHEN E.DEPTNO IN (10,20) THEN D.DNAME
      ELSE 'SALES'
      END 
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    ORDER BY E.DEPTNO;
--HERE WE CAN ALSO GET THE OP USING JOINS .

SELECT E.EMPNO, E.ENAME ,  
    CASE
      WHEN E.DEPTNO = D.DEPTNO THEN D.LOC
      END AS "LOCATION",
    CASE
      WHEN E.DEPTNO = D.DEPTNO THEN D.DNAME
      END AS "DEPARTMENT NAME "
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
    ORDER BY E.DEPTNO;
--HERE WE USE MULTIPLE CASE EXPRESSION

SELECT D.DEPTNO ,D.DNAME , 
    CASE
        WHEN E.DEPTNO = D.DEPTNO  THEN D.DNAME 
        ELSE  'NO DEPTNO INFO'
    END AS "CASE DNAME"
    FROM EMP E RIGHT JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO ;
--USING RIGHT JOINS    
    
SELECT DEPTNO, JOB,
    CASE 
      WHEN DEPTNO = 10 THEN 'SALES'
      WHEN JOB = 'MANAGER' THEN 'ACCOUNTING'
      ELSE 'OTHERS'
      END
    FROM EMP
    ORDER BY DEPTNO;
--HERE ARG. WISE PRIORITY , 1ST DEPTNO, THEN JOB

SELECT DEPTNO, JOB,
    CASE
      WHEN DEPTNO =10 OR JOB = 'MANAGER' THEN 'ACCOUNTING'
      ELSE 'OTHERS'
      END
    FROM EMP
    ORDER BY DEPTNO;
--HERE OR OPERATOR WORK , IN BOTH ARG. IT GIVE 'ACCOUNT' AND REST ARE OTHERS

SELECT ENAME , DEPTNO, JOB,
    CASE
        WHEN DEPTNO =10 AND JOB = 'MANAGER' THEN 'ACCOUNTING'
        ELSE 'OTHERS'
    END
    FROM EMP
    ORDER BY DEPTNO;
--HERE AND OPERATOR WORK , WHERE DEPTNO 10, JOB MANAGER THEN DISPLAY "ACCOUNT", REST 'OTHERS'    .

SELECT SUM (CASE
          WHEN DEPTNO =10 THEN SAL
          END)
        FROM EMP
        ORDER BY DEPTNO;
--HERE SUM THE WHOLE DEPTNO 10 SAL

SELECT 
    SUM(CASE
          WHEN DEPTNO = 10 THEN SAL
        END) AS DEPTNO10SUM,
    SUM(CASE
          WHEN DEPTNO =20 THEN SAL 
        END) AS DEPTNO20SUM,
    SUM(CASE
          WHEN DEPTNO = 30 THEN SAL
        END) AS DEPTNO30SUM
      FROM EMP
      ORDER BY DEPTNO;
--HERE COLUMN WISE DISPLAY SUM SAL OF EVERY DEPTNO        

SELECT DEPTNO, JOB, 
    CASE 
        WHEN DEPTNO = 10 AND JOB IS NULL THEN (SELECT COUNT (*) FROM EMP WHERE DEPTNO = 10)
        WHEN DEPTNO = 20 AND JOB IS NULL THEN (SELECT COUNT(*) FROM EMP WHERE DEPTNO =20)
        WHEN DEPTNO = 30 AND JOB IS NULL THEN (SELECT COUNT(*) FROM EMP WHERE DEPTNO = 30)
    END AS CNT, SUM_SAL
    FROM 
    (SELECT DEPTNO, JOB, SUM(SAL) AS SUM_SAL FROM EMP 
        GROUP BY ROLLUP (DEPTNO, JOB));
        
SELECT DEPTNO, JOB, 
    CASE 
        WHEN DEPTNO = 10 AND JOB IS NULL THEN 'DEPT10 SUM SAL'
        WHEN DEPTNO = 20 AND JOB IS NULL THEN 'DEPT20 SUM SAL'
        WHEN DEPTNO = 30 AND JOB IS NULL THEN 'DEPT30 SUM SAL'
        ELSE JOB
    END AS COUNT , SL
    FROM 
    (SELECT DEPTNO, JOB, SUM(SAL) AS SL FROM EMP
        GROUP BY ROLLUP (DEPTNO, JOB));
        
SELECT DEPTNO, DECODE (JOB, NULL, 'DEPT WISE ', JOB), 
    CASE 
        WHEN DEPTNO = 10 AND JOB IS NULL THEN 'DEPT10 SUM SAL'
        WHEN DEPTNO = 20 AND JOB IS NULL THEN 'DEPT20 SUM SAL'
        WHEN DEPTNO = 30 AND JOB IS NULL THEN 'DEPT30 SUM SAL'
        ELSE JOB
    END AS COUNT , SL
    FROM 
    (SELECT DEPTNO, JOB, SUM(SAL) AS SL FROM EMP
        GROUP BY ROLLUP (DEPTNO, JOB));        
        
SELECT DEPTNO, 
    CASE 
        WHEN DEPTNO = 10 AND JOB IS NULL THEN TO_CHAR((SELECT COUNT(*) FROM EMP WHERE DEPTNO =10)) 
        WHEN DEPTNO = 20 AND JOB IS NULL THEN TO_CHAR((SELECT COUNT(*) FROM EMP WHERE DEPTNO = 20))
        WHEN DEPTNO = 30 AND JOB IS NULL THEN TO_CHAR (( SELECT COUNT(*) FROM EMP WHERE DEPTNO = 30))
        ELSE JOB
    END AS COUNT ,
    SUM(SAL)
    FROM EMP
    GROUP BY ROLLUP (DEPTNO, JOB);
--HERE WE GET JOB AND COUNT OF EMPLOYEE BOTH USING TO_CHAR FUNCTION

SELECT ENAME, SAL ,
    CASE 
        WHEN SAL >= 800 AND SAL <= 2000 THEN 'LOW PAY'
        WHEN SAL > 2000 AND SAL <= 4000 THEN 'MID PAY'
        WHEN SAL > 4000 THEN 'HIGH PAY'
    END AS "SAL SLAB"
    FROM  EMP
    ORDER BY SAL;
    
SELECT ENAME , SAL ,
    CASE 
        WHEN SAL >= 800 AND SAL <=2000 THEN 'LOW PAY'
        WHEN SAL > 2000 AND SAL <= 4000 THEN 'MID PAY'
        WHEN SAL > 4000 THEN 'HIGH PAY'
    END AS "SAL SLAB"
    FROM EMP
    WHERE
    CASE
        WHEN SAL >= 800 AND SAL <=2000 THEN 'LOW PAY'
        WHEN SAL > 2000 AND SAL <= 4000 THEN 'MID PAY'
        WHEN SAL > 4000  THEN 'HIGH PAY'
    END = 'MID PAY';
--HERE WE USED CASE IN WHERE CONDITION  AND FIND A PARTICULAR CASE .

SELECT ENAME , SAL,
    CASE 
        WHEN SAL >=800 AND SAL <= 2000 THEN 'LOW PAY'
        WHEN SAL > 2000 AND SAL <=4000 THEN 'MID PAY'
        WHEN SAL > 4000 THEN 'HIGH PAY'
    END AS SLAB
    FROM EMP
    ORDER BY SLAB;
--WE CAN ALSO ORDERING CASE
/

--OLAP FUNCTION / ANALYTICAL FUNCTION / WINDOWS FUNCTION
--======================================================
--OLAP FEATURES USES IN DATA WAREHOUSE AND DATA MARTS.
--OLAP OPERATIONS ARE PERFORMANCE ENHANCEMENT.
--THIS ARE ALSO KNOWN AS WINDOW FUNCTION.
--THIS CAN BE APPLIED IN SELECE STATEMENT.

--WORKING PRINCIPLE OF ANALYTICAL FUNCTION 
--=========================================
--IF QUERY PARTITIONS ARE AVAILABLE THEN, DIVIDE THE ROWS INTO PARTITIONS TO WHICH 
              --ANALYTICAL FUNCTION ARE APPLY.
--IF QUERY PARTITIONS IS OMITTED THEN WHOLE RESULT SET AS A SINGLE PARTITIONS.
--WHEN WE SPECIFY MULTIPLE ANALYTICAL FUNCTION THEN WITHOUT PARTITION THEN IT 
              --PRIORITY LAST ANALYTICAL FUNCTION.

--RANK ()
--========
--IT CALCULATES THE RANK OF VALUES IN SET OF VALUES.
--IT RETURNS RANK AS NO. LIKE 1,2,3,.......SO ON..
--THE RANK FUNCTION RETURNS THE SAME RANK FOR THE ROWS WITH SAME VALUES.
--IN CASE OF DUPLICATE , IT SKIP THE CONSECUTIVE NO. AND SHOW THE SEQUENTIAL GAP BETWEEN THE NO.S..
--PARTITION CLAUSE IS OPTIONAL IN RANK FUNCTION.
--BUT, ORDER BY CLAUSE ARE MANDATORY IN RANK FUNCTION.
--IT GENERATES GAPS.

SELECT DEPTNO, SAL, RANK ()
    OVER (PARTITION BY DEPTNO ORDER BY SAL) AS RNK
    FROM EMP;
--HERE OP RETURNS DEPTNO WISE ASC SAL WITH RANK ..

SELECT DEPTNO, SAL , RANK()
    (PARTITION BY DEPTNO ORDER BY SAL)
    FROM EMP;--ERROR    , missing window specification for this function
--WHEN WE USE RANK FUNCTION THEN MANDATORY TO TAKE OVER ..

SELECT DEPTNO, SAL , RANK ()
      OVER (ORDER BY SAL)
      FROM EMP;
--PARTITION IS NOT MANDATORY SO HERE ORDERING THE SAL WITH RANK 

SELECT DEPTNO, SAL , RANK ()
    OVER (PARTITION BY DEPTNO)
    FROM EMP;--ERROR,    missing ORDER BY expression in the window specification
--IN WINDOWS FUNCTION THERE ORDER BY CLAUSE IS MANDATORY.

SELECT DEPTNO, SAL, RANK ()
    OVER (ORDER BY SAL DESC)
    FROM EMP
    ORDER  BY SAL;
--HERE OP IS OVER THE RESULT IT ORDERING..

SELECT DEPTNO, SAL, RANK()
    OVER (ORDER BY SAL DESC)
    FROM EMP
    WHERE RANK() 
          OVER (ORDER BY SAL DESC) =2;--ERROR,  Window functions are allowed only in the SELECT list of a query.   
--WE CAN'T TAKE RANK FUNCTION IN WHERE CONDITION , THIS ONE ONLY USES IN SELECT STATEMENT.

SELECT * FROM(
    SELECT EMPNO, ENAME , DEPTNO, SAL, RANK () 
    OVER(ORDER BY SAL DESC) AS RNK
    FROM EMP)
    WHERE RNK = 2;
--HERE WE GET 2ND HIGH SAL USING RANK

SELECT * FROM (
    SELECT EMPNO, ENAME, DEPTNO, SAL, RANK ()
    OVER (ORDER BY SAL DESC) AS RNK
    FROM EMP)
    WHERE RNK = 3;
--HERE 3 NO RANK NOT FOUND , DUE TO CONSECUTIVE NO. IT WILL SKIP    

SELECT EMPNO, ENAME , JOB, DEPTNO, SAL, RANK ()
    OVER (PARTITION BY JOB , DEPTNO ORDER BY SAL DESC) AS RNK
    FROM EMP order by sal;
--HERE WE TAKE MULTIPLE COLUMN IN PARTITION.

SELECT E.* , RANK ()
    OVER (PARTITION BY EMPNO ORDER BY SAL) AS RANK
    FROM EMP E;
--HERE ALL EMP ARE UNIQUE SO ALL RANK ARE IS 1.

SELECT E.ENAME, D.DNAME , D.DEPTNO ,D.LOC, E.SAL, RANK ()
    OVER (PARTITION BY D.LOC ORDER BY SAL) FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;
--HERE WE GET THE OP USING JOINS

SELECT E.ENAME , E.SAL,D.DEPTNO, D.DNAME, D.LOC , RANK ()
    OVER (PARTITION BY D.DEPTNO ORDER BY SAL )
    FROM EMP  E RIGHT JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO;
--USING RIGHT JOIN

--DENSE_RANK ()
--==============
--IT IS A ANALYTICAL FUNCTION AND PROVIDE THE RANKING BASED UPON THE WINDOW CLAUSE.
--IF DUPICATE VALUE FIND IN RANKING THEN IT WILL NOT SKIP THE CONSECUTIVE NO.
--ORDER BY CLAUSE IS MANDATORY AND RANKING CAN BE ASC. OR DESC.
--BY USING DENSE_RANK WITH INLINE VIEW WE CAN GET THE EXACT Nth NO. OF POSITIONS.

SELECT E.*, DENSE_RANK ()
    OVER (PARTITION BY DEPTNO ORDER BY SAL)
    FROM EMP E;
--HERE WE GET THE RANK WITHOUT CONSECUTIVE NO. GAPS.

SELECT * FROM 
    (SELECT E.*, DENSE_RANK ()
        OVER (PARTITION BY DEPTNO ORDER BY SAL ) AS DRNK
        FROM EMP E)
    WHERE DRNK = 3;
--HERE WE GET ALL DEPTNO WISE 3RD LOWEST SAL BUT HERE NO GAP IN CONSECUTIVE NO.

SELECT * FROM 
    (SELECT E.*, DENSE_RANK ()
        OVER (PARTITION BY NULL ORDER BY SAL DESC) AS DRNK
      FROM EMP E)
    WHERE DRNK = 2;
--HERE WE GET 2ND HIGH SAL EMP WITHOUT CONSECUTIVE NO GAPS.
--HERE "PARTITION BY NULL" = NOT MENTION PARTITION BY IN WINDOWS FUNCTION

SELECT * FROM 
    (SELECT E.*, DENSE_RANK ()
        OVER (ORDER BY SAL DESC) AS DRNK
        FROM EMP E)
    WHERE DRNK <=3;
--HERE WE GET TOP 3 HIGH SAL EMP WITHOUT CONSECUTIVE NO GAP

--Q. DISPLAY THE 2nd HIGHEST SALARY INFORMATION WITH HIS LOCATION ?
SELECT * FROM 
    (SELECT E.ENAME, E.JOB, E.SAL , E.DEPTNO, D.LOC, DENSE_RANK()
    OVER (ORDER BY SAL DESC) AS DRNK
    FROM EMP E INNER JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO)
  WHERE DRNK =2;

--Q. WAQ TO DISPLAY TOP 5 HIGHEST SAL WITHOUT DUPLICATE SAL ?
SELECT UNIQUE (SAL) FROM 
    (SELECT SAL , DENSE_RANK()
    OVER (ORDER BY SAL DESC) AS DRNK
    FROM EMP)
  WHERE DRNK <=5;
/

--ROW_NUMBER
--============
--ASSIGN A UNIQUE SEQUENTIAL NO. FROM 1 TO N...
--IT PROVIDE UNIQUE SERIAL NO. EVEN DUPLICATE RECORD EXIST.
--THIS FUNCTION USED WITH OVER CLAUSE , PARTITION BY IS OPTIONAL BUT, ORDER BY IS MANDATORY.
--IT USES WHEN THERE IS A NEED TO BREAK DATASET INTO SECTIONS AND PROVIDE ROW_NUMBER CONSIDER EACH SEPARATE SET.

SELECT E.*, ROW_NUMBER ()
    OVER (ORDER BY SAL)
    FROM EMP E;
--SAME WORK LIKE AS ROWNUM .

SELECT E.*, ROW_NUMBER ()
    OVER (PARTITION BY DEPTNO ORDER BY SAL)
    FROM EMP E;
--HERE DEPTNO WISE WE GET ROW_NUMBER

SELECT * FROM 
    (SELECT E.*, ROW_NUMBER ()
    OVER (PARTITION BY DEPTNO ORDER BY SAL) AS RNM
    FROM EMP E)
    WHERE RNM = 2;
--HERE WE GET ALL DEPTNO WISE 2nd RECORD 

SELECT * FROM
    (SELECT E.* , ROW_NUMBER()
    OVER (ORDER BY SAL) AS RNM
    FROM EMP E)
    WHERE RNM =10;
--HERE WE FIND 10th NO. RECORD IN EMP TABLE .

SELECT * FROM
    (SELECT E.*, ROW_NUMBER()
    OVER (ORDER BY SAL) RNM 
    FROM EMP E )
    WHERE RNM >= 5;
--HERE WE FIND RECORD 5 TO LAST RECORD    

SELECT * FROM 
    (SELECT E.*, ROW_NUMBER()
    OVER (ORDER BY SAL) AS RNM
    FROM EMP E)
    WHERE RNM BETWEEN 4 AND 9;
--USE HERE BETWEEN OPERATOR

--Q.FIND THE DUPLICATE VALUE IN TABLE "DUPLICATE" ?
SELECT * FROM DUPLICATE;
SELECT * FROM (    
    SELECT D.*, ROW_NUMBER()
    OVER (PARTITION BY ID, NAME ORDER BY ID) RNM
    FROM DUPLICATE D)
    WHERE RNM >1;
--HERE WE FIND THE DUPLICATE VALUE IN TABLE 

SELECT * FROM 
    (SELECT E.*, ROW_NUMBER()
    OVER (ORDER BY SAL)
    FROM EMP E)
    ORDER BY ENAME;
--HERE ORDER BY CLAUSE WORK UPON RESULT

SELECT E.*, DENSE_RANK ()
    OVER (ORDER BY SAL DESC) AS DRNK,
    ROW_NUMBER ()
    OVER (ORDER BY SAL DESC ) AS RNUM,
    RANK ()
    OVER (ORDER BY SAL) AS RNK
    FROM EMP E;
--IF WE TAKE MULTIPLE ANALYTICAL FUNCTION WITHOUT PARTITION THEN IT PRIOR LAST ANALYTICAL FUNCTION.

--Q. WHO JOINED FIRST AMONG MANAGER (JOB) ?
SELECT * FROM (
SELECT E.*, DENSE_RANK()
    OVER (PARTITION BY JOB ORDER BY HIREDATE ) DRNK
    FROM EMP E) WHERE JOB = 'MANAGER' AND DRNK =1;
/

--LAG FUNCTION
--==============
--THE LAG FUNCTION IS USED TO ACCESS DATA FROM A PREVIOUS ROW.
--IT ACCEPT MAX. 3 ARGUMENTS BUT, 2nd AND 3rd ARGUMENT ARE OPTIONAL.
--1ST ARG. IS ACTUAL VALUE.
--2ND ARG. IS HOW MANY ROWS SKIP FROM TOP .
--3rd. ARG. IS WHAT VALUES WILL BE SHOW ON THIS SKIPPED VALUE 
--IF WE DON'T SPECIFY 2nd ARGUMENT THEN BY DEFAULT IT TAKES 1 .
--IF WE DON'T SPECIFY 3nd ARGUMENT THEN BY DEFAULT IT TAKES NULL .
--LAG FUNCTION ONLY GET THE DATA BASED UPON THE WINDOWS FUNCTION.

SELECT E.*, LAG(SAL,1)
    OVER (ORDER BY SAL)  
    FROM EMP E;
--HERE OP SHOW AFTER 1 ROW SKIPPED AND WE DON'T SPECIFY 3RD ARG. SO 3RD ARG. IS NULL

SELECT E.*, LAG(SAL, 3, 143)
    OVER (ORDER BY SAL)
    FROM EMP E;
--HERE OP SHOW AFTER 3 ROW SKIPPED AND 3RD ARG, WILL BE SHOW ON THIS SKIPPED VALUES.

SELECT E.*, 
    LAG (SAL, 1,0) 
    OVER (ORDER BY SAL) AS PREVIOUS_SAL ,
    SAL - LAG (SAL, 1,0) OVER (ORDER BY SAL) AS DIFFERENCE_SAL
    FROM EMP E;
--HERE WE DISPLAY BOTH PREVIOUS SAL AND DIFFERENCE SAL USING LAG.

SELECT E.*, 
    LAG(SAL, 1) OVER (ORDER BY SAL) AS PRIVS_SAL,
    SAL- LAG(SAL, 1,0) OVER (ORDER BY SAL) AS DIFF_SAL
    FROM EMP E;
--HERE ONLY PRIVS_SAL SKIPPED VALUES ARE CHNGE IF WE COMPARE TO TOP QUERY.

SELECT E.*, 
    LAG(SAL, 2) OVER (ORDER BY SAL) AS PRIVS_SAL,
    SAL - LAG(SAL,2) OVER (ORDER BY SAL) AS DIFF_SAL
    FROM EMP E;
--HERE PRIVS_SAL DISPLAY AFTER 2 ROW SKIPPED VALUE .
--HERE DIFF_SAL DISPLAY DIFFERENCE SAL BETWEEN 2 SKIP VALUE RESULT  .

SELECT ENAME , DEPTNO, SAL, LAG(SAL,1)
    OVER (PARTITION BY DEPTNO ORDER BY SAL)
    FROM EMP E;
--HERE WE PARTITION WISE DISPLAY PRIVS_SAL.

SELECT ENAME, DEPTNO, SAL,
    LAG(SAL, 1) OVER (PARTITION BY DEPTNO ORDER BY SAL) AS PRIVS_SAL,
    SAL - LAG(SAL,1) OVER (PARTITION BY DEPTNO ORDER BY SAL) AS DIFF_SAL
    FROM EMP;
--HERE WE GET DIFF_SAL IN DEPTNO PARTITION WISE

--Q. CURRENT SALARY AND PREVIOUS SALARY DIFFERENCE ?
SELECT E.*, 
     LAG(SAL) OVER (ORDER BY SAL) AS PRIVS_SAL,
    SAL - LAG(SAL) OVER (ORDER BY SAL) AS DIFF_SAL
    FROM EMP E;
/

--LEAD FUNCTION
--==============
--THE LEAD FUNCTION IS USED TO ACCESS DATA FROM A NEXT ROW.
--IT ACCEPT MAX. 3 ARGUMENTS BUT, 2nd AND 3rd ARGUMENT ARE OPTIONAL.
--1ST ARG. IS ACTUAL VALUE.
--2ND ARG. IS HOW MANY ROWS SKIP FROM BOTTOM .
--3rd. ARG. IS WHAT VALUES WILL BE SHOW ON THIS SKIPPED VALUE 
--IF WE DON'T SPECIFY 2nd ARGUMENT THEN BY DEFAULT IT TAKES 1 .
--IF WE DON'T SPECIFY 3nd ARGUMENT THEN BY DEFAULT IT TAKES NULL .
--LEAD FUNCTION ONLY GET THE DATA BASED UPON THE WINDOWS FUNCTION.

SELECT ENAME, JOB, SAL,
    LEAD (SAL) OVER (ORDER BY SAL) AS NEXTVALUE
    FROM EMP;
--USING LEAD WE FIND THE NEXTVALUE ON ROW BASICS.

SELECT ENAME , JOB, SAL ,
    LEAD (SAL) OVER (ORDER BY SAL) AS NEXTSAL,
    LEAD (SAL) OVER (ORDER BY SAL) - SAL AS DIFF
    FROM EMP;
--HERE WE GET DIFFERENCE VALUE BETWEEN NEXTSAL AND SAL

SELECT ENAME , JOB, DEPTNO,SAL,
    LEAD (SAL) OVER (PARTITION BY DEPTNO ORDER BY SAL) AS NETVAL,
    SAL - LAG(SAL) OVER ( PARTITION BY DEPTNO ORDER BY DEPTNO) AS DIFF
    FROM EMP; 
--HERE WE GET BOTH NEXT_VALUE AND DIFF_VALUE IN DEPTNO WISE.

SELECT ENAME, JOB, DEPTNO, SAL, 
    LEAD (SAL,1) OVER (PARTITION BY DEPTNO ORDER BY SAL)AS NEXTSAL,
    SAL - LAG(SAL) OVER(ORDER BY SAL) AS NEXTVAL
    FROM EMP;
--HERE WE SPECIFY BOTH LAG AND LEAD AND GET NEXTSAL AND DIFFSAL.

SELECT ENAME , HIREDATE ,
    LEAD (HIREDATE ) OVER (ORDER BY HIREDATE )
    FROM EMP;
--HERE WE GET HIREDATE WISE NEXT HIREDATE RECORD WISE.

SELECT ENAME, HIREDATE, 
    LEAD (HIREDATE) OVER (ORDER BY HIREDATE DESC) AS NEXT_HIREDATE
    FROM EMP;
--HERE WE GET NEXT_HIREDATE RECORD WISE IN DESC ORDER .

--Q. WAQ TO DISPLAY ENAME , SAL, NEXTSAL, NEXTSAL ENAME , DIFFERENCE SAL FROM EMP ?
SELECT ENAME , SAL, 
    LEAD (SAL) OVER (ORDER BY SAL) AS NEXTSAL, 
    LEAD (ENAME) OVER (ORDER BY SAL) AS NEXTSAL_ENAME ,
    LEAD (SAL) OVER (ORDER BY SAL) - SAL AS DIFF
    FROM EMP;

SELECT ENAME , HIREDATE ,
    LEAD (HIREDATE) OVER (ORDER BY HIREDATE),
    LEAD (ENAME) OVER (ORDER BY HIREDATE) AS NEXT_HIREDATE_ENAME
    FROM EMP;
--HERE WE GET NEXT HIREDATE  WITH NAME ALSO.

SELECT ENAME , HIREDATE , 
    LEAD(ENAME) OVER (ORDER BY HIREDATE DESC) ,
    LAG (ENAME) OVER (ORDER BY HIREDATE DESC)
    FROM EMP;
    
SELECT ENAME , JOB, HIREDATE ,
    LEAD(ENAME) OVER (ORDER BY HIREDATE)
    FROM EMP
    WHERE JOB = 'MANAGER';
--HERE FIND MANAGER LEAD WISE     

--Q. HOW MANY PERCENTAGE INCREASED OF PREVIOUS SALARY ?
SELECT ENAME, SAL,
    LAG(SAL) OVER (ORDER BY SAL) AS PRIVS,
    SAL - LAG(SAL) OVER (ORDER BY SAL) AS DIFF,
    ROUND((SAL- LAG(SAL) OVER (ORDER BY SAL)) / (LAG (SAL,1) OVER (ORDER BY SAL))*100,2) AS PERCENTAGE
    FROM EMP;

/
-- NTILE ()
--==========
-- IT DIVIDE THE TOTAL RECORD INTO THE GROUP OF RECORD BASED UPON THE PARAMETER PASSED.
SELECT EMPNO, ENAME, NTILE (2)
    OVER (ORDER BY EMPNO) GRP
    FROM EMP;
--HERE DIVIDE 2 (2 IS ARGUMENT )GROUP USING NTILE.

SELECT ENAME , NTILE (5)
    OVER (ORDER BY EMPNO) AS GRP
    FROM EMP;
--HERE DIVIDE 1ST 4 AT 3 EMPLOYEE AND LAST IS DIVIDED 2 EMPLOYEE.

SELECT * FROM (
SELECT ENAME , NTILE (2)
    OVER (ORDER BY EMPNO)AS  GRP 
    FROM EMP) WHERE GRP =1;
--HERE WE GET HALF RECORD OF EMP 

SELECT * FROM EMP WHERE NTILE (2)
    OVER (ORDER BY EMPNO) = 1;
--WINDOWS FUNCTION CAN'T TAKE IN WHERE CLAUSE ONLY IT WILL WORKS ON SELECT STATEMENT.

/
--OLAP FUNCTION WITH AGGREGATE FUNCTION 
--=======================================

--SUM()
--============
--IT DISPLAY DATA IN CUMULATIVE FORMAT (ADDING ROW BY ROW).
--ORDER BY CLAUSE NOT MANDATORY.
--WE HAVE TO SPECIFY PARTITION CLAUSE (OPTIONAL).

SELECT ENAME , SAL, SUM(SAL) 
    OVER (ORDER BY SAL) FROM EMP;
--HERE WE GET ORDERING WISE SUM OF SAL LIKE ... 800,1750,2850.........

SELECT ENAME , DEPTNO, SAL , SUM(SAL)
    OVER (PARTITION BY DEPTNO ) 
    FROM EMP;
--HERE DEPTNO WISE WE GET SUM SAL .    

SELECT ENAME , DEPTNO, SAL , SUM(SAL)
    OVER (PARTITION BY DEPTNO ORDER BY SAL) 
    FROM EMP;
--HERE WE GET DEPTNO WISE AND ORDERING OF SAL WITH SUM SAL.

SELECT E.*, SUM(SAL) 
    OVER () 
    FROM EMP E;
--HERE WE DON'T SPECIFY OVER CLAUSE THEN IT WILL SUM THE SAL DISPLAY ALONG THAT .

--COUNT(*)
--==============
--IT WILL DISPLAY THE RECORD COUNT BASED UPON ORDER BY AND OR PARTITION BY CLAUSE .
SELECT  distinct COUNT(*) OVER () FROM EMP;
--HERE COUNT ALL THE RECORD.

SELECT ENAME , DEPTNO, SAL,COUNT(*)
    OVER (ORDER BY SAL) FROM EMP;
--HERE ORDERING THE SAL, IF ANY DUPLICATE THEN THIS  VALUE ARE SAME ORDERING VALUE AFTER CONTINUE SO ON...

SELECT ENAME, DEPTNO, SAL , COUNT(*)
    OVER (PARTITION BY DEPTNO)
    FROM EMP;
--HERE COUNT EACH DEPTNO WISE RECORD .

SELECT ENAME , DEPTNO, SAL , COUNT(*)
    OVER (PARTITION BY DEPTNO ORDER BY SAL)
    FROM EMP;

SELECT AVG(SAL) OVER (PARTITION BY DEPTNO) FROM EMP;

SELECT * FROM EMP WHERE SAL IN (
SELECT MAX(SAL) OVER (PASRTITION  BY DEPTNO) FROM EMP);

SELECT * FROM EMP WHERE SAL IN (
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);    

/
--SYNONYM
--===========
--
--SYNONYM IS A DATABASE OBJECT, WHICH ACTS AS AN ALTERNATE NAME FOR AN EXISTING DATABASE OBJECT.
--BY USING A SYNONYM, WE CAN AVOID THE ENTRY OF THE SCHEMA NAME, WHEN REFERENCING UPON OBJECTS 
--        THAT BELONG TO ANOTHER SCHEMA.
--WE CAN SHORT THE LARGE OBJECT NAME USING SYNONYM.
/

--IT IS CREATED FOR
--===================
--TABLE , VIEW, MATERIALIZED VIEW, SEQUENCE, PROCEDURE, FUNCTION, PACKAGES ETC...
--IT IS USED FOR HIDING THE INFORMATION AS :    * USER_NAME .
--                                              * OBJECT_NAME .                                                
--                                              * DATABASE LINK FOR SECURITY PURPOSE.
--TO CREATE A SYNONYM PRIVILIGES IS MUST REQUIRE.
--USING USER_SYNONYM, ALL_SYNONYM WE GET THE DETAILS OF ALL SYNONYM.
--SYNONYM ARE DIVIDED INTO 2 PARTS.     1. PRIVATE SYNONYM.
--                                      2. PUBLIC SYNONYM.
--WE CAN ALSO DML OPEARTION ON SYNONYM.
--IF WE DO ANY DML OPEARTION THROUGH SYNONYM THEN UNTIL COMMIT IT WILL DOESN'T AFFECT TO THE BASE TABLE .
--WE CAN ALSO CREATE A SYNONYM WITHOUT A BASE TABLE.
--WHEN WE CREATE A SYNONYM THEN BASE TABLE'S ALL CONSTRAINT, INDEX ETC... WILL BE COPIED TO SYNONYM.
--SYNTAX :
--===========
CREATE OR REPLACE [PUBLIC]--IF HERE WE DONT PROVIDE PUBLIC THEN IT BY DEFAULT TAKE PRIVATE SYNONYM
    SYNONYM <SYNONYM_NAME> 
    FOR <SCHEMA_NAME>. <OBJECT_NAME> @ [DATABASE LINK];

--1. PRIVATE SYNONYM
--=====================
--IT IS CREATED BY USER.
--USED BY SPECIFIC USERS WHICH HAVE PERMISSION.
CREATE OR REPLACE SYNONYM NEMP_SYN 
    FOR NIELEMP;--ERROR
--PERMISSION REQUIRE FROM DBA.

GRANT CREATE SYNONYM TO SCOTT;--  <NIEL DBA > 

CREATE OR REPLACE SYNONYM NEMP_SYN 
    FOR NIELEMP;
    
SELECT * FROM SCOTT.NEMP_SYN;--ERROR < DEV >
--PRIVILEGES REQUIRE FROM DBA .    

GRANT SELECT  ON SCOTT. NEMP_SYN TO DEV;--< NIEL DBA> .

SELECT * FROM SCOTT.NEMP_SYN;--< DEV >

INSERT INTO SCOTT.NEMP_SYN (EMPNO, DEPTNO)VALUES (1234, 40);--ERROR < DEV>
--PRIVILEGE REQUIRE 

GRANT INSERT ON SCOTT.NEMP_SYN TO DEV;  --< NIEL DBA>

INSERT INTO SCOTT.NEMP_SYN (EMPNO, DEPTNO)VALUES (1234, 40);  --< DEV >
--WE CAN DO DML OPERATION USING SYNONYM.

SELECT * FROM PREM;
--TABLE DOESN'T EXIST.
CREATE SYNONYM PREM_SY FOR PREM;
--BUT WE CAN CREATE A SYNONYM WITHOUT A BASE TABLE 
SELECT * FROM PREM_SY;
--DOESN'T FIND
CREATE TABLE PREM (ID INT);
INSERT INTO PREM VALUES (1);
COMMIT;

SELECT * FROM PREM_SY;
--NOW SYNONYM WILL WORK 
SELECT * FROM USER_SYNONYMS;
--DICTIONARY TABLE 
SELECT * FROM ALL_SYNONYMS;
--DICTIONARY TABLE 

SELECT * FROM PREM_SY;  --< DEV>
--VALUES ARE DISPLAY
DROP TABLE PREM;   --< SCOTT>

SELECT * FROM PREM_SY;--ERROR   <DEV>
--IT WILL DOESN'T FIND 

SELECT SEQ14.NEXTVAL FROM DUAL;
CREATE SYNONYM SEQ_SY FOR SEQ14;  --< SCOTT>
SELECT SEQ_SY.NEXTVAL FROM DUAL;
GRANT SELECT  ON SCOTT.SEQ_SY TO DEV;   --< NIEL DBA>
SELECT SCOTT.SEQ_SY.NEXTVAL FROM DUAL;    --< DEV>

--2. PUBLIC SYNONYM
--====================
--IT IS CREATED BY USER.
--USED BY ALL USERS WHICH HAVE PERMISSION
--SYNTAX
--============
CREATE OR REPLACE PUBLIC SYNONYM < SYNONYM_NAME >
    FOR <OBJECT_NAME >;

CREATE PUBLIC SYNONYM NDEPT_SY FOR NIELDEPT;--ERROR   --<SCOTT>
--PERMSSION REQUIRED FROM DBA.

GRANT CREATE PUBLIC SYNONYM TO SCOTT;   --NIELDBA

CREATE PUBLIC SYNONYM NDEPT_SY FOR NIELDEPT;    --SCOTT
SELECT * FROM NDEPT_SY;   --SCOTT

SELECT * FROM NDEPT_SY;--ERROR    --< DEV >
--PERMISSION REQUIRED FROM DBA

GRANT SELECT ON NDEPT_SY TO PUBLIC;   --<NIEL DBA>

SELECT * FROM NDEPT_SY;   --<DEV, PROD, UAT, TEST......>
/
--DICTIONARY TABLES OF SYNONYM
--===============================
SELECT * FROM USER_SYNONYMS;    --<SCOTT>
SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = 'SYNONYM';   --<SCOTT>
SELECT * FROM DBA_OBJECTS WHERE OBJECT_TYPE = 'SYNONYM' ORDER BY CREATED DESC;
SELECT * FROM ALL_OBJECTS WHERE OBJECT_TYPE = 'SYNONYM' ORDER BY CREATED DESC;

/
--CHECK THE REFERENCED DICTIONARY TABLE 
--=======================================
SELECT * FROM USER_DEPENDENCIES;
SELECT * FROM USER_DEPENDENCIES  WHERE REFERENCED_NAME = 'EMP';
SELECT * FROM USER_DEPENDENCIES  WHERE TYPE = 'SYNONYM';

/
--DROPPING A SYNONYM
--======================
--IF WE DROP THE TABLE THEN THE SYNONYM OF THE TABLE BECOME AS A INVALID.

--SYNTAX
--=======
DROP SYNONYM <SYNONYM_NAME>;    --PRIVATE
DROP PUBLIC SYNONYM <SYNONYM_NAME>;     --PUBLIC.

/
--INTERVIEW QUESTION FROM SYNONYM
--==================================
--WE CAN CREATE N NO. OF SYNONYM ON A SINGLE TABLE .
--WHEN WE DO DML OPERATION ON SYNONYM THEN IT WILL DIRECTLY IMPACT ON TABLE . (AUTO - SYN..)
--IF BASE TABLE STRUCTURE CHANGED THEN SYNONYM STRUCTURE AUTOMATIC CHANGED.
--BUT, WE CAN'T CHANGE THE STRUCTURE OF A SYNONYM.
--SYNONYM WILL HOLD THE CONSTRAINTS, INDEX ETC... FROM A BASE TABLE , MEAN IT DEPENDENT OBJECT.

/
--DML OPERATION (DATA MANIPULATION LANGUAGE)
--============================================
--DML IS A PART OF SQL SUB LANGUAGES.
--BY USING DML WE CAN PERFORM INSERT , DELETE , UPDATE IN TABLE.
--WHEN WE PERFORM DML WE DO TRANSACTION IN DATABASE.

/
--UPDATE STATEMENT 
--===================
--BY USING UPDATE STATEMENT WE CAN UPDATE DATA IN A TABLE MEAN EXISTING VALUE WILL CHANGE TO NEW VALUE. 
--WE CAN MODIFY SINGLE COLUMN AND MULTIPLE COLUMN IN A TABLE AT A TIME. 
--SET COLUMN DATA TYPE SHOULD BE SAME.
--FOR UPDATE PRIVILIGES SHOULD BE AVAILABLE.

--SYNTAX
--=============
UPDATE <TABLE_NAME> SET <COLUMN_NAME > = <VALUE>
--FOR SINGLE COLUMN.
UPDATE <TABLE_NAME> SET <COL1> = <VALUE1>, <COL2> = <VALUE2>
--FOR MULTIPLE COLUMN.
/

UPDATE NIELEMP SET SAL = 50000;
--HERE WE DON'T SPECIFY THE WHERE CLAUSE SO IT WILL UPDATE THE ALL RECORDS.

UPDATE NIELEMP SET SAL = (SELECT MAX(SAL) FROM EMP) WHERE ENAME = 'KING';
--WE ALSO UPDATE USING AGGREGATE FUNCTION
--AND HERE ONLY UPDATE KING SALARY.

UPDATE NIELEMP SET SAL = 50000 WHERE ENAME = 'KING';
--HERE ONLY UPDATE THE KING SAL.

UPDATE NIELEMP SET SAL = (SELECT MAX(SAL) FROM EMP) WHERE ENAME = 'SMITH';
--HERE WE USING AGGREAGATE WITH WHERE CLAUSE.
--UPDATE THE SMITH SALARY TO MAX(SAL)

UPDATE NIELEMP SET SAL = 50000 WHERE DEPTNO IN (10,20);
--HERE  WHICH ARE UNDER DEPTNO 10 AND 20 UPDATE SAL 50000.

UPDATE NIELEMP SET SAL = 50000 , COMM = 1550 WHERE ENAME = 'KING';
--HERE WE MULTIPLE COLUMN UPDATE WHERE ENAME = KING.

UPDATE NIELEMP SET SAL = 50000, COMM = 5000 WHERE EMPNO = 7839;
--HERE WE UPDATE THROUGH EMPNO.

UPDATE NIELEMP SET SAL = 1000000, COMM  = 5 WHERE EMPNO = 4444;
--HERE 0 ROW UPDATE .
--COZ, THIS EMPNO NOT FOUND SO....

UPDATE EMP SET COMM = 500 WHERE SAL =
      (SELECT MAX(SAL) FROM EMP);
--HERE WE UPDATE THE COMM WHO IS GETTING MAX SAL IN EMP.

--Q.UPDATE COMM 300 WHO ARE UNDER GRADE 4 ?
UPDATE EMP SET COMM = 3000 WHERE SAL IN 
      (SELECT E.SAL FROM EMP E INNER JOIN SALGRADE S 
      ON E.SAL BETWEEN S.LOSAL AND S.HISAL
      WHERE S.GRADE = 4);

UPDATE EMP SET JOB = 
      (SELECT JOB FROM EMP WHERE EMPNO = 7788) WHERE ENAME = 'KING';
--HERE WE UPDATE THE JOB OF KING WHICH JOB OF EMPNO =7788

UPDATE EMP SET JOB = 
      (SELECT JOB FROM EMP WHERE EMPNO = 7788) ,
      SAL = (SELECT SAL FROM EMP WHERE EMPNO = 7499) ,
      COMM = (SELECT MAX(COMM) FROM EMP) WHERE ENAME IN ('KING', 'SMITH');
--HERE WE UPDATE 2 EMPLOYEE JOB , SAL, COMM.

UPDATE EMP SET (JOB, DEPTNO) = (SELECT JOB , DEPTNO FROM EMP WHERE  ENAME = 'KING');
--HERE WE UPDATE MULTIPLE COLUMN .
--ALL RECORD WILL BE UPDATED WHICH JOB, DEPTNO OF KING.

UPDATE EMP SET(JOB, DEPTNO) = (SELECT JOB , DEPTNO FROM EMP WHERE ENAME = 'KING') WHERE DEPTNO = 10;
--HERE UPDATE DEPTNO 10 JOB, DEPTNO WHICH ARE IN KING'S RECORD.

UPDATE EMP SET (JOB, SAL, COMM )= 
    (SELECT (SELECT JOB FROM EMP WHERE EMPNO = 7788) AS JOB,
            (SELECT SAL FROM EMP WHERE EMPNO = 7499) AS SAL,
            (SELECT MAX(COMM) FROM EMP) AS COMM FROM DUAL)
      WHERE ENAME = 'KING';
--HERE WE ALSO UPDATE MULTIPLE COLUMN AT A TIME.

UPDATE DUPLICATE SET NAME = 'NIEL' WHERE ROWNUM = 1;
--USING ROWNUM WE CAN ALSO UPDATE .

UPDATE EMP SET DEPTNO = 
        (SELECT DISTINCT DEPTNO FROM EMP WHERE JOB = 'SALESMAN') 
        WHERE JOB = 'PRESIDENT';
--HERE PRESIDENT DEPTNO UPDATED TO SALESMAN DEPTNO MEAN 10 TO 30 UPDATE.

UPDATE EMP SET JOB = DEFAULT WHERE ENAME = 'SMITH';
--HERE SMITH JOB IS UPDATE TO DEFAULT VALUE
--IN JOB COLUMN THERE IS NO DEFAULT COLUMN SO THERE AUTOMATIC UPDATE TO NULL.

SELECT * FROM USER_DEPENDENCIES WHERE REFERENCED_NAME ='EMP';
--DEPENDECIES DICTIONARY TABLE .

CREATE TABLE DELL2 (ID NUMBER, NAME VARCHAR2(10));
INSERT INTO DELL2 VALUES (1,'NIEL');
COMMIT;
CREATE VIEW DELL2_VW AS SELECT * FROM DELL2;
SELECT * FROM DELL2_VW;
UPDATE DELL2_VW SET NAME = 'NITIN' ;
--WE CAN ALSO UPDATE THROUGH VIEW WITH ANOTHER TABLES DATA .

--Q. UPDATE IN GENDER TABLE WHERE M THEN F AND WHERE F THEN M ?
UPDATE GENDER SET GENDER = DECODE (GENDER , 'M','F', 'M'); 
--OR
UPDATE GENDER SET GENDER = CASE GENDER WHEN 'M' THEN 'F'
                                        WHEN 'F' THEN 'M' END ;
                                        
--Q. UPDATE KING SALARY TO 1500 AND SMITH SALARY TO 5000 ?                                        
UPDATE EMP SET SAL = CASE WHEN ENAME = 'KING' THEN 1500
    WHEN ENAME = 'SMITH' THEN  5000 ELSE SAL END ;
--OR    
UPDATE EMP SET SAL = DECODE (SAL, (SELECT SAL FROM EMP WHERE ENAME = 'KING'), 1500,
                                    (SELECT SAL FROM EMP WHERE ENAME = 'SMITH'), 5000, SAL);

--Q. UPDATE KING'S COMM TO 9TH HIGHEST SAL ?
UPDATE EMP SET COMM = 
        (SELECT  SAL FROM (SELECT SAL, DENSE_RANK () OVER (ORDER BY SAL)AS DR FROM EMP)
            WHERE DR = 9) WHERE ENAME = 'KING';    

UPDATE NIELEMP SET SAL = (SELECT MAX(SAL) FROM NIELEMP ),
    COMM = (SELECT MIN(COMM) FROM NIELEMP WHERE COMM >(SELECT MIN(COMM) FROM NIELEMP)) 
    WHERE ENAME IN ( 'SMITH','SCOTT') ;
--HERE WE UPDATE SMITH AND SCOTT SAL TO MAX(SAL) FROM EMP AND COMM UPDATE TO 2ND MIN COMM.    

--Q. UPDATE KING SAL 1500, SMITH SAL 50000, SCOTT COMM 15000?
UPDATE EMP SET SAL = CASE ENAME WHEN  'KING' THEN 1500 
    WHEN  'SMITH' THEN 50000 ELSE SAL END ,
     COMM = CASE ENAME WHEN 'SCOTT' THEN 15000 ELSE COMM END;

--Q. UPDATE WHO ARE JOINED BEFORE TURNER 
--      * UPDATE SAL WHERE COMM IS NULL THEN 500
--      * UPDATE SAL WHERE COMM IS NOT NULL THEN 278
--      * WHERE JOB IS ANALYST THEN DISPLAY SALESMAN
--      * WHERE JOB IS SALESMAN THEN DISPLAY ANALYST ?
UPDATE EMP SET SAL = NVL2(COMM,278,500),
        JOB = CASE JOB WHEN  'ANALYST' THEN 'SALESMAN'
                      WHEN 'SALESMAN' THEN 'ANALYST' ELSE JOB END WHERE HIREDATE < 
                    (SELECT HIREDATE FROM EMP WHERE ENAME = 'TURNER')  ;
--OR
UPDATE EMP SET SAL = CASE WHEN COMM IS NULL THEN 500
        WHEN COMM IS NOT NULL THEN 278 END ,
        JOB = CASE WHEN JOB = 'ANALYST' THEN 'SALESMAN'
                    WHEN JOB = 'SALESMAN' THEN 'ANALYST' ELSE JOB END WHERE HIREDATE < 
                    (SELECT HIREDATE FROM EMP WHERE ENAME = 'TURNER')  ;

UPDATE NIELEMP SET ENAME = LOWER(ENAME);
--FUNCTION WILL BE UPDATE HERE .

UPDATE NIELEMP SET ENAME = SUBSTR(ENAME, 1,3);
--THROUGH SUBSTR WE ALSO UPDATE .

/
--DELETE STATEMENT (DML)
--========================
--IT IS A DML COMMAND.
--WE CAN REMOVE A SPECIFIC RECORD BY USING DELETE.
--IT REMOVES ALL THE RECORDS AT A TIME OR AS PER OUR REQUIREMENT.
--IT CAN BE ROLLBACK BECAUSE IT STORES A COPY OF TABLE IN ROLLBACK SEGMENT AREA SO WE CAN ROLLBACK.
--IT IS SLOWER.
--WE CAN USE WHERE CLAUSE.
--TO DELETE ANY RECORD FROM A TABLE THEN PRIVILEGE IS MUST REQUIRED.
--IN DELETE STATEMENT FROM CLAUSE IS OPTIONAL.
--SYNTAX
--=======
--              {DELETE ALL RECORD}
--              ====================
--DELETE FROM  < TABLE_NAME > ;
--OR
--DELETE < TABLE_NAME >;

--                 {DELETE SOME SPECIFIC RECORD }
--DELETE FROM < TABLE_NAME > WHERE < ..... >
--OR
--DELETE < TABLE_NAME > WHERE < ...... >;

DELETE EMP;
--HERE WE DON'T SPECIFY ANY CONDITION THE IT WILL DELETED THE WHOLE RECORD.

DELETE EMP WHERE DEPTNO IN (10,20);
--HERE WE SPECIFY SOME CONDITION THEN IT WILL DELETED THE RECORD ON CONDITION BASIC.

DELETE EMP WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'CHICAGO');
--HERE WE DELETE THE RECORD USING SUB - QUERY.

--Q.DELETE THE DUPLICATE RECORD IN DUPLICATE TABLE ?
DELETE FROM DUPLICATE WHERE ROWID IN 
      (SELECT ROWID FROM (
          SELECT D.*, ROW_NUMBER() OVER(PARTITION BY ID, NAME ORDER BY ID , NAME) AS RNM , ROWID 
          FROM DUPLICATE D)
       WHERE RNM > 1); 

--Q. DELETE THE RECORD WHERE SAL = 3000 ?
DELETE EMP WHERE SAL = 3000;

--Q. DELETE THE RECORD WHO ARE WORKING IN SALES DEPARTMENT ?
DELETE EMP WHERE DEPTNO IN 
    (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');

--Q. DELETE THE RECORD WHO GETTING HIGH SAL ?    
DELETE EMP WHERE SAL = (SELECT MAX(SAL) FROM EMP); 

--Q.DELETE THE RECORD WHO ARE JOINED THURSDAY ?
DELETE  EMP WHERE TRIM(TO_CHAR (HIREDATE, 'DAY')) = 'THURSDAY'; 

--Q.DELETE IN EMP WHO ARE UNDER GRADE 4 ?
DELETE EMP WHERE SAL IN 
    (SELECT E.SAL FROM EMP E INNER JOIN SALGRADE S
        ON E.SAL BETWEEN S.LOSAL AND S.HISAL
        WHERE S.GRADE = 4);

--Q. DELETE IN GENDER TABLE WHERE  GENDER = M ?
DELETE GENDER WHERE GENDER = 'M';

--Q. DELETE THE RECORD WHO GETTING 9TH HIGHEST SAL   IN EMP?
DELETE EMP WHERE SAL IN  
    (SELECT SAL FROM 
    (SELECT SAL, DENSE_RANK () OVER (ORDER BY SAL DESC) AS DR FROM EMP) WHERE DR =9);
    
--Q. DELETE THE RECORD OF EMP WHO ARE JOINING BEFORE TURNER ?
DELETE EMP WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'TURNER');

DELETE DELL2_VW WHERE 1=1;
--WE CAN DELETE USING VIEW ALSO .
--HERE WHERE CONDITION MATCH SO IT DELETE THE WHOLE RECORD .

DELETE EMP WHERE ENAME = 'KING' OR JOB = 'SALESMAN' OR SAL = 3000;
--HERE WE DELETE MULTIPLE COLUMN DATA AT A TIME .

/
--RETURNING CLAUSE
--==================
--RETURNING CLAUSE IS KEYWORD WHERE WE CAN HOLD VALUE AT RUN TIME.
--TO USE THE RETURN KEYWORD IN A QUERY WE MUST HAVE TO TAKE SOME BIND VARIABLE LIKE ( :A, :B).
--USING BIND VARIABLE WE CAN STORE A SINGLE VALUE AT A TIME.
--WE CAN TAKE 'N' NO. OF BIND VARIABLE .
--THE VARIABLE STORES DATA ONLY FOR TEMPORARY BASES.

/
--VARIABLE
--=========
--WHO HOLD SINGLE VALUE AND TEMPORARY.

/
--SYNTAX
--==========
--VARIABLE < VARIABLE_NAME > DATATYPE ;

--IN UPADATE
--=============
SQL> VARIABLE A NUMBER;
SQL> UPDATE EMP SET SAL =
  2             SAL + SAL*0.5 WHERE DEPTNO = 10 RETURNING SUM(SAL) INTO :A;

3 rows updated.

SQL> PRINT :A;

         A
----------
     13125

SQL> --HERE 1ST GET THE VALUE OF SAL+SAL*0.5 THEN WHAT ARE O/P WILL BE RETURN IT WILL SUM THE ALL RETURNED VALUE.

/
SQL> VARIABLE A NUMBER ;
SQL> UPDATE EMP SET SAL = SAL * 0.5  WHERE DEPTNO = 10 RETURNING SUM(SAL) INTO :A;

3 rows updated.

SQL> PRINT :A;

         A
----------
      4375

SQL> --HERE 1ST GET THE VALUE OF SAL * 0.5 THEN WHAT ARE O/P WILL BE RETURN IT WILL SUM THE ALL RETURNED VALUE.

/

SQL> VARIABLE BSAL NUMBER;
SQL> VARIABLE BNAME VARCHAR2(10);

SQL> UPDATE EMP SET SAL = SAL+1000 WHERE ENAME = 'KING' RETURNING ENAME,SAL INTO :BNAME, :BSAL;

1 row updated.

SQL> PRINT :BSAL :BNAME;

      BSAL
----------
      6000


BNAME
--------------------------------
KING

SQL> --HERE 1ST GET THE VALUE OF SAL+100 THEN WHAT ARE O/P WILL BE RETURN IT WILL ENAME, SAL OF RETURNED VALUE.
--
/
SQL> VARIABLE A NUMBER;
SQL> VARIABLE B VARCHAR2(10);

SQL> UPDATE EMP SET SAL = SAL+SAL*0.25 WHERE ENAME = 'KING' RETURNING ENAME, SAL INTO :B, :A;

1 row updated.

SQL> PRINT :A, :B;

SQL> PRINT :A :B;

         A
----------
      6250


B
--------------------------------
KING

      
--DELETE STATEMENT IN RETURNING CLAUSE VARIABLE 
--===============================================
SQL> VARIABLE SALARY NUMBER;
SQL> DELETE EMP WHERE DEPTNO = 10 RETURNING SUM(SAL) INTO :SALARY;

3 rows deleted.

SQL> PRINT :SALARY;

    SALARY
----------
      8750
--HERE WE GET WHICH ROW ARE DELETED THE SUM(SAL) OF THOSE RECORD .
/

SQL> VARIABLE A NUMBER;
SQL> DELETE FROM EMP WHERE DEPTNO =10 AND HIREDATE < SYSDATE RETURNING MIN(SAL) INTO :A;

3 rows deleted.

SQL> PRINT :A;

         A
----------
      1300
--HERE WE GET MIN SAL OF DELETED ROWS WHO ARE IN DEPTNO =10 AND THEIR HIREDATE < SYSDATE ;

SQL> ROLLBACK;

Rollback complete.

SQL> VARIABLE A NUMBER;
SQL> DELETE FROM EMP WHERE  HIREDATE < SYSDATE RETURNING MIN(SAL) INTO :A;

14 rows deleted.

SQL> PRINT :A;

         A
----------
       800
--HERE WE GET MIN SAL OF WHICH VALUE ARE DELETED .

/
--DML MERGE STATEMENT
--=====================
--USING MERGE STATEMENT WE CAN AVOID TO WRITE MULTIPLE DML STATEMENT.
--IT CAN PERFORM DML , BASED UPON SOURCE TABLE MATCHING VALUE AND NON-MATCHING VALUE.

--WHERE WE CAN PERFORM MERGE STATEMENT :
--=======================================
--POSSIBLE 
MATCHED WITH UPDATE
MATCHED WITH UPDATE , DELETE 
MATCHED WITH UPDATE , DELETE AND NOT MATCHED WITH INSERT, BUT INSERT STATEMENT WILL WORK WHEN WE EXEXCUTE 2 TIMES.
NOT MATCHED WITH INSERT 

--NOT POSIBBLE
MATCHED WITH DELETE 
MATCHED WITH INSERT
NOT MATCHED WITH UPDATE 
NOT MATCHED WITH DELETE 
NOT MATCHED WITH UPDATE , DELETE 

SELECT * FROM SOURCE;
SELECT * FROM DESTINATION ;

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN MATCHED THEN 
    UPDATE SET D.DESCRIPTION = 'ORACLE' ;
--HERE WE CAN UPDATE THE VALUES . 

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN NOT  MATCHED THEN 
    UPDATE SET D.DESCRIPTION = 'ORACLE' ;--ERROR
--MISSING KEYWORD.    
--UPDATE STATEMENT CAN'T TAKE IN NOT MATCHED CONDITION.

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN MATCHED THEN 
    DELETE WHERE D.STATUS = 20;--ERROR
--MISSING KEYWORD

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN NOT MATCHED THEN
    DELETE WHERE D.STATUS =20;--ERROR
--MISSING KEYWORD

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN MATCHED THEN
    INSERT VALUES (S.ID, S.STATUS, S.DESCRIPTION);--ERROR
--MISSING KEYWORD    
    select * from source;
MERGE INTO SOURCE S
    USING DESTINATION D
    ON (D.ID = S.ID)
    WHEN NOT MATCHED THEN 
    INSERT VALUES (D.ID, D.STATUS, D.DESCRIPTION);
--HERE INSERT UPTO BOTH TABLE RECORD ARE NOT SAME , WHEN BOTH TABLE RECORD WILL BE SAME THEN INSERTED STOPPED.

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN MATCHED THEN 
    UPDATE SET D.DESCRIPTION = 'NIEL'
    DELETE WHERE D.STATUS = 20;
--HERE BOTH ARE WORKED.

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN NOT MATCHED THEN
    UPDATE SET DESCRIPTION = 'NIEL'
    DELETE WHERE  D.STATUS =20;--ERROR
--MISSING KEYWORD

MERGE INTO DESTINATION D
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN MATCHED THEN 
    UPDATE SET DESCRIPTION = 'NEELAKANTHA SAHU'
    DELETE WHERE D.STATUS = 20
    WHEN NOT MATCHED THEN
    INSERT VALUES (100,200,'NITIN');
--IT WILL WORKED BUT, FOR INSERT WE EXECUTE THIS QUERY 2 TIMES.
    
MERGE INTO DESTINATION D 
    USING SOURCE S
    ON (D.ID = S.ID)
    WHEN MATCHED  THEN
    UPDATE SET DESCRIPTION = 'NIEL'
    WHEN NOT MATCHED 
    THEN INSERT VALUES (10,100, 'NITIN');
--HERE ONLY MATCHING ID WILL BE UPDATE BUT NOTINSERT ANY DATA .
--WORKED BUT DOESN'T INSERT VALUES, COZ THOSE TABLE ROWS ALEREAY ADDED THERE IS NO EXTRA ADD USING MERGE STATEMNT.

MERGE INTO SOURCE S 
    USING DESTINATION D
    ON (D.ID = S.ID)
    WHEN MATCHED  THEN
    UPDATE SET DESCRIPTION = 'NIEL'
    WHEN NOT MATCHED 
    THEN INSERT VALUES (10,100, 'NITIN');
--BUT IN THIS CASE WE INSERT N NO OF DATA .

SELECT * FROM EXAMTIMETABLE1;
SELECT * FROM EXAMTIMETABLE2;

MERGE INTO EXAMTIMETABLE1 E1
    USING EXAMTIMETABLE2 E2
    ON (E2.EXAMNAME = E1.EXAMNAME)
    WHEN MATCHED THEN 
    UPDATE SET EXAMTIME = 'CANCEL'
    WHEN NOT MATCHED THEN
    INSERT VALUES (E2.EXAMNAME , E2.EXAMTIME); 
--HERE WE SEE BOTH UPDATE AND INSERT A ROW.    

MERGE INTO EXAMTIMETABLE1 E1
    USING EXAMTIMETABLE2 E2
    ON (E2.EXAMNAME = E1.EXAMNAME)
    WHEN MATCHED THEN 
    UPDATE SET EXAMTIME = 'CANCEL'
    WHEN NOT MATCHED THEN
    INSERT VALUES ('PHYSICAL SC', 'CANCEL'); 
--HERE WE ALSO UPDATE AND INSERT A NEW RECORD.

/
--MULTIPLE INSERT STATEMENT
--===========================
--WE CAN INSERT RECORDS MULTIPLE TABLES SIMENTENOUSLY (AT A TIME) , USING INSERT ONLY.
--THE TARGET TABLE AND SOURCE TABLE DATATYPE SHOULD MATCH EACH OTHER. 
--NO. OF COLUMN SHOULD MATCH BETWEEN SOURCE AND TARGET TABLE.
--WE CAN INSERT DATA IN MULTIPLE TABLE BASED BASED UPON THE CONDITION.

CREATE TABLE D11 AS SELECT * FROM DEPT WHERE 1=2;
CREATE TABLE D12 AS SELECT * FROM DEPT WHERE 1=2;
CREATE TABLE D13 AS SELECT * FROM DEPT WHERE 1=2;
--IF WHERE CONDITION IS FALSE THEN THIS TIME ONLY CREATE STRUCTURE OF SOURCE TABLE .

SELECT * FROM D11;
SELECT * FROM D12;
SELECT * FROM D13;
--ABOVE 3 TABLE ONLY CREATE STRUCTURE FROM SOURCE TABLE.

INSERT INTO D11 SELECT * FROM DEPT;
--HERE WE INSERT ALL VALUES OF DEPT TABLE .

INSERT INTO D11 (DEPTNO, DNAME)
    SELECT DEPTNO, DNAME FROM DEPT;
--HERE WE INSERT ONLY 2 COLUMN USING SOURCE TABLE .

INSERT INTO D11 (DEPTNO, DNAME ) 
    SELECT SUBSTR (EMPNO, 1,2), ENAME FROM EMP;
--TARGET TABLE AND SOURCE TABLE DATATYPE SHOULD MATCH EACH OTHER AND LENGTH ALSO.

INSERT ALL INTO D11
            INTO D12
            INTO D13
      SELECT * FROM DEPT  ; 
--HERE WE INSERT AT A TIME 3 TABLE DATA USING INSERT ALL COMMAND 

INSERT ALL INTO D11 (DEPTNO)
            INTO D12 (DEPTNO)
            INTO D13 (DEPTNO)
        SELECT DEPTNO FROM DEPT;
--HERE WE ONLY INSERT THE DEPTNO OF ALL TABLE USING PARTICULAR NAME .

ALTER TABLE D11 ADD PRIMARY KEY (DEPTNO);
--ADD PRIAMARY KEY HERE ON DEPTNO.

INSERT ALL INTO D11 (DNAME)
            INTO D12 (DNAME)
            INTO D13 (DNAME)
        SELECT DNAME FROM DEPT;--ERROR
--PRIMARY KEY DOESN'T HOLD NULL VALUE SO HERE DOESN'T INSERT VALUE IN ABOVE 3 TABLE .

CREATE TABLE SUPPLIER AS SELECT * FROM DEPT WHERE 1=2;
CREATE TABLE CUSTOMERS AS SELECT * FROM DEPT WHERE 1=2;

SELECT * FROM SUPPLIER;
SELECT * FROM CUSTOMERS;

ALTER TABLE SUPPLIER ADD ADDRESS VARCHAR2(10);
--ADD NEW A COLUMN IN EXISTING TABLE .

INSERT ALL INTO SUPPLIER (DEPTNO, DNAME)
            INTO CUSTOMERS (DEPTNO, DNAME)
            SELECT 26, 'BERHAMPUR' FROM DUAL;
--USING DUAL WE CAN INSERT MULTIPLE DATA AT A TIME.

INSERT ALL INTO SUPPLIER VALUES(10,'BERHAMPUR','ODISHA' )
            INTO CUSTOMERS VALUES (20, 'CHATRAPUR')
            SELECT * FROM DUAL;
--HERE ALSO WE CAN INSERT DATA USING DUAL ALSO.

CREATE TABLE EMPDEPT AS
    SELECT E.*, D.DEPTNO AS DDEPTNO , D.LOC, D.DNAME FROM EMP E INNER JOIN DEPT D
            ON E.DEPTNO = D.DEPTNO WHERE 1=2;
--USING JOINS WE CAN CREATE A NEW STRUCTURE .

SELECT * FROM EMPDEPT;            
--HERE ONLY STRUCTURE CAN DISPLAY.

INSERT INTO EMPDEPT  
        SELECT E.*, D.DEPTNO, D.LOC, D.DNAME FROM EMP E INNER JOIN DEPT D
              ON E.DEPTNO = D.DEPTNO;
--USING JOINS WE INSERT DATA AT A TIME.

SELECT * FROM EMPDEPT;

INSERT ALL 
            WHEN DEPTNO < 20 THEN INTO D11 VALUES (DEPTNO, DNAME , LOC)
            WHEN DEPTNO BETWEEN 20 AND 30 THEN INTO D12 VALUES (DEPTNO, DNAME , LOC)
            ELSE INTO D13 (DEPTNO, LOC) VALUES (DEPTNO, LOC)
        SELECT * FROM DEPT;
--HERE WE INSERT MULTIPLE TABLE USING OPERATOR .

/
--USING SUBSTITUDE VARIABLE INSERT STATEMENT 
--============================================
INSERT INTO D11 VALUES ('&DEPTNO', '&DNAME', '&LOC');
--WE CAN USE SUBSTITUDE FOR INSERT STATEMNT.
--USING SUBSTITUDE WE HAVE DON'T WRITE MULTIPLE INSERT STATEMENT , JUST EXECUTE AND INSERT THE VALUES .

INSERT ALL 
          INTO D11 VALUES ('&DEPTNO', '&DNAME', '&LOC')
          INTO D12 VALUES ('&DEPTNO', '&DNAME', '&LOC')
          SELECT * FROM DEPT;
--USING SUBSTITUDE WE CAN INSERT MULTIPLE TABLE  ALSO .

INSERT ALL INTO D11 (DEPTNO, DNAME) VALUES ('&A', '&B')
            INTO D12 (DNAME , LOC) VALUES ('&A','&B')
            INTO D13 (LOC) VALUES ('&A')
        SELECT * FROM DUAL;
--USING SUBSTITUDE WE CAN INSERT INDIVIDUAL COLUMN ALSO.        
/

CREATE TABLE C (ID NUMBER);
INSERT INTO C  VALUES (1);
INSERT INTO C  VALUES (2);
INSERT INTO C  VALUES (3);

CREATE TABLE T1 AS SELECT * FROM C WHERE 1=2;
CREATE TABLE T2 AS SELECT * FROM C WHERE 1=2;
CREATE TABLE T3 AS SELECT * FROM C WHERE 1=2;

INSERT ALL INTO T1 VALUES (ID)
            INTO T2 VALUES (ID)
            INTO T3 VALUES (ID)
        SELECT * FROM C;

SELECT * FROM T3;       
--HERE WE USING C TABLE WE INSERT AT A TIME IN T1, T2, T3.
        
/
--Q.CREATE 3 TABLE (E10, E20, E30) AND DEPTNO WISE INSERT  ALL ENAME , DEPTNO ?
CREATE TABLE E10 AS SELECT ENAME , DEPTNO FROM EMP WHERE 1=6;
CREATE TABLE E20 AS SELECT * ENAME , DEPTNO FROM EMP WHERE 1=6;
CREATE TABLE E30 AS SELECT * ENAME , DEPTNO FROM EMP WHERE 1=6;

INSERT ALL WHEN DEPTNO =10 THEN INTO E10 VALUES (ENAME , DEPTNO)
            WHEN DEPTNO = 20 THEN INTO E20 VALUES (ENAME , DEPTNO)
            ELSE INTO E30 VALUES (ENAME , DEPTNO)
            SELECT DEPTNO , ENAME FROM EMP;
        
SELECT * FROM E10;
SELECT * FROM E20;
SELECT * FROM E30;
--HERE WE DIVIDE ALL ENAME WITH THEIR DEPTNO WISE AT A TIME .  

/
--TCL (TRANSACTION CONTROL LANGUAGE)
--====================================
--A TRANSACTION IS A LOGICAL UNIT OF WORK
--ANY CHANGES (DML, DDL) IN DATABASE IS CALLED TRANSACTION.
--TRANSCATION CHANGES CAN BE MADE PERMANENT TO A DATABASE ONLY , IF THEY ARE COMMITED .

--TRANSACTION COMPLETE WHEN FOLLOWING SPECIFICATION OCCUR :
--=========================================================
--A COMMIT OR ROLLBACK ISSUED.
--A DDL COMMAND ISSUED.(AUTO COMMIT)
--A DCL COMMAND ISSUED(AUTO COMMIT)
--THE USER EXIT THE SQL PLUS.(AUTO ROLLBACK)
--FAILURE OF MACHINE OR SYSTEM CRASHES (AUTO ROLLBACK)

--1.COMMIT :
--===========
--IT IS A TCL COMMAND.
--COMMIT COMMAND IS USED TO SAVE DATA PERMANENTLY AFTER ANY MODIFICATION.
--IF WE FIRE THE COMMIT COMMAND THEN THE ENTIRE PENDING TRANSACTION WILL BE COMPLETE .

SELECT * FROM A ;
INSERT INTO A VALUES (5);
INSERT INTO A VALUES (6);
--NOW THIS VALUES ARE STORED IN BUFFER NOT IN DATABASE 

COMMIT;
--NOW THOSE BUFFER VALUES WILL BE STORED AS A PERMANENT IN DATABASE .

/
--2.ROLLBACK / ROLL :
--====================
--IT IS A TCL COMMAND.
--ROLLBACK COMMAND IS USED TO CANCEL THE TRANSACTION WHICH ARE NOT SAVED.
--IF WE FIRE THE ROLLBACK COMMAND THEN THE ENTIRE PENDING TRANSACTION WILL NOT SAVE/CANCEL PERMANENTLY.
--WE CAN SAY ROLLBACK IS A UNDO OPERATION IN DATABASE AND THIS OPERATION ONLY WORK UNTILL WE COMMIT TRANSACTION.
--WHEN WE FEEL DML OPERATION CHANGES ARE NOT ACCURATE THEN ROLLBACK WORKS.
--BUT IF WE SPECIFY ROLL AFTER DML OPERATION THEN THIS TIME SAVEPOINT WILL NOT WORK.

INSERT INTO A VALUES (99);
--NOW THIS VALUES ARE STORED IN BUFFER NOT IN DATABASE 

SELECT * FROM A;
--HERE LATEST VALUE WILL BE DISPLAY .

ROLLBACK;
--AFTER ROLLBACK THIS LATEST DATA WILL BE PERMANENTLY REMOVED FROM BUFFER / OBJECT.

INSERT INTO A VALUES (100);

SELECT * FROM A;

ROLL
--HERE ALSO THIS LATEST DATA WILL BE PERMANENTLY REMOVED FROM BUFFER / TABLES.
SELECT * FROM A;

/
--3.SAVEPOINT :
--=============
--IT IS A TCL COMMAND.
--IT MARKS A SAVE POINT WITHIN THE CURRENT TRANSACTION.
--SAVE POINT ARE USED TO IDENTIFY A POINT IN THE TRANSACTION TO WHICH YOU CAN ROLLBACK RATHER THAN CANCEL 
--                                                                                THE COMPLETE TRANSACTION.
--SAVE POINT NAME SHOULD BE CHARACTER. 
--IF THE SAVE POINT NAME IS SAME THEN IT CONSIDER ONLY THE LATEST SAVE POINT.
--THERE IS NO LIMIT FOR SAVEPOINT.
--AFTER COMMIT / DDL / DCL COMMAND ALL SAVEPOINT WILL BE ERASED.
--IF SAVEPOINT NAME IS SEQUENCE ORDER THEN IT WILL BETTER FOR IDENTIFY TO US , BUT THIS IS NOT MANDATORY.

INSERT INTO AA VALUES (4);
INSERT INTO AA VALUES (5);

SAVEPOINT S1;

INSERT INTO AA VALUES (6);
INSERT INTO AA VALUES (7);

SAVEPOINT S2;

INSERT INTO AA VALUES (8);

SELECT * FROM AA;
--HERE WE SEE THE ALL INSERT DATA

ROLLBACK TO S2;

SELECT * FROM AA;
--HERE WE SEE UPTO SAVEPOINT S2 WILL BE STORED IN BUFFER 
--AFTER SAVEPOINT S2 ALL DML DATA WILL BE REMOVED PERMANENTLY.

ROLLBACK TO S1;

SELECT * FROM AA;

INSERT(1) 
INSERT(2) 
SAVEPOINT S1(3)    --SAVEPOINT
DELETE(4) 
SAVEPOINT(5)
SELECT(6) 
SAVEPOINT S2(7)    --SAVEPOINT
INSERT(8)

ROLLBACK TO S2;   --UPTO LINE NO 7 ALL ARE IN BUFFER AFTER LINE NO. 7 ALL DML WILL BE REMOVED PERMANENTLY
ROLLBACK TO S1;   --UPTO LINE NO 3 ALL ARE IN BUFFER AFTER LINE NO. 3 ALL DML WILL BE REMOVED PERMANENTLY.
--HERE WE SEE UPTO SAVEPOINT S1 WILL BE STORED IN BUFFER 
--AFTER SAVEPOINT S1 ALL DML DATA WILL BE REMOVED PERMANENTLY.

/
--WHEN DML OPERATION WILL BE STORED AS BUFFER / PERMANENTLY :
--=============================================================
INSERT 
INSERT 
DDL   --AUTO COMMIT
INSERT 
COMMIT      --COMMIT
INSERT 
ROLLBACK    --REMOVE DATA FROM BUFFER

/
INSERT 
INSERT 
ROLLBACK    --REMOVE DATA FROM BUFFER
INSERT 
INSERT 
COMMIT    --COMMIT

/
INSERT 
UPDATE 
COMMIT    --COMMIT

/
INSERT 
ALTER   --DDL , AUTO COMMIT

/
INSERT 
DELETE 
DROP    --DDL, AUTO COMMIT

/
SELECT 
INSERT
SELECT 
DELETE
SELECT 
COMMIT    --DDL, AUTO COMMIT

/
--DDL (DATA DEFINATION LANGUAGE)
--==============================
--DDL IS A PART OF SUB-LANGUAGE.
--WHEN WE PERFORM CREATION, MODIFICATION, STRUCTURE CHANGE OF ANY OBJECT IS KNOWN AS DDL.
--"CREATE , MODIFY, ALTER, DROP, UNUSED, FLASHBACK, RENAME, COMMENT, TRUNCATE" THIS ARE PART OF DDL.
--AFTER DDL STATEMENT WE CAN'T ROLLBACK , COZ DDL IS A AUTO COMMIT STATEMENT.

--ADDING A NEW COLUMN IN A EXISTING TABLE 
--=========================================
ALTER TABLE < TABLE_NAME> ADD < COLUMN_NAME > < DATATYPE (SIZE)>;

--GUIDELINE FOR ADD A NEW COLUMN IN EXISTING TABLE
--=================================================
--WE CAN'T SPECIFY THE LOCATION OF NEW COLUMN, IT BY DEFAULT LAST COLUMN IN TABLE .
--IF WE SPECIFY THE LOCATION THEN WE NEED TO RECREATE IT.
--IF IN A TABLE CONTAINS RECORDS , BEFORE THE COLUMN IS ADDED , THEN WHEN WE ADD NEW COLUMN THEN IT 
--                                                                              CONTAINS NULL VALUES.

--WHEN WE ADD A NEW COLUMN IN BASE TABLE THEN WHAT ARE THE EFFECT ON DEPENDENCIES OBJECT :
--=========================================================================================
--VIEW : THE NEW COLUMN DOESN'T DISPLAY.
--MATERIALIZED VIEW : THE NEW COLUMN DOESN'T DISPLAY.
--SYNONYM : IT DISPLAY THE NEW COLUMN COZ, IT IS AUTO SYNC.

/
CREATE TABLE TEST_DDL (ID NUMBER, NAME VARCHAR2(10));
INSERT INTO TEST_DDL VALUES (&A, '&B');
COMMIT;

SELECT * FROM TEST_DDL;

ALTER TABLE TEST_DDL ADD MOBILE_NO NUMBER;
--HERE ADD THE NEW COLUMN BUT ON THIS TABLE HAVE ALREADY DATA SHOW THIS NEW COLUMN SHOW NULL.
--THIS COLUMN WILL SPECIFY AT LAST OF TABLE .

SELECT * FROM TEST_DDL;

INSERT INTO TEST_DDL VALUES (&A, '&B','&C');
--HERE WE ADD THE COLUMN VALUES IN 3 COLUMN
COMMIT;

SELECT * FROM TEST_DDL;


CREATE TABLE TEST_DDL_BKP_25AUG2022 AS SELECT * FROM TEST_DDL;
--HERE WE CREATE A BACKUP TABLLE USING BASE TABLE .

DROP TABLE TEST_DDL;

CREATE TABLE TEST_DDL (MOBILE_NO NUMBER, ID NUMBER, NAME VARCHAR2(10));
--HERE OUR ORDERING WISE WE CREATE A TABLE .

INSERT INTO TEST_DDL SELECT MOBILE_NO , ID, NAME FROM TEST_DDL_BKP_25AUG2022;
COMMIT;
--HERE WE ORDER WISE INSERT VALUES FROM BACKUP TABLE .

SELECT * FROM TEST_DDL;

ALTER TABLE TEST_DDL ADD (ADDR1 VARCHAR2(10), ADDR2 VARCHAR2(10));
--HERE WE ADD AT A TIME MULTIPLE COLUMN .
--WHEN WE ADD MULTIPLE COLUMN THEN THIS TIME COLUMN NAME ARE MUST BE INSIDE OF (  ).

SELECT * FROM TEST_DDL;

ALTER TABLE TEST_DDL ADD(ADDR3 VARCHAR2(10), ADDR4 VARCHAR2(10), UNIQUE(ADDR3, ADDR4));
--HERE WE ADD MULTIPLE COLUMN AND COMPOSITE CONSTRAINT AT A TIME .

ALTER TABLE TEST_DDL ADD (ADDR5 VARCHAR2(10) UNIQUE, ADDR6 VARCHAR2(10) DEFAULT 'BERHAMPUR');
--HERE WE CAN ALSO ADD MULTIPLE COLUMN AND INDIVIDUALLY CONSTRAINT ON TABLE.

SELECT * FROM TEST_DDL;

/

--WHEN WE ADD A NEW COLUMN IN BASE TABLE THEN WHAT ARE THE EFFECT ON DEPENDENCIES OBJECT :
--=========================================================================================
SELECT * FROM USER_DEPENDENCIES WHERE REFERENCED_NAME = 'NIELEMP';

ALTER TABLE NIELEMP ADD ADDRESS VARCHAR2(10);
--HERE WE ADD A NEW COLUMN IN NIELEMP BASE TABLE ,NOW CHECK WHAT IMPACT ON DEPENDENCIES...

SELECT * FROM NIELEMP_VW;--VIEW
--IN VIEW THE EXTRA ADD COLUMN WILL BE NOT DISPLAY.

EXEC DBMS_MVIEW.REFRESH ('GMEET');
SELECT * FROM GMEET;--MATERIALIZED VIEW
--IN MATERIALIZED VIEW THIS NEW COLUMN DOESN'T DISPLAY.

SELECT * FROM NEMP_SYN;--SYNONYM
--BUT IN CASE OF SYNONYM IT WILL DISPLAY THE NEW COLUMN COZ, THIS ONE IS AUTO - SYNC.

/
--MODIFTING A COLUMN :
--=====================
--A COLUMN DATATYPE , SIZE, DEFAULT VALUES CAN BE CHANGED USING MODIFY.
--A CHANGE TO THE DEFAULT VALUE AFFECT ONLY SUBSEQUENT INSERTION TO THE TABLE .

--GUIDELINES TO MODIFY A COLUMN :
--================================
--WE CAN CHANGE THE WIDTH, PRECISION OF A NUMERIC COLUMN.
--WE CAN DECREASE THE WIDTH OF A COLUMN IF THE COLUMN CONTAIN NULL VALUES AND IF THE TABLE HAVE NO ROWS.
--WE CAN CHANGE THE DATATYPE IF THE COLUMN CONTAIN NULL VALUES .
--WE CAN CONVERT A CHAR DATATYPE TO VARCHAR DATATYPE AND VARCHAR2 TO CHAR EVEN DATA IN EXIST.

--WHEN WE MODIFY A COLUMN
--=========================
--IF A COLUMN STORES NULL VALUES THEN WE CHANGE ANY DATATYPE .
--IF A NUMBER COLUMN HAVE VALUES THEN WE DON'T CHANGE THE DATATYPE TO ANOTHER,THIS CASE ONLY WE INCREASE THE SIZE.
--IF A COLUMN DATE DATATYPE WITH VALUE THEN WE CAN CHANGE TO TIMESTAMP AND SAME AS VICE-VERSA.
--IF A COLUMN CHAR DATATYPE WITH VALUE THEN WE CAN CHANGE TO VARCHAR2 AND SAME AS VICE-VERSA.

--SYNTAX :
--=========
--FOR SINGLE COLUMN :
--=====================
--ALTER TABLE < TABLE_NAME > MODIFY < COLUMN_NAME > <DATATYPE SIZE>;    
--FOR MULTIPLE COLUMN :
--=====================
--ALTER TABLE < TABLE_NAME > MODIFY  ( < COLUMN1 > <DATATYPE SIZE> , <COLUMN2> <DATATYPE SIZE>) 
--WHEN WE TAKE MULTIPLE COLUMN THEN THIS TIME THOSE COLUMN ARE MANDATORY TO UNDER  (  ).

/

ALTER TABLE TEST_DDL MODIFY NAME VARCHAR(4);
--HERE WE REDUCE THE SIZE OF NAME COLUMN.

DESC TEST_DDL;

ALTER TABLE TEST_DDL MODIFY NAME VARCHAR(2);--ERROR
--WE CAN'T DECREASE THE DATA SIZE COZ ALWAYS MODIFY DATA SIZE IS >= TO LAST SIZE IF THERE IS EXIST RECORD.

ALTER TABLE TEST_DDL MODIFY ADDR1 NUMBER (4,2);
--HERE WE CHANGE THE DATATYPE VARCHAR2 TO NUMBER 
--THIS THING ONLY HAPPEN IF THERE IS NO RECORD AVAILABLE.
SELECT * FROM TEST_DDL;

DESC TEST_DDL;

ALTER TABLE TEST_DDL MODIFY ADDR1 DEFAULT 40.2;
--HERE WE SET DEFAULT VALUE IS 40.2.

INSERT INTO TEST_DDL(MOBILE_NO, ID, NAME, ADDR2) VALUES 
            (7788, 10, 'NIEL', 'ASKA'  );
--HERE BY DEFAULT ADDR1 VALUES STORED AS 40.2    

SELECT * FROM TEST_DDL;          

ALTER TABLE TEST_DDL MODIFY ADDR1 VARCHAR2(10);--ERROR
--IF A NUMBER COLUMN HAVE DATA THEN WE CAN'T CHANGE THE DATATYPE OF THIS COLUMN.

ALTER TABLE TEST_DDL MODIFY ADDR1 NUMBER (15,5);
--ONLY WE CAN INCREASE THE SIZE BUT DON'T DECREASE.

ALTER TABLE TEST_DDL ADD GENDER VARCHAR2(20);
--ADD A COLUMN

INSERT INTO TEST_DDL (GENDER)VALUES ('M');

COMMIT;

ALTER TABLE TEST_DDL MODIFY GENDER CHAR;
--DATATYPE CHANGED FROM VARCHAR2 TO CHAR EVEN RECORD EXIST.
--THIS ONE ONLY SUPPORT ONLY CHAR TO VARCHAR AND VARCHAR2 TO CHAR.

ALTER TABLE TEST_DDL ADD (JOIN DATE, TIMING TIMESTAMP);
--2 COLUMN ADD.

INSERT INTO TEST_DDL (JOIN) VALUES (&A);
--SYSDATE INSERT .

ALTER TABLE TEST_DDL MODIFY JOIN TIMESTAMP;

SELECT * FROM TEST_DDL;

DESC TEST_DDL;

ALTER TABLE TEST_DDL MODIFY (NAME VARCHAR2(10), ADDR2 VARCHAR2(20));
--HERE WE MODIFY 2 COLUMN AT A TIME .
--BUT IN MULTIPLE COLUMN MODIFY MUST REQUIRE ().


DESC TEST_DDL;
SELECT * FROM TEST_DDL;
INSERT INTO TEST_DDL (JOIN) VALUES ('29-AUG-22');

ALTER TABLE TEST_DDL MODIFY JOIN TIMESTAMP;
--HERE THIS DATE ARE CONVERTED TO TIMESTAMP AND TIME WILL BE DISPLY BY DEFAULT TIME 12 AM.

/
--RENAME A COLUMN :
--===================
--WE CAN MODIFY THE OLD COLUMN_NAME TO NEW COLUMN_NAME USING RENAME .

--AFTER RENAME COLUMN NAME WHAT EFFECT ON DEPENDENCIES OBJECTS AND WHERE WE APPLY OR NOT  :
--==========================================================================================
--AFTER RENAME COLUMN FROM BASE TABLE THEN VIEW HAS ERROR.
--AFTER RENAME COLUMN IN BASETABLE THIS MATERIALIZED VIEW IS DEPENDENCIES REMOVED .
--AFTER REFRESH IN MATERAILIZED VIEW THERE IS NO CAHNGES IN COLUMN NAME .
--NEW CHANGING COLUMN NAME DISPLAY IN SYNONYM.
--NO CHANGES IN CONSTRAINT.
--NO CHANGES IN INDEX.
--WE CAN RENAME CONSTRAINT NAME .
--WE CAN'T RENAME THE INDEX NAME .
--USING VIEW , MATERIALIZED VIEW , SYNONYM WE CAN'T RENAME THE COLUMN NAME .

--SYNTAX :
--========
--ALTER TABLE < TABLE_NAME > RENAME COLUMN < OLD_NAME > TO < NEW_NAME >;

SELECT * FROM TEST_DDL;

ALTER TABLE TEST_DDL RENAME COLUMN ID TO IDNO;
--HERE WE CHANGE A OLD COLUMN NAME TO NEW COLUMN NAME .

SELECT * FROM TEST_DDL;

ALTER TABLE TEST_DDL RENAME COLUMN NAME TO ENAME , ADDR1 TO ADDRESS;--ERROR
--WE CAN'T CHANGE MORE THAN ONE COLUMN AT A TIME .

SELECT * FROM NIELEMP;

ALTER TABLE NIELEMP RENAME COLUMN JOB TO DESIGNATION;
--RENAME JOB TO DESIGNATION.

SELECT * FROM USER_DEPENDENCIES WHERE REFERENCED_NAME = 'NIELEMP';

SELECT * FROM NIELEMP_VW;--VIEW 
--AFTER CHANGES RENAME FROM BASE TABLE THEN VIEW HAS ERROR

SELECT * FROM GMEET;--MATERAILIZED VIEW

EXEC DBMS_MVIEW.REFRESH('GMEET');
--AFTER RENAME COLUMN IN BASETABLE THIS MATERIALIZED VIEW DEPENDENCIES ON BASE TABLE IS REMOVED .
--AFTER REFRESH IN MATERAILIZED VIEW THERE IS NO CAHNGES IN COLUMN NAME .

SELECT * FROM NEMP_SYN;
--NEW CHANGING COLUMN NAME DISPLAY IN SYNONYM.

ALTER TABLE NIELEMP RENAME COLUMN DEPTNO TO DEPARTMENT;

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'NIELEMP';
--AFTER CHANGING NAME OF A COLUMN THEN CONSTRAINT HOLDS THE COLUMN.
--NO CHANGES IN CONSTRAINT.

SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'NIELEMP';
--INDEX ALSO NO CHANGES AFTER CHNAGING A COLUMN NAME.

ALTER TABLE NIELEMP RENAME CONSTRAINT PK_EMP_NIEL TO NIELEMP_PK;
--WE CAN ALSO CHANGE THE CONSTRAINT NAME .

ALTER TABLE NIELEMP RENAME INDEX FUN TO NIELEMP_FUN;--ERROR
--WE CAN'T CHANGE A INDEX NAME .

ALTER TABLE VW_NIELEMP RENAME COLUMUN DESIGNATION TO JOB;
--USING VIEW WE CAN'T RENAME A COLUMN.

ALTER TABLE MV_NIELEMP RENAME COLUMN DESIGNATION TO JOB;
--USING MATERIALIZED VIEW WE CAN'T RENAME A COLUMN.

ALTER TABLE NEMP_SYN RENAME COLUMN DESIGNATION TO JOB;
--USING SYNONYM WE CAN'T RENAME A COLUMN .

/
--DROPPING A COLUMN 
--==================
--A COLUMN CAN BE DROPPED FROM A TABLE BY USING ALTER TABLE STATEMENT.
--THE DROP COLUMN COMMAND IS USED FOR THIS PURPOSE AND IT WAS ENABLED FROM ORACLE 8i ONWARDS.

--GUIDELINES FOR DROPPING A COLUMN :
--===================================
--THE COLUMN MAY OR MAY NOT CONTAIN DATA .
--ONLY ONE COLUMN WE CAN DROP AT A TIME USING COLUMN KEYWORD .
--WE CAN ALSO DROP MULTIPLE COLUMN AT A TIME WITHOUT USING COLUMN KEYWORD.
--THE TABLE MUST HAVE AT LEAST ONE COLUMN REMAINING IN AFTER IT IS ALTERED.
--ONCE A COLUMN IS DROPPED THEN WE CAN'T RECOVERY.

--WHAT ARE THE EFFECT AFTER DROPPING A COLUMN IN DEPENDENCIES OBJECTS :
--======================================================================
--WE CAN'T DROP A PARENT TABLE COLUMN  IF THEY HAVE RELATIONSHIP BETWEEN ANOTHER TABLE , FIRST DROP 
--                                                              THE CONSTRAINT THEN,WE DROP THE COLUMN.
--VIEW WILL BE DISPLAY ERROR.
--MATERIALIZED VIEW ARE DOESN'T REFRESH.
--SYNONYM WILL AUTO SYNC. WITH BASE TABLE.

--SYNTAX :
--=========
--FOR SINGLE COLUMN :
--=====================
--ALTER TABLE < TABLE_NAME > DROP COLUMN < COLUMN_NAME >;

--FOR MULTIPLE COLUMN :
--======================
--ALTER TABLE < TABLE_NAME > DROP ( <COL1, COL2, COL3,... > );

SELECT * FROM TEST_DDL;

ALTER TABLE TEST_DDL DROP COLUMN TIMING;
--HERE WE DROP A SINGLE COLUMN.

ALTER TABLE TEST_DDL DROP (GENDER , JOIN);
--HERE WE DROPPED 2 COLUMN AT A TIME .

CREATE TABLE TEST_DDL2 (ID INT PRIMARY KEY, SLNO INT REFERENCES TEST_DDL2(ID) );

INSERT INTO TEST_DDL2 VALUES (1,NULL);
INSERT INTO TEST_DDL2 VALUES (2,1);

COMMIT;

SELECT * FROM TEST_DDL2;

ALTER TABLE TEST_DDL2 DROP PRIMARY KEY CASCADE ;
--HERE WE DROP THE CONSTRAINT, COZ WITHOUT DROP PRIAMRY KEY CONSTRAINT WE CAN'T BREAK  THE RELATIONSHIP.

ALTER TABLE TEST_DDL2 DROP COLUMN ID;
--HERE WE DROP THE COLUMN.

SELECT * FROM SYS.USER_DEPENDENCIES WHERE REFERENCED_NAME = 'NIELEMP';

SELECT * FROM VW_NIELEMP;

ALTER TABLE NIELEMP DROP COLUMN ADDRESS;
--DROP THE COLUMN.

SELECT * FROM VW_NIELEMP;--ERROR    VIEW
--VIEW WILL BE DISPLAY ERROR.

SELECT * FROM MV_NEMP2;

ALTER TABLE NIELEMP DROP COLUMN ADDD;

EXEC DBMS_MVIEW.REFRESH ('MV_NEMP2');--ERROR    MVIEW
--REFRESH NOT WORK.

SELECT * FROM SY_NEMP;
--HERE DROPPED THIS COLUMN , COZ AUTO SYNC.

/
--SET UNUSED OPTION :
--=====================
--IN ORACLE 8i ACCESS TO DROP COLUMN FROM TABLE .
--IF WE DROP A TABLE THEN WE MAKE REBUILD IT.
--NOW WE CAN MARK A COLUMN AS UNUSED (LOGICAL DELETE ) OR DELETE IT COMPLETLY ( PHYSICAL DELETE).

--LOGICAL DELETE / UNUSED :
--===========================
--ON A LARGE TABLE PROCESS OF PHYSICAL DELETE OF A COLUMN IT TAKE MORE TIME AND RESOURCE CONSUMING.
--FOR THIS REASON WE MAY DECIDE TO LOGICALLY DELETE IT.


--NOTES FOR UNUSED OPTION :
--==========================
--AFTER A COLUMN HAS BEEN MARKED AS UNUSED , THEN WE CAN'T ACCESS OVER THIS COLUMN.
--WHICH COLUMN WE MARKED AS UNUSED , THOSE COLUMN WE CAN'T SEE IN DESCRIBE .
--WE CAN ADD TO SAME TABLE A NEW COLUMN WITH THE SAME NAME AS AN UNUSED COLUMN.

--WHAT EFFECT ON DEPENDENCIES OBJECTS AFTER UNUSED COLUMN IN BASE TABLE :
--========================================================================
--VIEW = ERROR 
--MATERIALIZED VIEW = CAN'T REFRESH.
--SYNONYM = AUTO SYNC. 
--CONSTRAINT = REMOVED 
--CONSTRAINT =IF ONE COLUMN IS PARENT AND RELATIONSHIP WITH ANOTHER TABLE CHILD COLUMN THEN DROP CONSTRAINT
--                                                                                      THEN UNUSED.
--CONSTRAINT = IF BOTH PARENT AND CHILD ARE IN SAME TABLE THEN AT A TIME WE UNUSED BOTH COLUMN AT A TIME , THERE 
--                                                                                  IS NO RESTRICTION.

--SYNTAX :
--==========
--ALTER TABLE < TABLE_NAME > SET UNUSED < ( COL1, COL2,.... ) >;

/
SELECT * FROM NIELEMP;
SELECT * FROM SYS.USER_DEPENDENCIES WHERE REFERENCED_NAME = 'NIELEMP';

ALTER TABLE NIELEMP SET UNUSED (DEPARTMENT);
--HERE WE ALTERED THE DEPARTMENT COLUMN.

SELECT * FROM NIELEMP;
--HIDE THIS COLUMN .

DESC NIELEMP;
--HERE ALSO HIDE THIS COLUMN.

SELECT * FROM VW_NIELEMP;--ERROR    VIEW
--VIEW SHOW ERROR

EXEC DBMS_MVIEW.REFRESH ('MV_NIELEMP');--ERROR    MATERIALIZED VIEW
--AFTER UNUSED COLUMN IN BASE TABLE  

SELECT * FROM SY_NEMP;
--HERE AUTO SYNC THIS COLUMN , HIDE THIS COLUMN

ALTER TABLE TEST_DDL SET UNUSED (ADDR1, ADDR2);
--WE CAN ALSO UNUSED MULTIPLE COLUMN AT A TIME .

SELECT * FROM TEST_DDL;
--HIDE THIS COLUMN.

CREATE INDEX BTREE_NAME_TEST_DDL ON TEST_DDL (NAME);

SELECT * FROM SYS.USER_INDEXES WHERE TABLE_NAME= 'TEST_DDL';
--HERE DISPLAY THE INDEX 

ALTER TABLE TEST_DDL SET UNUSED (NAME );
--HIDE THIS PARTICULAR COLUMN.

SELECT * FROM TEST_DDL;
--HIDE.

SELECT * FROM SYS.USER_INDEXES WHERE TABLE_NAME= 'TEST_DDL';
--HERE DEPENDENCIES INDEX WILL BE HIDE PERMANENTLY.

/
--DICTIONARY TABLE OF UNUSED COLUMN :
--====================================
SELECT * FROM USER_UNUSED_COL_TABS;
--HERE WE CHECK TABLE NAME OF UNUSED COLUMNS AND HOW MANY COLUMN ARE UNUSED.

--DROP A UNUSED COLUMN OPTION :
--==============================
--THIS OPTION REMOVES FROM TABLE ALL COLUMNS WHICH ARE MARKED AS UNUSED.
--THIS OPTION IS USED WHEN WE WANT TO RECLAIM THE EXTRA DISK SPACE FROM UNUSED COLUMNS IN THE TABLE .
--IF THE TABLE DOES'T CONTAIN UNUSED COLUMNS THE STATEMENT RETURN WITH NO ERROR.

--SYNTAX :
--==========
--ALTER TABLE < TABLE_NAME > DROP UNUSED COLUMN ;

ALTER TABLE TEST_DDL DROP UNUSED COLUMN;
--HERE WE DROP ALL UNUSED COLUMNS OF INDIVIDUAL TABLE .

SELECT * FROM USER_UNUSED_COL_TABS;
--HERE WE CHECK THE REST UNUSED COLUMNS..

/
--DROPPING A TABLE :
--===================
--IT REMOVES THE DEFINATION OF THE ORACLE TABLE .
--THIS COMMAND NOT ONLY DROPS THE TABLE BUT THE ENTIRE DATABASE IS LOST ALONG WITH THE ASSOCIATED INDEX,
--                                                                  CONSTRAINT, VIEW WILL BE INVALID.
--MATERIALIZED VIEW WILL NOT REFRESH.
--SYNONYM WILL BE INVALID .

--SYNTAX :
--==========
--DROP TABLE < TABLE_NAME > ;
--DROP TABLE < TABLE_NAME > { CASCADE CONSTRRAINT} --IN CASE OF PARENT TABLE.

CREATE TABLE TEST_DROP (ID INT PRIMARY KEY, SLNO INT REFERENCES TEST_DROP (ID));--PARENT TABLE .

INSERT INTO TEST_DROP VALUES (1,NULL);
INSERT INTO TEST_DROP VALUES (2,1);
INSERT INTO TEST_DROP VALUES (3,1);

COMMIT;

CREATE TABLE TEST_DROP2 (SLNO INT REFERENCES TEST_DROP(ID));--CHILD TABLE .

INSERT INTO TEST_DROP2 VALUES (1);
INSERT INTO TEST_DROP2 VALUES (NULL);
INSERT INTO TEST_DROP2 VALUES (2);

COMMIT;

SELECT * FROM TEST_DROP2;

CREATE VIEW VW_TEST_DROP AS SELECT * FROM TEST_DROP;

SELECT * FROM VW_TEST_DROP;

CREATE MATERIALIZED VIEW MV_TEST_DROP AS SELECT * FROM TEST_DROP;

SELECT * FROM MV_TEST_DROP;

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'TEST_DROP';
--UNIQUE INDEX WILL BY APPLY ON BY DEFAULT.

CREATE SYNONYM SY_TEST_DROP FOR TEST_DROP;

SELECT * FROM SY_TEST_DROP;

SELECT * FROM SYS.USER_DEPENDENCIES WHERE REFERENCED_NAME = 'TEST_DROP';
--HERE ALL WE CHECK DEPENDECIES OF A OBJECT..(VIEW, MATERIALIZED VIEW, SYNONYM)

DROP TABLE TEST_DROP;--ERROR
--THIS TABLE IS PARENT TABLE AND THIS TABLE RELATIONSHIP ANOTHER TABLE .

DROP TABLE TEST_DROP CASCADE CONSTRAINT;
--TABLE WILL BE DROPPED.
--CHILD TABLE CONSTRAINT WILL BE REMOVED BUT, DATA WILL BE SAME AS BEFORE .

SELECT * FROM VW_TEST_DROP;--VIEW
--VIEW WILL BE SHOW ERROR

SELECT * FROM MV_TEST_DROP;--MATERIALIZED VIEW 
--DATA WILL BE DISPLAY .

EXEC DBMS_MVIEW.REFRESH ('MV_TEST_DROP');--ERROR
--IT WILL NOT REFRESH AFTER DROP THE BASE TABLE .

SELECT * FROM SY_TEST_DROP;--ERROR      --SYNONYM
--SYNONYM WILL BE DISPLAY ERROR AFTER DROP THE BASE TABLE .

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'TEST_DROP';
--INDEX WILL BE REMOVED AFTER DROP THE BASE TABLE .

/
--RECYCLEBIN :
--=============
--WHEN WE DROP A TABLE THEN ALL TABLE ARE STORED IN RECYCLEBIN .
--IT IS A ONE TYPE OF VIEW.

--SYNTAX :
--===========
--SELECT * FROM RECYCLEBIN ;

DROP TABLE ABC;
-- DROP THE TABLE.

SELECT * FROM RECYCLEBIN;
--HERE WE SEE THE DROP TABLE DETAILS (NAME , TYPE, CREATETIME, DROPTIME.... )

SELECT * FROM RECYCLEBIN ORDER BY DROPTIME DESC;
--HERE WE ORDERING THE DROPTIME IN RECYCLEBIN

SELECT ORIGINAL_NAME , COUNT(*) FROM RECYCLEBIN GROUP BY  (ORIGINAL_NAME) HAVING COUNT(*) >1;
--HERE WE GET WHICH TABLE HOW MANT TIME DROPPED .

/
--FLASHBACK :
--=============
--ONCE TABLE IS DROP THEN IT WILL RECOVERY BY USING FLASHBACK.
--WHEN WE USE FLASHBACK THEN INDEX, CONSTRAINT, DEPENDENCIES OBJECTS ARE RECOVERY .

--SYNTAX :
--=========
--FLASHBACK TABLE < TABLE_NAME > TO BEFORE DROP ;

CREATE TABLE FLASHBACK_DROP_TEST (ID NUMBER (10) PRIMARY KEY, NAME VARCHAR2(10) NOT NULL, SALARY INT );

INSERT INTO FLASHBACK_DROP_TEST VALUES (10, 'ABC', 2000);

COMMIT;

CREATE INDEX IDX_SAL ON FLASHBACK_DROP_TEST(SALARY);
--INDEX WILL BE CREATE OVER SALARY COLUMN.

INSERT INTO FLASHBACK_DROP_TEST VALUES (11, 'PQR', 3000);

COMMIT;

SELECT * FROM FLASHBACK_DROP_TEST;

DROP TABLE FLASHBACK_DROP_TEST;
--DROPPED THE TABLE .

SELECT * FROM RECYCLEBIN WHERE ORIGINAL_NAME = 'FLASHBACK_DROP_TEST';
--HERE WE SEE THE DETAILS OF DROPPED TABLE .

FLASHBACK TABLE FLASHBACK_DROP_TEST TO BEFORE DROP ;
--HERE WE RECOVERY THE DROP TABLE USING FLASHBACK FROM RECYCLEBIN.

SELECT * FROM FLASHBACK_DROP_TEST;
--HERE WE GET THE SAME DATA BEFORE DROPPING.

/
--PURGE :
--==========
--IT IS A DDL COMMAND.
--IT IS USED FOR DROP A TABLE PERMANENTLY FROM DATABASE .

--SYNTAX :
--==========
--DROP TABLE < TABLE_NAME > PURGE;

SELECT * FROM FLASHBACK_DROP_TEST;

DROP TABLE FLASHBACK_DROP_TEST PURGE;
--THIS TABLE DROPPED PERMANENTLY.

SELECT * FROM RECYCLEBIN  WHERE ORIGINAL_NAME = 'FLASHBACK_DROP_TEST';
--HERE WE DON'T FIND THE TABLE WHICH ARE DROP WITH PURGE.

/
--HOW TO DROP ALL TABLE IN RECYCLEBIN WITHOUT USING FLASHBACK :
--=================================================================
PURGE RECYCLEBIN;
--HERE ALL TABLE ARE PERMANENT DROP FROM RECYCLEBIN.

SELECT * FROM RECYCLEBIN;
--HERE 0 RECORD FOUND AFTER DROPPED ALL RECYCLEBIN.

/
--RENAME COMMAND / CHANGE THE NAME OF AN OBJECT :
--===============================================
--THE RENAME COMMAND CAN BE USED TO CHANGE THE NAME OF A
--    * TABLE                 * INDEX
--    * VIEW                  * SEQUENCE 
--    * MATERIALIZED VIEW     * SYNONYM
--    * CONSTRAINT.
--TO RENAME THE OBJECT WE MUST BE THE OWNER OF THE OBJECT.

--AFTER RENAME A BASE TABLE THEN WHAT EFFECT OVER DEPENDENCIES OBJECT :
--======================================================================
--VIEW : DISPLAY ERROR.
--MATERIALIZED VIEW : IT CAN'T REFRESH.
--INDEX : REMVOVED AFTER RENAME .
--SYNONYM : DISPLAY ERROR.
--CONSTRAINT : REMOVED AFTER RENAME .

--AFTER RENAME WHERE NO CHANGES :
--==================================
-- RENAME VIEW  : STILL IT WILL DEPENDENCIES WITH BASE TABLE .
-- RENAME MATERIALIZED VIEW : IT CAN'T POSSIBLE .
-- RENAME CONSTRAINT : STILL IT WILL DEPENDENCIES WITH BASE TABLE.
-- RENAME INDEX : STILL IT WILL DEPENDENCIES WITH BASE TABLE .
-- RENAME SYNONYM : STILL IT WILL DEPENDENCIES WITH BASE TABLE .

--NOTE :
--========
--IF WE DON'T SPECIFY CACHE THEN AFTER RENAME A SEQUENCE IT BY DEFAULT START WITH DIFFERENCE 20 WITH NEXTVAL ONLY.
--IF WE SPECIFY NO CACHE WHEN WE CREATE SEQUENCE THEN AFTER RENAME THERE IS NO CHANGES  .
--WHEN WE RENAME SEQUENCE AFTER THAT CURRVAL CAN'T WORK , ITS MANDATORY TO USE ONCE NEXTVAL.


--SYNTAX :
--=========
--RENAME < OLD_NAME > TO < NEW_NAME>.

CREATE TABLE TEST_RENAME (ID INT CONSTRAINT PK_RENAME PRIMARY KEY, 
                          SLNO INT CONSTRAINT FK_RENAME REFERENCES TEST_RENAME(ID) );

INSERT INTO TEST_RENAME VALUES (1, NULL);
INSERT INTO TEST_RENAME VALUES (2, NULL);
INSERT INTO TEST_RENAME VALUES (3, 1);

COMMIT;

SELECT * FROM TEST_RENAME;                          

CREATE VIEW VW_TEST_RENAME AS SELECT * FROM TEST_RENAME;--VIEW

CREATE MATERIALIZED VIEW MV_TEST_RENAME AS SELECT * FROM TEST_RENAME;--MATERIALIZED VIEW 

CREATE INDEX IND_TEST_RENAME ON TEST_RENAME (SLNO);--INDEX

CREATE SYNONYM SY_TEST_RENAME FOR TEST_RENAME;--SYNONYM

RENAME TEST_RENAME TO NEW_TEST_RENAME;

SELECT * FROM TEST_RENAME;
--AFTER RENAME OLD TABLE NAME DOESN'T WORK .

SELECT * FROM NEW_TEST_RENAME;
--NEW TABLE_NAME WORKING

SELECT * FROM VW_TEST_RENAME;
--VIEW DISPLAY ERROR.

SELECT * FROM MV_TEST_RENAME;
--DISPLAY MATERIALLIZED VIEW DATA .

EXEC DBMS_MVIEW.REFRESH ('MV_TEST_RENAME');
--BUT IT CAN'T REFRESH.

SELECT * FROM SYS.USER_INDEXES WHERE TABLE_NAME = 'TEST_RENAME';
--INDEX WILL BE REMVOVED AFTER RENAME .

SELECT * FROM SY_TEST_RENAME;
--AFTER RENAME SYNONYM DISPLAY ERROR.

CREATE TABLE TEST_RENAME2 (ID INT CONSTRAINT PK_TEST_RENAME2 PRIMARY KEY,
                            SLNO INT CONSTRAINT FK_TEST_RENAME REFERENCES TEST_RENAME2 (ID));

INSERT INTO TEST_RENAME2 VALUES (1, NULL);   
INSERT INTO TEST_RENAME2 VALUES (2, NULL);                             
INSERT INTO TEST_RENAME2 VALUES (3, 1);  

COMMIT;

CREATE VIEW VW_TEST_RENAME2 AS SELECT * FROM TEST_RENAME2;

RENAME VW_TEST_RENAME2 TO NEW_VW_TEST_RENAME2;
--AFTER RENAME VIEW STILL IT WILL DEPENDENCIES WITH BASE TABLE TABLE.

CREATE MATERIALIZED VIEW MV_TEST_RENAME2 AS SELECT * FROM TEST_RENAME2;

RENAME MV_TEST_RENAME2 TO NEW_MV_TEST_RENAME2;--ERROR
--WE CAN'T RENAME A MATERIALIZED VIEW NAME .

ALTER TABLE TEST_RENAME2 RENAME CONSTRAINT PK_TEST_RENAME2 TO NEW_PK_TEST_RENAME2;
--AFTER RENAME CONSTRAINT IT WILL STILL RELATIONSHIP WITH EACH OTHER .

ALTER INDEX PK_TEST_RENAME2 RENAME   TO NEW_PK_TEST_RENAME2;
--AFTER RENAME INDEX STILL IT WILL DEPENDENCIES WITH BASE TABLE TABLE.

CREATE SYNONYM SY_TEST_RENAME2 FOR TEST_RENAME2;

RENAME SY_TEST_RENAME2 TO NEW_SY_TEST_RENAME2;
--AFTER RENAME SYNONYM STILL IT WILL DEPENDENCIES WITH BASE TABLE TABLE.

CREATE SEQUENCE SEQ_TEST_RENAMEE
      START WITH 5 
      NOCACHE ;
      
SELECT SEQ_TEST_RENAMEE.NEXTVAL FROM DUAL;--5

RENAME SEQ_TEST_RENAMEE TO NEW_SEQ_TEST_RENAMEE;
--RENAME THE SEQUENCE .

SELECT NEW_SEQ_TEST_RENAMEE.NEXTVAL FROM DUAL;--6
--AFTER RENAME SEQUENCE WORK.

CREATE SEQUENCE SEQ_TEST_RENAMEE2 ;

SELECT SEQ_TEST_RENAMEE2.NEXTVAL FROM DUAL;--1

RENAME SEQ_TEST_RENAMEE2 TO NEW_SEQ_TEST_RENAMEE2;
--RENAME THE SEQUENCE 

SELECT NEW_SEQ_TEST_RENAMEE2.NEXTVAL FROM DUAL;--21

RENAME NEW_SEQ_TEST_RENAMEE2 TO NEW_NEW_SEQ_TEST_RENAMEE2;

SELECT NEW_NEW_SEQ_TEST_RENAMEE2. NEXTVAL FROM DUAL;--41


--TRUNCATE (DDL) :
--=================
--IT IS USED TO REMOVES ALL ROWS FROM A TABLE AND TO RELATE THE STORAGE SPACE USED BY THE SPECIFIC TABLE.
--AFTER TRUNCATE WE CAN'T ROLLBACK COZ, THIS IS AUTO - COMMIT (DDL).

--SYNTAX :
--==========
--TRUNCATE TABLE < TABLE_NAME >;

/
CREATE TABLE TEST_TRUNCATE (ID INT PRIMARY KEY, SLNO INT REFERENCES TEST_TRUNCATE(ID), NAME VARCHAR2(5) NOT NULL);

INSERT INTO TEST_TRUNCATE VALUES (1, NULL, 'A');
INSERT INTO TEST_TRUNCATE VALUES (2, NULL, 'B');
INSERT INTO TEST_TRUNCATE VALUES (3, 1, 'C');
COMMIT;

SELECT * FROM TEST_TRUNCATE;

TRUNCATE TABLE TEST_TRUNCATE;

SELECT * FROM TEST_TRUNCATE;

SELECT * FROM VW_TEST_TRUNCATE;
--AFTER TRUNCATE VIEW WILL ALSO BLANK.

SELECT * FROM MV_TEST_TRUNCATE;
--DATA WILL BE DISPLAY BUT ,

EXEC DBMS_MVIEW.REFRESH ('MV_TEST_TRUNCATE');
--AFTER REFRESH MV WILL BE BLANK.

SELECT * FROM SYS.USER_INDEXES WHERE TABLE_NAME = 'TEST_TRUNCATE';
--INDEX ARE IN SAME NO CHANGES.

SELECT * FROM SYS.USER_CONSTRAINTS WHERE TABLE_NAME = 'TEST_TRUNCATE';
--CONSTRAINT ARE SAME NO CHANGES.

SELECT * FROM SY_TEST_TRUNCATE;
--SYNONYM ALL DATA WILL BE REMOVED COZ OF AUTO-SYNC.

ROLLBACK;
--HERE ROLLBACK DOESN'T WORK COZ, TRUNCATE IS A PART OF DDL (AUTO-COMMIT).

/
--INTERVIEW QUESTION :
--=======================
--WHAT IS DIFFERENCE BETWEEN DELETE AND TRUNCATE :
--==================================================
--                  DELETE                                               TRUNCATE
--               =============                                        ==============
1.IT IS A DML COMMAND.                                     1.IT IS A DDL COMMAND.
2.IT IS USED REMOVE RECORD FROM TABLE , IT CAN BE          2.IT IS USED TO REMOVE RECORD FROM TABLE, IT CAN'T' BE
  ROLLBACK AFTER DELETE.                                      ROLLBACK AFTER TRUNCATE.
3.WE CAN APPLY WHERE CONDITION.                            3.WE CAN'T' APPLY WHERE CONDITION.
4.PERFORMANCE IS SLOWER, IT WILL STORED A COPY IN          4.PERFORMANCE IS FASTER, IT WILL DOESN'T' STORE A COPY
  ROLLBACK SEGMENT AREA.                                      IN ROLLBACK SEGMENT AREA.
5.IT NEED TO BE COMMIT .                                   5.IT IS AUTO COMMIT (DDL).  

/
--COMMENT / APPLY COMMENTS UPON A TABLE (DDL):
--===============================================
--THE COMMENT COMMAND IS USED TO EXPLAIN WHICH TYPES OF DATA WILL HOLDS A TABLE OR COLUMN.
--THE MAXIMUM SIZE IS 2000 BYTES.

--SYNTAX :
--==========
--FOR TABLE :
--============
--COMMENT ON TABLE < TABLE_NAME > IS < EXPRESSION >;

--DICTIONARY OF TABLE COMMENTS:
--==============================
SELECT * FROM ALL_TAB_COMMENTS ;
--OWNER, TABLE_NAME , TABLE_TYPE, COMMENTS.

SELECT * FROM USER_TAB_COMMENTS ;
--TABLE_NAME , TABLE_TYPE, COMMENTS.

--FOR COLUMN :
--==============
--COMMENT ON COLUMN < TABLE_NAME > . < COLUMN_NAME > IS < EXPRESSION >;

--DICTIONARY OF COLUMN COMMENTS :
--================================
SELECT * FROM ALL_COL_COMMENTS;
--OWNER, TABLE_NAME, COLUMN_NAME , COMMENTS .

SELECT * FROM USER_COL_COMMENTS ;
--TABLE_NAME , COLUMN_NAME, COMMENTS.

--FOR MATERIALIZED VIEW COMMENTS :
--=================================
SELECT * FROM ALL_MVIEW_COMMENTS;--FOR MV
--OR
SELECT * FROM USER_MVIEW_COMMENTS;--FOR MV
--OR
SELECT * FROM USER_COL_COMMENTS ;--MV COLUMNS

--SYNONYM :
--===========
--AFTER COMMENT OVER A SYNONYM IT WILL CHANGES ALSO BASE TABLE EXIST COMMENT , AUTO-SYNC.
--WHEN WE APPLY A COMMENT OVER SYNONYM / SYNONYM COLUMN , WHEN WE DISPLAY DICTIONARY TABLE THEN WE MUST SPECIFY 
--                                              ONLY BASE TABLE NAME NOT A SYNONYM NAME 

/
--DROP A COMMENTS 
--=================
--COMMENT ON TABLE < TABLE_NAME > IS '';      --TABLE
--COMMENT ON COLUMN < TABLE_NAME > . < COLUMN_NAME > IS '' ;     --COLUMN

/
COMMENT ON TABLE NIELEMP IS 'THIS IS COPY TABLE OF EMP';
--COMMENT ON A TABLE.

SELECT * FROM USER_TAB_COMMENTS WHERE TABLE_NAME = 'NIELEMP';
--HERE WE GET THE COMMENTS OF TABLE .

COMMENT ON COLUMN NIELEMP.SAL IS 'THIS IS SALARY DETAILS OF ALL EMPLOYEE';
--HERE WE APPLY A COMMENTS OVER A COLUMN.

SELECT * FROM USER_COL_COMMENTS WHERE TABLE_NAME = 'NIELEMP';
--HERE WE CHECK THE COMMENT LIST OF COLUMNS.

COMMENT ON TABLE VW_NIELEMP IS 'THIS IS A VIEW';
--COMMENT APPLY OVER A VIEW .

COMMENT ON COLUMN VW_NIELEMP. NAME IS 'COL VIEW';
--COMMENT APLLY ON A COLUMN OF VIEW .

COMMENT ON MATERIALIZED VIEW  NIELEMP_MV IS 'THIS IS MV';
--OVER A MATERIALIZED VIEW WE CAN COMMENT.
SELECT * FROM USER_MVIEW_COMMENTS;

COMMENT ON COLUMN NIELEMP_MV.SAL IS 'THIS IS MVCOL SAL';
--OVER MATERIALIZED VIEW COLUMNS WE CAN APPLY COMMENTS.

SELECT * FROM USER_COL_COMMENTS WHERE TABLE_NAME  = 'NIELEMP_MV';

COMMENT ON TABLE SY_NEMP IS 'COMM_SY';
--OVER A SYNONYM WE CAN APPLY ALSO COMMENT .
--BUT IF WE SEE THE DICTIONARY TABLE OF SYNONYM COMMENT WE MUST SPECIFY THE TABLE_NAME = BASE_TABLE

COMMENT ON COLUMN SY_NEMP. NAME IS 'COMM_COL_SY';
--OVER A SYNONYM COLUMN WE CAN ALSO APPLY A COMMENTS.

COMMENT ON  COLUMN SY_NEMP.NAME IS '';
--HERE EXIST COLUMN WILL BE DROPPED.

COMMENT ON TABLE NIELEMP IS '';
--HERE EXIST COMMENT OVER A TABLE IS DROPPED .

/
--ADVANCE TABLE CREATION STRATEGY :
--===================================
--WE CAN CREATE A TABLE BASED ON AN EXISTING TABLE , THIS PROCESS IS KNOWN AS ON THE FLY.
--USING ON THE FLY WE CAN TAKE ALL COLUMNS , INDIVIDUAL COLUMNS WHILE CREATING THE TABLE .
--THE TARGET TABLE COPY THE DATA , DATATYPE, LENTH ALSO.
--THE INVENTED COLUMN DATATYPE SHOULD ADJUST WITH THE SOURCE TABLE COLUMN OR COMBINATION OF COLUMN.
--IN SOURCE TABLE IF ANY ONE COLUMN HAVE LONG DATATYPE THEN WE CAN'T CREATE THE TABLE .

--CREATE A EXACT COPY OF EXISTING TABLE :
--=========================================
--CREATE TABLE < TABLE_NAME > AS SELECT * FROM <SOURCE_TABLE_NAME >;

CREATE TABLE TEST_EXACT AS SELECT * FROM EMP;

SELECT * FROM TEST_EXACT;
--HERE ALL DATA , COLUMN, DATATYPE WILL BE COPY.
--BUT NOT INCLUDE CONSTRAINT, INDEX , VIEW, MATERIALIZED VIEW.

--CREATING EXACT COPY WITH DIFFERENT COLUMN NAME CHANGE :
--========================================================
--CREATE TABLE < TABLE_NAME > < (NEW1, NEW2, NEW3..) > AS SELECT * FROM < SOURCE_TABLE >;

CREATE TABLE TEST_EXACT_WITH_NAME_CHANGE (DEPARTMENT, LOCATION) 
                AS
                SELECT DEPTNO, LOC FROM DEPT;
--HERE WE CREATE A TABLE WITH NAME CHANGE AND SPECIFIED COLUMNS.

CREATE TABLE TEST_EXACT_WITH_NAME_CHANGE2 (DEPERTMENT, DEPARTMENT_NAME, LOCATION)
                            AS
                            SELECT * FROM DEPT;
--HERE ALSO WE CREATE ALL COLUMN WITH NAME CHANGE.
--MUST REMEMBER WHEN WE USING * IN SOURCE TABLE THEN BE SURE TARGET TABLE SEPCIFY NO. OF COLUMN SHOULD BE SAME.

CREATE TABLE TEST_EXACT_WITH_NAME_CHANGE3 (DEPARTMENT, LOCATION)
                      AS SELECT * FROM DEPT;--ERROR
--HERE TARGET TABLE'S SPECIFY NO. OF COLUMN AND SOURCE TABLE'S NO. OF COLUMN SHOULDN'T MATCH .

--CREATING A COPY WITH REQUIRED COLUMNS :
--=========================================
--CREATE TABLE < TABLE_NAME > AS SELECT < COL1, COL2 > FROM < SOURCE_TABLE_NAME >;

CREATE TABLE TEST_REQUIRE_COL_CREATE 
                AS
                SELECT DEPTNO, DNAME FROM DEPT;
--HERE WE CREATE A TABLE WITH REQUIRED COLUMN FROM SOURCE TABLE.

--CREATING A COPY WITH INVENTED COLUMN :
--=======================================
--CREATE TABLE < TABLE_NAME > < (COL1, COL2....) > AS SELECT < INVENTED COLUMN > FROM < SOURCE_TABLE >;

CREATE TABLE TEST_INVENTED (DEPARTMENT , DEPARTNAME, DEPARTMENT_BUDGET) AS
            SELECT D.DEPTNO, D.DNAME , SUM(E.SAL)
                  FROM EMP E INNER JOIN DEPT D
                  ON E.DEPTNO = D.DEPTNO
              GROUP BY (D.DEPTNO, D.DNAME);
--HERE USING COMPLEX QUERY WE CREATE A TABLE .

SELECT * FROM TEST_INVENTED;     

CREATE TABLE TEST_GRADE (ENAME , SAL, DNAME, GRADE ) AS 
          SELECT ENAME , SAL , DNAME, GRADE 
                  FROM EMP E INNER JOIN DEPT D
                      ON E.DEPTNO = D.DEPTNO
                  INNER JOIN SALGRADE S 
                      ON E.SAL BETWEEN S.LOSAL AND S.HISAL
                ORDER BY GRADE;
--HERE WE CREATE A TABLE USING MULTIPLE TABLE AND INDIVIDUAL COLUMN WITH ORDER BY CLAUSE .

SELECT * FROM TEST_GRADE ;                

--CREATING A COPY WITHOUT DATA ( ONLY STRUCTURE ) :
--==================================================
--CREATE TABLE < TABLE_NAME > AS SELECT * FROM < SOURCE_TABLE > WHERE < FALSE_CONDITION > ;

CREATE TABLE TEST_STRUCTURE (DEPARTMENT , LOCATION) AS SELECT DEPTNO,LOC FROM DEPT WHERE 'NIEL' = 'NEELAKANTHA';
--HERE WE CREATE A STRUCTURE OF SOURCE TABLE USING FALSE CONDITION IN WHERE CLAUSE.

SELECT * FROM TEST_STRUCTURE;

--WE CAN ALSO INSERT USING ON THE FLY METHOD :
--==============================================
--INSERT INTO < TABLE_TABLE > SELECT * FROM < SOURCE_TABLE >;

INSERT INTO TEST_STRUCTURE SELECT DEPTNO, LOC FROM DEPT;
--HERE WE INSERT DATA USING ON THE FLY METHOD;

SELECT * FROM TEST_STRUCTURE;

--CREATING A TABLE WITHOUT GENERARING REDO LOG FILES :
--======================================================
--BY USING REDO LOG ENTRIES, WE CAN RECOVER IF DATABASE IS FAILURE.
--IF WE CREATE A TABLE WITH NOLOGGING ENTRY WE CANNOT RECOVER THE TABLE IF DATABASE IS FAILURE. 
--BY DEFAULT LOGGING IS THERE BUT IT IS HIDE WHEN WE CREATE ANY NORMAL TABLE.

--NOTE BY NIEL :
--================
--WHEN WE DROP A TABLE THEN THIS TABLE WILL MOVE TO LOG FILES.
--3 IMPORTANT FILES IN DATABASE     1.CONTROL FILE
--                                  2.DATA FILE.
--                                  3.REDO FILE.
--REDO LOG IS A BACKUP FILE OF A OBJECT .
--NOLOGGING :- WE CAN'T RECOVERY A TABLE AFTER DROP .

--HOW TO CHECK A TABLES HAVE LOGGING OR NO LOGGING :
--==================================================
SELECT * FROM USER_TABLES ;
--HERE WE CHECK LOGGING DETAILS IN LOGGING COLUMN .

/
CREATE TABLE TEST_LOGGING  (ID INT )NOLOGGING;
--HERE WE CREATE A TABLE USING NOLOGGING FILES.

SELECT * FROM USER_TABLES WHERE TABLE_NAME = 'TEST_LOGGING';
--WHEN WE CHECK ON THIS TABLE THERE LOOGING COLUMN DISPLAY "NO".

CREATE TABLE TEST_LOGGING2 NOLOGGING AS SELECT * FROM DEPT;
--HERE WE CREATE A COPY OF A TABLE AND SPECIFY NOLOGGING FILES.

SELECT * FROM USER_TABLES WHERE TABLE_NAME = 'TEST_LOGGING2';

/
--CREATED INDEX ORGANIZED TABLE (IOT) :
--=======================================
--AN IOT STORED DATA ACCORDING TO THE PRIMARY KEY ON THIS SAME BASE TABLE .
--THERE IS NO NEED TO READ A INDEX THEN READ THE TABLE DATA IN A SEPARATE STRUCTURE.
--TO CREATE A IOT PRIMARY KEY CONSTRAINT IS MANDATORY.
--WE SHOULD APPLY IOT ON A TABLE WHICH IS LESS CHANGES.

--NOTE BY NIEL :
--===============
--IOT STORED COPY ON THIS SAME BASE TABLE.
--BUT IN CASE OF INDEX MAKE A EXTRA COPY OF INDEX ORDERING FORMAT.
--SO IOT ARE FASTER THEN INDEX.
--WE CAN'T ADD REVERSE INDEX ON OVER IOT.
--WE CAN'T ADD BITMAP INDEX OVER IOT.

/
CREATE TABLE TEST_IOT (ID NUMBER (4), NAME VARCHAR2(10), JOIN_DATE DATE, 
                      CONSTRAINT PK_ID_NAME PRIMARY KEY (ID, NAME)) ORGANIZATION INDEX;
--WHEN WE CHECK THE INDEX NAME THEN IT WILL TAKE THE CONSTRAINT NAME AS A INDEX NAME .

INSERT INTO TEST_IOT SELECT EMPNO, ENAME , HIREDATE FROM EMP;

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'TEST_IOT';                      
--HERE WE CHECK IN COLUMN INDEX_TYPE IT WILL DISPLAY AS " IOT - TOP ".

SELECT * FROM TEST_IOT;
--INDEX FAST FULL SCAN.

SELECT * FROM TEST_IOT WHERE JOIN_DATE  = '22-FEB-81';
--HERE WE INDEX FULL SCAN

SELECT JOIN_DATE  FROM TEST_IOT WHERE NAME = 'KING';
--INDEX FULL SCAN.

CREATE  INDEX REVIDX_JOIN_DATE ON TEST_IOT(JOIN_DATE) REVERSE;
--WE CAN'T ADD REVERSE INDEX ON OVER IOT.

CREATE BITMAP INDEX BMAPIDX_JOIN_DATE ON TEST_IOT (JOIN_DATE);
--WE CAN'T ADD BITMAP INDEX OVER IOT.

CREATE INDEX FUNIDX_IOT ON TEST_IOT( LOWER (JOIN_DATE));
--IT WILL WORKING.

CREATE TABLE TEST_IOT2 (ID INT, NAME VARCHAR2(10)) ORGANIZATION INDEX;--ERROR
--TO CREATE ORGANIZATION INDEX MUST REQUIRE A PRIMARY KEY CONSTRAINT.

CREATE TABLE TEST_IOT3 (ID INT, NAME VARCHAR2(10)) ;

ALTER TABLE TEST_IOT3 ADD CONSTRAINT PK_ID_TEST_IOT3 PRIMARY KEY(ID);

CREATE ORGANIZATION INDEX IDX_IOT_TEST_IOT3 ON TEST_IOT3(ID);--ERROR
--WE CAN'T ADD ORGANIZATION TABLE OVER A EXISTING 

CREATE TABLE TEST_IOT4(ID INT PRIMARY KEY, NAME VARCHAR2(10))ORGANIZATION INDEX;

SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'TEST_IOT4';
--HERE INDEX NAME BY DEFAULT SYSTEM SET = 'SYS_IOT_TOP_79326'.

ALTER INDEX SYS_IOT_TOP_79326 RENAME TO NIEL_IND;
--HERE WE RENAME THE DEFAULT ORGANIZATION INDEX NAME .

/
--PARTITION TABLE :
--===================
--DIVIDING THE ROWS OF A SINGLE TABLE INTO MULTIPLE PARTS IS CALLED PARTITIONING OF A TABLE .
--THE TABLE THAT IS PARTITIONED IS CALLED PARTITIONED TABLE .
--PARTS OF THE TABLE ARE CALLED PARTITIONS.
--THE PARTITIONING IS USEFUL FOR VERY LARGE TABLES ONLY.
--PARTITION ALWAYS SPECIFY BEGINNING OF CREATE A TABLE .
--EACH PARTITION WORK AS A SINGLE TABLE .
--WHICH COLUMN WE SPECIFY UNDER PARTITION IS CALLED PARTITION KEY.

--BENEFITS OF USING PARTITIONED TABLE :
--=========================================
--THE PERFORMANCE OF QUERIES GETS INCREASED.
--WE CAN EASILY MANAGE THE PARTITION TABLE .
--WE CAN EASILY LOAD & DELETE DATA PARTITION THAN IF THE LARGE TABLE .
--WE CAN EASILY DO THE BACKUP & RECOVERY .
--PARTITION NAME IS OPTIONAL , IF WE DON'T PROVIDE PARTITION NAME THEN ORACLE WILL CREATE AUTOMATICALLY.

--1. RANGE PARTITION :
--=======================
--WE CAN TAKE RANGE ONLY WITH NUMBER & DATE ONLY .
--IF WE PROVIDE MAXVALUE THEN IT WILL STORE REST OF THE DATA IN MAXVALUE PARTITION (DEFAULT) .
--IN RANGE PARTITION WE CAN'T TAKE ANY RELATIONAL OPERATOR.

--SYNTAX:
--=========
--CREATE TABLE < TABLE_NAME > ( < COLUMN_NAME >  <DATATYPE> ) 
--            PARTITION BY < PARTITION_TYPE > ( < COLUMN_NAME >)
--            ( PARTITION < PARTITION_NAME > VALUES LESS THEN ( < VALUES >),
--              PARTITION < PARTITION_NAME > VALUES LESS THAN ( < VALUES >));

/
CREATE TABLE PARTITION_RANGE (ID INT, NAME VARCHAR2(10)) 
                PARTITION BY RANGE (ID)
                      (PARTITION P1 VALUES LESS THAN (5),
                      PARTITION P2 VALUES LESS THAN (10));
--HERE P1 LESS THAN 5 MEAN UPTO 4 , UNDER NEGATIVE VALUES ALSO.
--HERE P2 ONLY 5 TO 9 .

INSERT INTO PARTITION_RANGE VALUES (4, 'A');
--THIS WILL BE UNDER P1.
INSERT INTO PARTITION_RANGE VALUES (-4, 'A');
--THIS ONE ALSO UNDER P1.
-- NEGATIVE VALUES UNDER LESS THAN 5 SO..
INSERT INTO PARTITION_RANGE VALUES (4, 'A');
--UNDER P1.
INSERT INTO PARTITION_RANGE VALUES (7, 'A');
--UNDER P2.
INSERT INTO PARTITION_RANGE VALUES (5, 'A');
--UNDER P2.
INSERT INTO PARTITION_RANGE VALUES (11, 'A');--ERROR
--COZ THIS ONE IS OUT OF RANGE PARTITION.
INSERT INTO PARTITION_RANGE VALUES (1.9, 'A');
--IT WILL BE UNDER P1.
--BUT IT WILL ROUND THE VALUES IF SCALE IS 5 OR LESS THAN THEN IT WILL TAKE SMALLEST, SAME AS GREATEST. 
--FOR THIS ROUND OPTION OVERCOME WE SPECIFY PRESCISION AND SCALE ON THIS COLUMN AT CREATE TIME.

SELECT * FROM PARTITION_RANGE;
--WHEN WE CHECK EXPLAIN PLAN IT DISPLAY TABLE ACCESS FULL WITH PARTITION RANGE ALL.

SELECT * FROM PARTITION_RANGE WHERE ID =4;
--WHEN WE CHECK EXPLAIN PLAN IT DISPLAY PARTITION RANGE (SINGLE) WITH TABLE ACCESS FULL .

--DICTIONARY TABLE OF PARTITION TABLE :
--========================================
SELECT * FROM USER_TAB_PARTITIONS;--DICTIONARY TABLE
--HERE WE CHECK THE DETAILS OF PARTITIONS. (TABLE_NAME , PARTITION_NAME , HIGH_VALUE, LOGGING ...)

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'PARTITION_RANGE';
--DETAILS OF A PARTITION.

SELECT * FROM SYS.USER_PART_TABLES;
--ANOTHER DICTIONARY (TABLE_NAME , PARTITION_TYPE, PARTITION_COUNT, STATUS )

SELECT * FROM USER_PART_TABLES WHERE TABLE_NAME = 'PARTITION_RANGE';

SELECT * FROM USER_PART_KEY_COLUMNS ;
--ANOTHER DICTIONARY ( NAME < TABLE_NAME >, OBJECT_TYPE, COLUMN_NAME , COLUMN_POSITION )

SELECT * FROM USER_PART_KEY_COLUMNS WHERE NAME = 'PARTITION_RANGE';

--WE CAN'T INSERT VALUES WHICH IS OUTSIDE OF THE PARTITION :
--=============================================================
INSERT INTO PARTITION_RANGE VALUES (10, 'A');--ERROR
--THIS ONE ALSO OUT OF RANGE PARTITION (LESS THAN 10)
INSERT INTO PARTITION_RANGE VALUES (NULL, 'A');--ERROR
--NULL IS A UNDEFINED VALUES SO WE CAN'T SPECIFY BETWEEN A RANGE.

--CHECK INDIVIDUALLY PARTITION VALUES :
--=======================================
SELECT * FROM PARTITION_RANGE partition(P1);
--WE CAN ALSO CHECK INDIVIDUAL PARTITON VALUES ALSO.

SELECT * FROM PARTITION_RANGE partition(P2);

--ADD PARTITION ON A EXISTING TABLE :
--=====================================
--SYNTAX :
--===========
--ALTER TABLE < TABLE_NAME > ADD PARTITION < PARTITION_NAME > VALUES LESS THAN ( < VALUES >);

ALTER TABLE PARTITION_RANGE ADD PARTITION P3 VALUES LESS THAN (20);
--HERE WE ADD ANOTHER PARTITION OF A EXISTING TABLE.
--THIS ALTER OPTION IS POSSIBLE WHEN AT LEAST ONE PARTITION SPECIFY IN CREATE TABLE TIME.

INSERT INTO PARTITION_RANGE VALUES (11, 'N');
--NOW THIS VALUES ARE UNDER P3.
INSERT INTO PARTITION_RANGE VALUES (10, 'D');
--UNDER P3.

SELECT * FROM PARTITION_RANGE PARTITION (P3);
--HERE WE CHECK THE P3 VALUES.

--HOW WE CAN ADD VALUES WHICH IS NOT IN RANGE VALUES PARTITION :
--================================================================
ALTER TABLE PARTITION_RANGE ADD PARTITION P4 VALUES LESS THAN (MAXVALUE);
--HERE WHICH VALUES ARE NOT LISTED BETWEEN THE RANGE THEN THIS TIME WE SPECIFY MAXVALUE .
--NULL VALUES ARE ALSO STORED IN MAXVALUE.
--WE CAN SAY IN RANGE PARTITION MAXVALUE IS A DEFAULT OPTION .
--ONCE WE SPECIFY MAXVALUE IN RANGE PARTITION THEN WE CAN'T ADD ANY OTHER PARTITION IN SAME TABLE .

INSERT INTO PARTITION_RANGE VALUES (20, 'D');
INSERT INTO PARTITION_RANGE VALUES (21, 'D');
--THESE ABOVE 2 VALUES ARE NOT BETWEEN THE RANGE SO THIS VALUES ARE STORED IN P4 PARTITION (MAXVALUE)

INSERT INTO PARTITION_RANGE VALUES (NULL, 'D');
--NULL VALUE ARE ALSO STORED UNDER MAXVALUE (P4)

SELECT * FROM PARTITION_RANGE PARTITION (P4);
--HERE WE FIND THE MAXVALUE PARTITION VALUES .
SELECT * FROM USER_TAB_PARTITIONS ;

--DML OPERATION ON A SPECIFIC PARTITION :
--========================================
--INSERT :
--=========
INSERT INTO PARTITION_RANGE PARTITION(P1) VALUES (4, 'DS');
--HERE WE INSERT VALUES IN SPECIFY A INDIVIDUAL PARTITION NAME 
--BUT MAKE SURE FOR IF WE SPECIFY A PARTITION THEN WHICH VALUE WE INSERT THEN THIS VALUE ARE UNDER THIS 
--                                                         PARTITION RANGE.
--THIS IS NOT NECESSARY ONLY FOR UNDERSTANDING ..

INSERT INTO PARTITION_RANGE PARTITION(P2) VALUES (4, 'DS');--ERROR
--WHEN WE SPECIFY PARTITION THEN INSERT VALUES ARE OUT OF THIS PARTITION RANGE THEN THIS INSERT NOT EXECUTE.

--DELETE:
--=============
DELETE FROM PARTITION_RANGE PARTITION(P2) WHERE ID = 7;
--HERE WE SPECIFY A PARTITION NAME DELETE A RECORD OF THIS SAME PARTITION VALUES .

DELETE FROM PARTITION_RANGE PARTITION(P1) WHERE ID =11;--0ROW DELETED
--HERE DOESN;T FIND 11 IN P1 SO ...

DELETE FROM PARTITION_RANGE WHERE ID =11;
--WITHOUT SPECIFY PARTITION WE CAN DELETE ANY DATA THERE IS NO RESTRICTION.

DELETE FROM PARTITION_RANGE PARTITION(P2);
--HERE WE DELETE ALL VALUES AT A TIME WHICH ARE UNDER PARTITION P2 .

--UPDATE :
--==========
UPDATE PARTITION_RANGE PARTITION(P2) SET ID = 17 WHERE ID =7;--ERROR
UPDATE PARTITION_RANGE  SET ID = 17 WHERE ID =7;--ERROR
--WE CAN'T UPDATE A VALUE TO OUT OF RANGED VALUES .
--SO MAKE SURE WHEN WE UPDATE A VALUE THE NEW VALUE ARE UNDER EXIST VALUE RANGE.

UPDATE PARTITION_RANGE PARTITION (P3)SET ID = 17 WHERE ID =7;--0 ROW UPDATE 
--HERE IN P3 DOESN'T FIND THE VALUE =7.

UPDATE PARTITION_RANGE SET ID =9 WHERE ID =7;
--HERE WE UPDATE THE VALUES COZ , BOTH EXIST AND NEW VALUE BOTH ARE IN SAME RANGE .

--TO OVERCOME THIS UPDATE ERROR WE USE ENABLE ROW MOVEMENT :
--=======================================================
--IF WE WANT TO UPDATE A PARTITION VALUES WHICH IS OUTSIDE OF THE PARTITION RANGE THAT TIME WE WILL NEED 
--              ALTER WITH ENABLE ROW MOVEMENT (OR) WE ALL ADD ENABLE ROW MOVEMENT WHILE CREATING A TABLE.

ALTER TABLE PARTITION_RANGE ENABLE ROW MOVEMENT;
--NOW THOSE UPDATE ERROR WILL BE NOT DISPLAY .

UPDATE PARTITION_RANGE PARTITION(P2) SET ID =17 WHERE ID = 9;.
--AFTER ENABLE ROW MOVEMENT IT WILL DON'T FIND ANY PARTITION IF EXIST VALUE IS FIND THEN WE CAN CHANGE.
--BUT AFTER UPDATE THOSE NEW VALUE FIND THE PARTITION RANGE AND SET ON THAT PARTITION .
UPDATE PARTITION_RANGE PARTITION(P1) SET ID = 100 WHERE ID =-4;
--SAME HERE WE UPDATE A VALUE .

--WE CAN ALSO SPECIFY ENABLE ROW MOVEMENT IN CREATE TIME :
--==========================================================
CREATE TABLE RANGE_PART(ID INT, NAME VARCHAR2(10))
          PARTITION BY RANGE (ID)
      (PARTITION P1 VALUES LESS THAN (5),
        PARTITION P2 VALUES LESS THAN (10),
        PARTITION P3 VALUES LESS THAN (20))
    ENABLE ROW MOVEMENT;
--CREATE THE TABLE WITH PARTITION AND ENABLE ROW MOVEMENT.

INSERT INTO RANGE_PART VALUES (9, 'NIEL');

SELECT * FROM RANGE_PART PARTITION (P2);
--HERE WE VALUE FIND 

UPDATE RANGE_PART SET ID =21 WHERE ID =9;--ERROR
--OUT OF RANGE 

ALTER TABLE RANGE_PART ADD PARTITION P4 VALUES LESS THAN (MAXVALUE);
--ADD A DEFAULT PARTITION .

UPDATE RANGE_PART SET ID = 100 WHERE NAME = 'NIEL';
--UPDATE VALUES ARE SHIFT TO P4.

SELECT * FROM RANGE_PART PARTITION (P4);
--HERE UPDATE VALUE ARE FOUND.

SELECT * FROM USER_TABLES WHERE TABLE_NAME = 'RANGE_PART';
--HERE WE CHECK ENABLE ROW MOVEMENT IN ROW_MOVEMENT COLUMN.

--INTERVIEW QUESTION : (PARTITION )
--===========================
--Q.CAN WE CREATE A PARTITION ON EXISTING TABLE ?
YES . WE CAN. APLLY BY USING DBMS_REDEFINATION PACKAGE ;
BUT IT TAKE LONGER TIME TO EXECUTE.

--RANGE WITH DATE PARTITION :
--=============================
--IF WE WANT TO STORE DATA ON A DATE RANGE ON A COLUMN , THEN WE HAVE TO USE RANGE PARTITION ON DATE COLUMN .

CREATE TABLE RANGE_PART1 (PRODUCT NUMBER , NAME VARCHAR2(10), DOP DATE )
              PARTITION BY RANGE (DOP)
          (PARTITION P11 VALUES LESS THAN (TO_DATE ('01-FEB-2021')),
          PARTITION P22 VALUES LESS THAN (TO_DATE ('01-JUN-2021')),
          PARTITION P33 VALUES LESS THAN (MAXVALUE));
          
INSERT INTO RANGE_PART1 VALUES (100, 'SAMSUNG', '25-JAN-2020');  --UNDER P11        
INSERT INTO RANGE_PART1 VALUES (200, 'LG', '25-MAR-2021');     --UNDER P22     
INSERT INTO RANGE_PART1 VALUES (300, 'XIAOMI', '25-MAR-2023');   --UNDER P33
INSERT INTO RANGE_PART1 VALUES (400, 'REALME' , NULL);--UNDER P33

SELECT * FROM RANGE_PART1 PARTITION (P11);
SELECT * FROM RANGE_PART1 PARTITION (P22);
SELECT * FROM RANGE_PART1 PARTITION (P33);

SELECT * FROM RANGE_PART1 WHERE NAME = 'REALME';

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'RANGE_PART1' ;
--CHECK THE DICTIONATARY TABLE OF PARTITON TABLE .

--DROP A PARTITION :
--=====================
--IF WE DROP A PARTITION THEN THE UNDERLYING (UNDER PARTITION VALUES )DATA ALSO DROPPED.

--SYNTAX :
--===========
--ALTER TABLE < TABLE_NAME > DROP PARTITION < PARTITION_NAME >;

ALTER TABLE RANGE_PART1 DROP PARTITION P33;
--HERE WE DROPPED A PARTITION .
--ALSO UNDER THOSE PARTITION WHICH DATA WILL BE STORED THAN THIS DATA WILL BE REMOVED FROM BASE TABLE .

SELECT * FROM RANGE_PART1;

--RANGE INTERVAL PARTITION :
--===========================
--IT SUPPORTS ORACLE 11g ONWARDS.
--IF WE PROVIDE RANGE WITH INTERVAL THEN IT WILL CREATE AUTOMATICALLY NEW PARTITION BASED UPON EXISTING RANGE /
--                                                                            INTRVAL VALUE.
--IT SPECIFY TO OVERCOME THE LIMITATION OF MAXVALUE.

--RESTRICTION IN RANGE INTERVAL PARTITION :
--==========================================
--INTERVAL SUPPORT ONLY IN RANGE PARTITION .
--IT SUPPORT ONLY SINGLE COLUMN.
--WHICH TABLE APPLY IOT THEN WE CAN'T APPLY INTERVAL THERE .
--WE CANT APPLY INTERVAL OVER A SUB-PARTITION.
--WHEN WE APPLY INTERVAL THEN WE CAN'T SPECIFY MAXVALUE THERE.
--IN INTERVAL NULL VALUES ARE NOT ALLOW.

CREATE TABLE INT_RANGE (ID NUMBER , DOP DATE )
          PARTITION BY RANGE (ID)
          INTERVAL (5)
          (PARTITION P11 VALUES LESS THAN (10),
          PARTITION P22 VALUES LESS THAN (MAXVALUE));--ERROR
--WHEN WE SPECIFY INTRVAL THEN WE CAN'T SPECIFY MAXVALUE .

CREATE TABLE RANGE_PART_INT (ID INT , NAME VARCHAR2(10))
            PARTITION BY RANGE (ID)
            INTERVAL (5)
        (PARTITION P1 VALUES LESS THAN (10),
        PARTITION P2 VALUES LESS THAN (20));
--CREATE TABLE WITH INTERVAL RANGE PARTITION


INSERT INTO RANGE_PART_INT VALUES (1, 'A');--P1
INSERT INTO RANGE_PART_INT VALUES (9, 'B');--P1
INSERT INTO RANGE_PART_INT VALUES(15, 'C');--P2
INSERT INTO RANGE_PART_INT VALUES(20, 'D');--SYS_P21
--HERE BY DEFAULT TAKE RANGE AND CREATE A PARTITION AND STORED DATA AUTOMATICALLY.
INSERT INTO RANGE_PART_INT VALUES(NULL, 'E');--ERROR
--IF WE SPECIFY INTERVAL WITH RANGE THEN WE CAN'T INSERT NULL ON PARTITION KEY.
INSERT INTO RANGE_PART_INT VALUES(100, 'F');--SYS_P22
INSERT INTO RANGE_PART_INT VALUES(50, 'G');--SYS_P23
--RANGE WISE IT WILL CREATE A NEW PARTITION .

SELECT * FROM SYS.USER_TAB_PARTITIONS WHERE TABLE_NAME = 'RANGE_PART_INT';
--HERE WE CHECK RANGE AND INTERVAL = 'YES'

SELECT * FROM SYS.USER_PART_TABLES WHERE TABLE_NAME = 'RANGE_PART_INT';
--HERE WE CHECK THE INTRVAL VALUE .

CREATE TABLE RANGE_PART11 (PRODUCT INT , NAME VARCHAR2(10), DOP DATE)
              PARTITION BY RANGE (DOP)
              INTERVAL ( NUMTOYMINTERVAL (1, 'MONTH'))
          (PARTITION P1 VALUES LESS THAN ('01-JAN-2022'));
          
INSERT INTO RANGE_PART11 VALUES (100, 'SAMSUNG','02-DEC-2021' );--P1
INSERT INTO RANGE_PART11 VALUES (200, 'LG', '26-APR-2022');--UNDER NEW PARTITION (SYS_P41)
INSERT INTO RANGE_PART11 VALUES (300, 'XIAOMI', '29-APR-2022');--UNDER SYS_P41.
INSERT INTO RANGE_PART11 VALUES (400, 'RELAME', '1-MAR-2022');--UNDER NEW PARTITION (SYS_P42)
INSERT INTO RANGE_PART11 VALUES (500, 'MICROMAX', NULL);--ERROR
--WE CANT TAKE NULL VALUE IN INTERVAL WITH RANGE PARTITION .

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'RANGE_PART11';
--HERE WE FIND ALL DETIALS OF ABOVE PARTITION.

SELECT * FROM USER_PART_TABLES WHERE TABLE_NAME = 'RANGE_PART11';

CREATE TABLE RANGE_PART111 (PRODUCT INT , NAME VARCHAR2(10), DOP DATE)
              PARTITION BY RANGE (DOP)
              INTERVAL ( NUMTOYMINTERVAL (1, 'YEAR'))
          (PARTITION P1 VALUES LESS THAN ('10-JAN-2022'));
          
INSERT INTO RANGE_PART111 VALUES (1, 'A', '9-JAN-22');--UNDER P1
INSERT INTO RANGE_PART111 VALUES (2, 'B', '1-APR-29');--UNDER NEW PARTITION (SYS_P43)

SELECT * FROM RANGE_PART111;

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'RANGE_PART111';
--HERE WE SEE 1YEAR RANGE VALUES MAKE A NEW PARTITION.

CREATE TABLE RANGE_PART12 (ID INT, DOP DATE)
        PARTITION BY RANGE (DOP)
        INTERVAL (NUMTODSINTERVAL (2, 'DAY'))
    (PARTITION P1 VALUES LESS THAN ('10-MAR-2022'));

INSERT INTO RANGE_PART12 VALUES (1, '1-MAR-22');--UNDER P1 VALUES 
INSERT INTO RANGE_PART12 VALUES (2, '15-MAR-22');--UNDER SYS_P45
INSERT INTO RANGE_PART12 VALUES (2, '13-MAR-22');--UNDER SYS_P44.
--HERE DAY WISE PARTITION CHANGE.

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'RANGE_PART12';

CREATE TABLE RANGE_PART13 (ID INT, DOP TIMESTAMP)
        PARTITION BY RANGE (DOP)
        INTERVAL (NUMTODSINTERVAL (2, 'HOUR'))
    (PARTITION P1 VALUES LESS THAN ('12-SEP-22 06.54.49'));

INSERT INTO RANGE_PART13 VALUES (1, '12-SEP-22 04.54.49')  ;--UNDER P1
INSERT INTO RANGE_PART13 VALUES (2, '12-SEP-22 9.54.49')  ;--UNDER NEW PARTITION
--HERE AFTER PER 2 HOUR ONE PARTITION WILL BE CREATED.

SELECT * FROM RANGE_PART13;
SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'RANGE_PART13';
--HERE WE SEE IN HIGH VALUE COLUMN RANGES .

--2.HASH PARTITION :
--==================
--IN HASH PARTITION ORACLE AUTOMATIC CREATE PARTITION.
--WE CAN'T ASSURE THAT DATA WILL RESIDE IN WHICH PARTITION.
--THERE IS NO CONFUSION OF DATA INSERTION.
--IT WILL HELP TO INSERT FASTER .
--WHEN WE RETRIVE A SINGLE VALUE IN HASH PARTITION ONLY THOSE TIME THIS PARTITION WILL BE FASTER .
--IT WILL NOT ACCEPT ANY RANGE OF VALUES .

CREATE TABLE DEPT_HASH (DEPTNO INT, DNAME VARCHAR2(10))
          PARTITION BY HASH (DEPTNO) 
          PARTITIONS 4;

INSERT INTO DEPT_HASH VALUES (10, 'A');          
INSERT INTO DEPT_HASH VALUES (50, 'A');          
INSERT INTO DEPT_HASH VALUES (30, 'A');          
INSERT INTO DEPT_HASH VALUES (20, 'A');     
INSERT INTO DEPT_HASH VALUES (NULL, 'A');        
INSERT INTO DEPT_HASH VALUES (500, 'A');      
INSERT INTO DEPT_HASH VALUES (5000, 'A'); 
--HERE ALL DATA DIVIDE IN PARTITION RANDOMLY.

SELECT * FROM DEPT_HASH;

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'DEPT_HASH';
--HERE WE SEE ORACLE CREATE BY DEFAULT PARTITION NAME .

SELECT * FROM DEPT_HASH PARTITION (SYS_P47);
SELECT * FROM DEPT_HASH PARTITION (SYS_P48);
SELECT * FROM DEPT_HASH PARTITION (SYS_P49);
SELECT * FROM DEPT_HASH PARTITION (SYS_P50);
--HERE DIVIDE ALL DATA RANDOMLY IN PARTITIONS.

INSERT INTO DEPT_HASH PARTITION (SYS_P50) VALUES (6000, 'Z');
--HERE WE CAN'T INSERT VALUE IN A INDIVIDUAL PARTITION.

SELECT COUNT(*) FROM DEPT_HASH PARTITION (SYS_P48);
--COUNT THE INDIVIDUAL PARTITION RECORD AVAILABLE .

CREATE TABLE DEPT_HASH2 (ID INT )
        PARTITION BY HASH (ID)
    ( PARTITION P1, PARTITION P2, PARTITION P3, PARTITION P4 );        
    
INSERT INTO DEPT_HASH2 VALUES (10);    
INSERT INTO DEPT_HASH2 VALUES (100);    
INSERT INTO DEPT_HASH2 VALUES (1000);    
INSERT INTO DEPT_HASH2 VALUES (101);    
INSERT INTO DEPT_HASH2 VALUES (1001);    
INSERT INTO DEPT_HASH2 VALUES (90);    

SELECT * FROM DEPT_HASH2 ;

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'DEPT_HASH2';
--HERE  ALL DATA STORED IN SPECIFIED PARTITIONS (P1, P2, P3, P4)

SELECT * FROM DEPT_HASH2 PARTITION(P1);
SELECT * FROM DEPT_HASH2 PARTITION(P2);
SELECT * FROM DEPT_HASH2 PARTITION(P3);
SELECT * FROM DEPT_HASH2 PARTITION(P4);
--HERE WE SEE THE DATA .(WHICH VALUES ARE IN WHICH PARTITION )

--3.LIST PARTITION :
--=====================
--IT IS USED TO LIST TOGETHER UNRELATED DATA INTO PARTITIONS .
--AND REST OF THE VALUES WILL STORE UNDER DEFAULT.
--WHEN WE SPECIFY MAXVALUE IN LIST PARTITION IT WILL BE DISPLAY ERROR , COZ MAXVALUE ONLY SUPPORT IN RANGE 
--                                                                                        PARTITION.
--LIST PARTITIONS SUPPORT ALPHA NUMBERIC VALUES .

CREATE TABLE SALES_BY_REGION (DEPTNO INT, DNAME VARCHAR2 (10), QTRLY_SALES NUMBER (10,2), STATE CHAR(2))
                PARTITION BY LIST (STATE)
        (PARTITION NORTHZONE VALUES ('JK', 'HP', 'UP'),
        PARTITION EASTZONE VALUES ('OR', 'WB', 'BI'),
        PARTITION WESTZONE VALUES ('MH', 'RJ'),
        PARTITION SOUTHZONE VALUES ('AP', 'TN'),
        PARTITION NORTHEAST VALUES (DEFAULT));
--HERE WE CREATE STATE WISE PARTITION .

INSERT INTO SALES_BY_REGION VALUES (10, 'A', 10000,'JK' );
INSERT INTO SALES_BY_REGION VALUES (10, 'A', 10000,'RJ' );
INSERT INTO SALES_BY_REGION VALUES (10, 'A', 10000,'AP' );
INSERT INTO SALES_BY_REGION VALUES (10, 'A', 10000,'TS' );
INSERT INTO SALES_BY_REGION VALUES (10, 'A', 10000,NULL );
--HERE NULL UNDER DEFAULT PARTITIONS.

SELECT * FROM SALES_BY_REGION;

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'SALES_BY_REGION';

SELECT * FROM SALES_BY_REGION PARTITION(NORTHEAST);
SELECT * FROM SALES_BY_REGION PARTITION(SOUTHZONE);
SELECT * FROM SALES_BY_REGION PARTITION(WESTZONE);
SELECT * FROM SALES_BY_REGION PARTITION(EASTZONE);
SELECT * FROM SALES_BY_REGION PARTITION(NORTHZONE);

CREATE TABLE DEPT_PART_LIST (DEPTNO INT , DNAME CHAR )
          PARTITION BY LIST (DEPTNO)
      (PARTITION D10 VALUES (10),
      PARTITION D20 VALUES (20),
      PARTITION D30 VALUES (30),
      PARTITION D40 VALUES (40),
      PARTITION D_NOT_LISTED VALUES (DEFAULT));
      
INSERT INTO DEPT_PART_LIST VALUES (10, 'A');
INSERT INTO DEPT_PART_LIST VALUES (20, 'D');
INSERT INTO DEPT_PART_LIST VALUES (30, 'S');
INSERT INTO DEPT_PART_LIST VALUES (10 , 'W');
INSERT INTO DEPT_PART_LIST VALUES(NULL, 'S');

SELECT * FROM DEPT_PART_LIST;

SELECT * FROM DEPT_PART_LIST PARTITION(D10);
SELECT * FROM DEPT_PART_LIST PARTITION(D20);
SELECT * FROM DEPT_PART_LIST PARTITION (D30);
SELECT * FROM DEPT_PART_LIST PARTITION (D40);
SELECT * FROM DEPT_PART_LIST PARTITION (D_NOT_LISTED);
--HERE WE CHECK INDIVIDUALLY ALL RECORD IN PARTITIONS.

--COMPOSITE PARTITION :
--=======================
--IF WE WANT APPLY PARTITION MORE THAN ONE COLUMN THEN WE CAN TAKE COMPOSITE PARTITION.
--HERE WE CREATE A SUB-PARTITION UNDER A PARTITION.

--    SUPPORT                                           UNSUPPORT
--================                                    ==============
--RANGE = RANGE, LIST, HASH                          -- HASH = RANGE, LIST, HASH.
--LIST = RANGE, LIST, HASH.
--INTERVAL = HASH, LIST, RANGE.
CREATE TABLE EMP_PART (DEPTNO INT, HIREDATE DATE )
                  PARTITION BY RANGE (HIREDATE)
                      SUBPARTITION BY LIST (DEPTNO)
            (PARTITION P1 VALUES LESS THAN ('01-JAN-1980')
                  (SUBPARTITION SP1 VALUES (10),
                  SUBPARTITION SP2 VALUES (20)),
              PARTITION P2 VALUES LESS THAN ('01-JAN-1985')
                  (SUBPARTITION SP21 VALUES(10),
                  SUBPARTITION SP22 VALUES (20)),
              PARTITION P3 VALUES LESS THAN (MAXVALUE)
                  (SUBPARTITION SP3 VALUES (DEFAULT)));
                  
INSERT INTO EMP_PART SELECT DEPTNO , HIREDATE FROM EMP WHERE DEPTNO IN (10,20);

SELECT * FROM EMP_PART;

SELECT * FROM EMP_PART PARTITION(P1);
SELECT * FROM EMP_PART PARTITION(P2);
SELECT * FROM EMP_PART PARTITION(P3);
--HERE WE SEE ALL PARTITION DATA IN INDIVIDUAL PARTITION.

SELECT * FROM EMP_PART SUBPARTITION (SP21);
SELECT * FROM EMP_PART SUBPARTITION (SP22);
SELECT * FROM EMP_PART SUBPARTITION (SP3);
--HERE WE SEE ALL SUB-PARTITION DATA IN INDIVIDUAL SUB-PARTITION .

DROP TABLE COM_PAR PURGE;
CREATE TABLE COM_PAR (ID INT , DOJ DATE)
      PARTITION BY RANGE (DOJ)
      SUBPARTITION BY HASH (ID) 
          SUBPARTITIONS 2
          (PARTITION P11 VALUES LESS THAN ('01-JAN-2022'),
          PARTITION P22 VALUES LESS THAN ('01-FEB-2022'),
          PARTITION P33 VALUES LESS THAN ('01-MAR-2022'),
          PARTITION P44 VALUES LESS THAN (MAXVALUE));

INSERT INTO COM_PAR VALUES (10, '10-JAN-2022');
INSERT INTO COM_PAR VALUES (20, '15-JAN-2022');
INSERT INTO COM_PAR VALUES (10, '10-FEB-2022');
INSERT INTO COM_PAR VALUES (30, '10-MAR-2022');

SELECT * FROM COM_PAR PARTITION (P11);
SELECT * FROM COM_PAR PARTITION (P22);
SELECT * FROM COM_PAR PARTITION (P33);
SELECT * FROM COM_PAR PARTITION (P44);

SELECT * FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'COM_PAR';
--DETAILS OF ALL PARTITION OF ABOVE TABLE .

SELECT * FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME = 'COM_PAR';
--DETAILS OF ALL SUBPARTITIONS OF ABOVE TABLE .

SELECT * FROM SYS.USER_SUBPART_KEY_COLUMNS WHERE NAME = 'COM_PAR';
--HERE WE FIND WHICH COLUMN WILL BE PART OF SUBPARTITION.

--ADD A PARTITION ON A EXISTING TABLE :
--======================================
CREATE TABLE PAR_CHK (ID INT , DOP DATE )
          PARTITION BY RANGE (DOP)
          SUBPARTITION BY LIST (ID)
      (PARTITION P1 VALUES LESS THAN ('01-JAN-2020')
            (SUBPARTITION SP1 VALUES (10)),
      PARTITION P2 VALUES LESS THAN ('01-FEB-2020')
            (SUBPARTITION SP2 VALUES (20)));

INSERT INTO PAR_CHK VALUES (10, '01-JAN-1999')            ;
INSERT INTO PAR_CHK VALUES (20, '15-JAN-2020');
INSERT INTO PAR_CHK VALUES (10, '01-JAN-2024');--ERROR
-- PARTITION OUT OF RANGE .

ALTER TABLE PAR_CHK ADD PARTITION P3 VALUES LESS THAN (MAXVALUE);
--WE ALTER THE PARTITION 

INSERT INTO PAR_CHK VALUES (10, '01-JAN-2024');
--NOW THIS VALUE WILL BE ACCEPTED 

INSERT INTO PAR_CHK VALUES (50, '05-AUG-2512');
--HERE IT WILL TAKE COZ COMPOSITE RULE SAY IF ONE CONDITION IS SATISFIED THEN IT WILL TAKE .

ALTER TABLE PAR_CHK MODIFY PARTITION P3 ADD SUBPARTITION SP5 VALUES (100);
--HERE WE ADD SUBPARTITION UNDER A PARTITION .
--BUT HERE WE CAN'T SPECIFY COZ DEFAULT OPTION ARE THERE IN SUBPARTITION .

/
--==============================================================================================================
--SQL LOADER :
--==============
--IT IS A UTILITY OR PROCESS WHERE WE CAN IMPORT(LOAD) DATA FROM FLAT FILE TO DATBASE.
--TO PERFORM SQL LOADER REQUIRE AT LEAST 3 STEPS :
--    STEP-1
--    ========
--      * GET THE FLAT FILE FROM CLIENT AND STORE IN A LOCAL DRIVE.
--      * THIS FLAT FILE FORMAT CAN BE .TXT OR .CSV (COMMA SEPARATED VALUE)
--    STEP-2
--    ========
--      * CREATE A CONTROL FILE WITH HAVING INFORMATION OF :
--          = FLATFILE.
--          = DATABASE TABLE AND SAVE IT IN A LOCATION AS .CTL FILE .
--      * THIS CONTROL FILE MEDIATOR BETWEEN FLATFILE AND DATABASE.
--    STEP-3
--    ========
--      * OPEN COMMAND PROMPT (CMD) AND EXECUTE THE CONTROL FILE.

--NOTE BY NIEL :
--===============
--SQL LOADER IS A UTILITY / PROCESS FILE.
--EXTENSION OF SQL LOADER IS SQLLDR.EXE
--USING CONTROL FILE WE CAN IMPORT DATA FROM FLAT FILE TO DATABASE.
--EXTENSION OF CONTROL FILE = .CTL
--WHERE DATA WILL BE COLLECT FROM A CLIENT AND STORED A FILE THIS FILE CALLED AS A FLAT FILE.
--EXTENSION OF FLAT FILE IS .TXT OR .CSV
--FLAT FILE DIVIDED 2 TYPES :
--    1. VARIABLE RECORD FLATFILE :- IF BETWEEN DATA USING ELIMINATOR {(,) (#) ($)}
--    2. FIXED RECORD FLATFILE :- IF THERE IS NO ELIMINATOR BETWEEN DATA (EG.. 100ABC20)

--LOG FILE (.LOG)
--=================
--IT IS USED TO STORE THE LOG INFOMATION OF SQL LOADER ACTIVITY.
--IT STORES THE INFORMATION SUCH AS : DATA LOADED SUCESSFULLY OR NOT.
--                                    EXECUTION TIME.
--                                    WHAT ARE THE ERROR.
--                                    WHICH TIME HAS BEEN LOADED.
--                                    HOW MANY RECORD ARE LOADED OR REJECTED.
--LOGFILE CREATE SAME AS CONTROL FILE NAME AUTOMATICALLY.

--BADFILE (.BAD) :-
--=====================
--BADFILE IS USED TO STORE BUSINESS RULE VIOLATION DATA (CONSTRAINT VIOLATION & DATATYPE MISMATCH)
--BADFILE AUTOMATICALLY CREATE IN THE NAME OF CONTROLFILE .
--BAD FILE ALWAYS STORE THE LATEST MISMATCH INFORMATION (IT REPLACE THE OLD BADFILE TO NEW BADFILE ).

/
CREATE TABLE EMP_LOADER (EMPNO INT, ENAME VARCHAR2(10), SAL INT, DEPTNO INT);

SELECT * FROM EMP_LOADER;
--TABLE IS BLANK

--CREATE A FLATFILE ON NOTEPAD (EMP_LOADER.TXT)
--================================================
--ALL RECORDS RECIEVED FROM CLIENT.

--    1,SCOTT,1000,10
--    2,SMITH,2000,20
--    3,ALLEN,3000,30
--    4,JONES,4000,10
--    5,KING,5000,10

--NOTE:
--=======
--WHILE LOADING DATA FROM FLATFILE TO DATABASE WE CAN PERFORM INSERT , APPEND, TRUNCATE, REPLACE .

--CREATE A CONTROL FILE ON NOTEPAD (EMP_LOADER_CONTROL.CTL) (INSERT)
--====================================================================
--IN INSERT ONLY ONE TIME RECORDS WILL BE INSERTED.
--IF WE WANT INSERT 2nd TIME THEN WE NEED TO TRUNCATE THE TABLE THEN WE CAN BE INSERT 
--WE CAN SAY WHEN WE 2nd TIME EXECUTE INSERT ,IT IS POSSIBLE WHEN TABLE MUST BE EMPTY.

--SYNTAX :
--===========
--      LOAD DATA 
--      INFILE '< FLATFILE PATH>'
--      INSERT INTO TABLE <DATABASE_TABLE_NAME >
--      FIELDS TERMINATED BY '< ELIMINATOR BETWEEN DATA IN FLATFILE>'
--      (COLUMNS OF DATABASE TABLE)

LOAD DATA 
INFILE 'C:\NIEL\EMP_LOADER.TXT'
INSERT INTO TABLE EMP_LOADER
FIELDS TERMINATED BY ','
(EMPNO, ENAME, SAL, DEPTNO)
--THIS ONE WE CREATE IN NOTEPAD AND EXTENSION OF THIS NOTEPAD IS .CTL

--EXECUTE CONTROLFILE IN COMMAND PROMPT(CMD):
--=============================================
--SYNTAX:
--=========
--      SQLLDR <USER_ID> / <PASSWORD> 
--      CONTROL = <CONTROL FILE PATH> \<CONTROL_FILE_NAME >.CTL 
--      LOG = <PATH WHERE WE WANT TO STORE > \ <NAME WHICH IS SAVED LOG FILE>. LOG

C:\Users\DELL>SQLLDR SCOTT/imniel99 CONTROL =C:\NIEL\EMP_LOADER_CONTROL.CTL LOG = C:\NIEL\EMPLOADER_LOG.LOG
--THIS SYNTAX WE RUN IN CMD AND AFTER THAT AUTOMATIC LOG FILE WILL BE CREATED .

SELECT * FROM EMP_LOADER;
--AFTER THAT ALL DATA OF FLAT FILE COPY TO DATABASE.

--IF WE AGAIN INSERT THEN WHAT HAPPEN :
--=======================================

C:\Users\DELL>SQLLDR SCOTT/imniel99 CONTROL =C:\NIEL\EMP_LOADER_CONTROL.CTL LOG = C:\NIEL\EMPLOADER_LOG.LOG--ERROR
--IN INSERT ONLY ONE TIME RECORD WILL BE INSERTED .
--IF WE SPECIFY INSERT AGAIN THEN DISPLAY ERROR,
--SO WE TRUNCATE DATABASE THEN WE CAN INSERT AGAIN.

CREATE TABLE EMPLDR2 (ID INT, NAME CHAR);
--HERE WE CREATE A TABLE .

--IMPORT DATA USING CSV FORMAT :
--===============================
    1	M
    2	F
    3	M

--CREATE A CONTROL FILE USING CSV FORAMT :
--==========================================
LOAD DATA 
INFILE 'C:\NIEL\EMPLDR2.CSV'
INSERT INTO TABLE EMPLDR2
FIELDS TERMINATED BY ','
(ID,NAME)

--EXECUTE CONTROL FILE IN CMD :
--==============================
C:\Users\DELL>SQLLDR SCOTT/imniel99 CONTROL= C:\NIEL\EMPLDR2.CTL LOG=C:\NIEL\EMPLDR2LG.LOG

--APPEND :
--=============
--IT WILL IN APPEND A NEW RECORD WILL BE INSERTED IF EXIST RECORD ARE THERE / AVAILABLE.
/
SELECT * FROM EMP_LOADER;
--HERE RECORDS ARE EXIST .

1,SCOTT,1000,10
2,SMITH,2000,20
3,ALLEN,3000,30
4,JONES,4000,10
5,KING,5000,10
6,NIEL, 10000 ,30

LOAD DATA 
INFILE 'C:\NIEL\EMP_LOADER.TXT'
APPEND INTO TABLE EMP_LOADER
FIELDS TERMINATED BY ','
(EMPNO, ENAME, SAL, DEPTNO)
--here we specify insert rows over a exist record .

C:\Users\DELL>SQLLDR SCOTT/imniel99 control = C:\NIEL\emp_loader_control.ctl log = C:\NIEL\empldrlg.log
/
select * from emp_loader;
--here we see old data with new data.

--TRUNCATE :
--===========
--IT WILL REMOVE DATA ALL THE EXISTING RECORD AND LOAD LATEST RECORD

1,SCOTT,1000,10
2,SMITH,2000,20
3,ALLEN,3000,30
4,JONES,4000,10
5,KING,5000,10
6,NIEL, 10000 ,30

LOAD DATA 
INFILE 'C:\NIEL\EMP_LOADER.TXT'
TRUNCATE INTO TABLE EMP_LOADER
FIELDS TERMINATED BY ','
(EMPNO, ENAME, SAL, DEPTNO)

C:\Users\DELL>sqlldr scott/imniel99 control = C:\NIEL\emp_loader_control.ctl log = C:\NIEL\empldrlg.log
--HERE ALL DATA OF DATABASE ARE REMOVED AND AGAIN RELOAD IN DATABASE
/
select * from emp_loader;

--WE CAN ALSO SPECIFY FLATFILE RECORDS IN CONTROLFILE USING *
--=============================================================
--HERE WE USE * AFTER THE INFILE
--WE MUST SPECIFY BEGINDATA AFTER THE SPECIFY COLUMN NAME .
--WHEN WE APPLY RECORD IN CONTROL FILE THEN THOSE TIME FLAT FILE NOT REQUIRED.

LOAD DATA 
INFILE *
TRUNCATE INTO TABLE EMP_LOADER
FIELDS TERMINATED BY ','
(EMPNO, ENAME , SAL, DEPTNO)
BEGINDATA
1,SCOTT,1000,10
2,SMITH,2000,20
3,ALLEN,3000,30
4, NIEL, 55, 20

C:\Users\DELL>sqlldr scott/imniel99 control = C:\NIEL\emp_loader_control.ctl log = C:\NIEL\empldrlg.log
/
SELECT * FROM EMP_LOADER;
--HERE WE SEE THE SAME RECORDS WHICH WE ARE SPECIFY IN THE END OF CONTROL FILE.

--REPLACE :
--===========
--IN REPLACE IT REPLACE ALL EXISTING DATA AND LOAD LATEST DATA .
--WHEN WE RETRIEVE DATABASE THEN THOSE TIME ONLY LATEST DATA WILL BE DISPLAY EXISTING ALL DATA WILL BE REPLACED.

LOAD DATA 
INFILE *
REPLACE INTO TABLE EMP_LOADER
FIELDS TERMINATED BY ','
(EMPNO, ENAME , SAL, DEPTNO)
BEGINDATA
8,ABC, 20,60

C:\Users\DELL>sqlldr scott/imniel99 control = C:\NIEL\emp_loader_control.ctl log = C:\NIEL\empldrlg.log

/
--WE CAN ALSO INSERT USING MULTIPLE FLATFILE TO DATABASE :
--=========================================================
--FLATFILE 1:(CSV)
--============
7369	SMITH	800	20
7499	ALLEN	1600	30
7521	WARD	1250	30

--FLATFILE 2:(NOTEPAD)
--===========
10, niel, 500, 10

LOAD DATA 
INFILE 'C:\NIEL\export.csv'
INFILE 'C:\NIEL\emp_loader.txt'
TRUNCATE INTO TABLE EMP_LOADER
FIELDS TERMINATED BY ','
(EMPNO, ENAME , SAL, DEPTNO)
--HERE WE SPECIFY BOTH FLATFILE IN INFILE .

C:\Users\DELL>sqlldr scott/imniel99 control=C:\NIEL\emp_loader_control.ctl log=C:\NIEL\empldrlg.log

/
--DISCARD FILE : (.DSC)
--===============
--IT IS USED TO STORED THE DATA WHICH IS NOT SATISFY WITH WHEN CONDITION.
--APART FROM  THE WHEN CONDITION DATA WILL GO TO DISCARD FILE.
--MANUALLY WE HAVE TO PROVIDE THE DISCARD FILE PATH.
--ALWAYS WE SPECIFY DISCARDFILE IN CONTRL FILE.
--WE ALSO LOAD DATA TO DATABASE USING DISCARDFILE.

CREATE TABLE LOADER (ID INT , NAME VARCHAR2(5), DEPTNO INT);

1,NIEL,10
2,NIEL,20
3,NIEL,30

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
DISCARDFILE 'C:\NIEL\LOADER\LOADERDSC.DSC'
TRUNCATE INTO TABLE LOADER
WHEN DEPTNO = '10'
FIELDS TERMINATED BY ","
(ID,NAME,DEPTNO)
--HERE SPECIFY DISCARD FILE WHICH RECORD ARE NOT SATISFY IN WHEN CONDITION THIS RECORD ARE STORED IN DISCARDFILE

C:\Users\DELL>SQLLDR SCOTT/imniel99 CONTROL = C:\NIEL\LOADER\LOADERCTL.CTL LOG=C:\NIEL\LOADER\LOADERLG.LOG
--AFTER THAT HERE ONLY WHEN COND. SATISFY RECORD WILL BE INSERT IN DATABASE REST ALL ARE IN DISCARDFILE

/
LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
DISCARDFILE 'C:\NIEL\LOADER\LOADERDSC.DSC'
TRUNCATE INTO TABLE LOADER
WHEN DEPTNO <> '30'
FIELDS TERMINATED BY ","
(ID,NAME,DEPTNO)
--WE CAN ALSO USING ^= , <>, != IN WHEN CONDITION .

C:\Users\DELL>SQLLDR SCOTT/imniel99 CONTROL = C:\NIEL\LOADER\LOADERCTL.CTL LOG=C:\NIEL\LOADER\LOADERLG.LOG

/
SELECT * FROM LOADER;
/
--NOTE :
--=========
--WE CAN ALSO TAKE THE COLUMNS IN CONTROLFILE AS PER OUR CHOICE AND THE COLUMN SEQUENCE IS NOT MANDATORY WITH
--                                                                                  TABLE COLUMN.
--BUT THE DATA PRESENT IN DATA IN FLATFILE SHOULD SAME WITH CONTROLFILE SEQUENCE .
--DATATYPE SHOULD MATCH WHEN WE CHNGE THE SEQUENCE .
--BUT THIS IS FOR INTERVIRW QUESTION PURPOSE , IN REAL TIME IF WE CHANGE THE SEQUENCE THEN DATA WILL BE MISMATCH.

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
DISCARDFILE 'C:\NIEL\LOADER\LOADERDSC.DSC'
TRUNCATE INTO TABLE LOADER
WHEN DEPTNO <> '30'
FIELDS TERMINATED BY ","
(DEPTNO,NAME,ID)
--HERE SEQUENCE CHANGE BUT BOTH COLUMN DATATYPE SAME .

--TRAILING NULLCOLS :
--===========================
--THIS IS SPECIFY AFTER FIELD TERMINATED BY .
--IF THE LAST COLUMN IS NULL THEN THAT RECORD GOES TO BAD FILE.
--SO AVOID THIS WE CAN USE TRIALING NULLCOLS.
--TRAILING NULLCOLS ONLY USED FOR LAST COLUMN IF LAST COLUMN IS NULL .
--IN FLATFILE AT MID ,1ST COLUMN IS NULL THEN THOSE TIME NOT REQUIRED TRAILING NULLCOLS.

1,,10
2,,20
3,NIEL,30

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID,NAME,DEPTNO)
--IN FLATFILE AT MID ,1ST COLUMN IS NULL THEN THOSE TIME NOT REQUIRED TRAILING NULLCOLS.

C:\Users\DELL>sqlldr scott/imniel99 control = C:\NIEL\LOADER\loaderctl.ctl log = C:\NIEL\LOADER\loaderlg.log
/
select * from loader;
/
1,,
2,,
3,NIEL,30
--HERE LAST COLUMN WITH BEFORE LAST COLUMN IS NULL SO HERE MANDATORY OF TRAILING NULLCOLS.

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
TRAILING NULLCOLS
(ID,NAME,DEPTNO)

C:\Users\DELL>sqlldr scott/imniel99 control = C:\NIEL\LOADER\loaderctl.ctl log = C:\NIEL\LOADER\loaderlg.log
/
SELECT * FROM LOADER;

--CONSTANT :
--===============
--IT IS A SQL LOADER CLAUSE.
--IF I WANT TO PROVIDE A DEFAULT VALUE TO A COLUMN WHICH IS NOT AVAILABLE IN FLATFILE / DATAFILE , THOSE TIME 
--                                                                WE SPECIFY CONSTANT.
--WE CAN SAY DEFAULT CONSTRAINT = CONSTANT IN SQL LOADER.

1,NIEL,
2,NITITN,

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID , NAME , DEPTNO CONSTANT '100')
--HERE CONSTANT VALUE IS 100 THEN THOSE COLUMN STORED DATA FROM DEFAULT VALUE.
/
SELECT * FROM LOADER;
DESC LOADER;
/
1, NIEL,
2, A, 
3, ,

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID , NAME CONSTANT aHA , DEPTNO CONSTANT 100)
--IF WE SPECIFY CONSTANT IN A COLUMN THOSE TIME THIS COLUMN HAVE VALUE OR NULL IT WILL LOAD ONLY CONSTANT VALUE 
--                                                                                  IN THAT COLUMN.

C:\Users\DELL>sqlldr scott/imniel99 control = C:\NIEL\LOADER\loaderctl.ctl log = C:\NIEL\LOADER\loaderlg.log
/
ALTER TABLE LOADER ADD  LOCATION VARCHAR2(10);
--HERE WE ADD A COLUMN IN EXISTING TABLE .

SELECT * FROM LOADER;

1,A,10,
2,B,20,

LOAD DATA
INFILE 'C:\NIEL\LOADER\LOADER.TXT'
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID , NAME , DEPTNO , LOCATION CONSTANT HYD)
--HERE WE SPECIFY CONSTANT ON NEW COLUMN.
/

--FILLER :
--==========
--I WANT TO SKIP A COLUMN IN DATAFILE AND LOAD OTHER COLUMN DATA THAT TIME FILLER IS REQUIRED .
--WHICH COLUMN WE SPECIFY FILLER THAT WHOLE COLUMN VALUE WILL BE DISPLAY NULL.
--IF WE USING FILLER ON A COLUMN  AND THIS COLUMN ALSO HAVE DEFAULT CONSTRAINT THEN IT WILL STORED DEFAULT VALUE.

LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID ,NAME ,DEPTNO FILLER , LOC)
BEGINDATA 
1,A,10,HYD
2,B,20,MUM
--HERE WE TAKE DEPTNO AS FILLER SO AFTER EXECUTE THIS COLUMN VALUES ARE DISPLAY AS NULL.
/
ALTER TABLE LOADER MODIFY NAME DEFAULT   'NIEL';
--HERE MODIFY NAME COLUMN AS DEFAULT AS NIEL.

LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID ,NAME FILLER,DEPTNO  , LOC)
BEGINDATA 
1,A,10,HYD
2,B,20,MUM
--HERE NAME HAS DEFAULT CONSTRAINT  SO AFTER FILLER IT WILL STORED DEFAULT DATA.
/
SELECT * FROM LOADER ;

--THERE ARE 2 MODES TO LOAD DATA IN SQL LOADER  :
--=================================================
--            1.CONVENTIONAL PATH MODE
--            2.DIRECT PATH MODE

--1.CONVENTIONAL PATH MODE
--============================
--IN THIS MODE THE DATA LOADS IN THE TRADITIONAL WAY .
--MEANS THE LOADING IS SECURE & DATA CAN BE RECOVER .

--2.DIRECT PATH MODE
--====================
--IN THIS MODE WE CAN LOAD DATA IN FASTER WAY & THIS PROCESS IS BIT UNSECURE.
--THE DATA LOSSES IT CAN'T BE RESECURE/ RECOVER

--USES OF SINGLE ROW FUNCTION IN SQL LOADER :
--=============================================
--WE CAN USE ONLY SQL SINGLE ROW FUNCTION TO COVERT DATA & LOAD.
--IT CAN BE APPLIED ON CONTROL FILE .
--FUNCTIONS ARE UNDER <"   ">.
--AFTER FUNCTION  WE SPECIFY < : > AND THIS IS MANDATORY.
-- WE CAN SAY < : > IS OPERATOR.

LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID ,NAME ,DEPTNO "DECODE (:DEPTNO, 10, 100,20, 200)", LOC)
BEGINDATA 
1,A,10,HYD
2,B,20,MUM
3,C,30, BAN
--HERE WE SPECIFY IF DEPTNO =10 THEN 100 IF 20 THEN 200
/
CREATE TABLE LOADER (ID INT, NAME VARCHAR2(10), GENDER CHAR, DEPT VARCHAR2(10));

LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID ,NAME ,GENDER , DEPT "DECODE (:DEPT, 10, 'ACCOUNT', 20, 'RESERACH', 'OUT')")
BEGINDATA 
1,A,M,10
2,B,F,20
3,C,F,30
--DEPT IS DECODED
/
SELECT * FROM LOADER ;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID ,NAME "DECODE(:NAME , 'A', 'KATIKI', 'B', 'PANEER', 'CHILLI')" ,
GENDER "CASE :GENDER WHEN 'M' THEN 'MALE' WHEN 'F' THEN 'FEMALE' END", DEPT )
BEGINDATA 
1,A,M,10
2,B,F,20
3,C,F,30
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID, NAME "INITCAP(:NAME )", GENDER ,DEPT)
BEGINDATA
1,JF,M,10
2,SDF,D,20
3,DS,E,30
--INITCAP FUNCTION
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID, NAME "SUBSTR (:NAME,1,1)", GENDER ,DEPT)
BEGINDATA
1,JF,M,10
2,SDF,D,20
3,DS,E,30
--USING SUBSTR

--WE CAN ALSO USE TO_DATE CONVERSION FUNCTION IN SQL LOADER :
--=============================================================
--HERE SAME AS SINGLE ROW FUNCTION RULES.
--AFTER LOAD DATA IT WILL STORE DATA AS DEFAULT DATE FORMAT .
/
CREATE TABLE LOADER (ID INT,  JOIN DATE);
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID,JOIN "TO_DATE (:JOIN, 'DDMMYY')")
BEGINDATA
1,200222
2,010423
3,290199
--HERE WE LOAD DATE IN BASETABLE USING SQL LOADER SINGLE ROW FUNCTION.
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID,JOIN "TO_DATE (:JOIN, 'MM-DD-YY')")
BEGINDATA
1,02-15-22
--HERE WE LOAD IF DATE FORMAT CHANGE .
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID,JOIN "TO_DATE (:JOIN, 'MON-DD-YYYY')")
BEGINDATA
1,FEB-15-1999
--HERE DATE FORMAT IS 'MON-DD-YYYY' BUT IT WILL STORE IN DATABASE AS THEIR OWN FORMAT 'DD-MON-YY'
/
SELECT * FROM LOADER;
/
--OPTIONALLY ENCLOSED BY :
--===========================
--IT IS A CLAUSE OF SQL LOADER .
--WE CAN REMOVE ANY CHARACTER WHICH IS OPTIONALLY ENCLOSED BY (SYMBOL HAVING STARING POINT TO ENDING POINT) 
--IT IS SPECIFY AFTER FIELDS TERMINATED BY.
--WE CAN APPLY OPTIONALLY ENCLOSED BY FOR A SINGLE SYMBOL / CHARACTER ONLY ONCE IN THE CONTROL FILE.
CREATE TABLE LOADER (ID INT, NAME VARCHAR2(10));
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
OPTIONALLY ENCLOSED BY "'"
(ID,NAME)
BEGINDATA
1, 'NIEL'
2, 'NITIN'
--HERE WE REMOVE THE ' FROM NAME USING OPTIONALLY ENCLOSED.
/
SELECT * FROM LOADER ;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
OPTIONALLY ENCLOSED BY '"'
(ID,NAME)
BEGINDATA
1, "NIEL"
2, "NITIN"
--SAME AS WE REMOVED " FROM NAME USING OPTINALLY ENCLOSED CLAUSE.
/
SELECT * FROM LOADER ;
ALTER TABLE LOADER ADD GENDER CHAR;
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
OPTIONALLY ENCLOSED BY ('"')("'")
(ID,NAME, GENDER)
BEGINDATA
1, "NIEL", 'M'
2, "NITIN", 'F'--ERROR
--WE CAN'T REMOVE MULTIPLE SYMBOL AT A TIME .
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
OPTIONALLY ENCLOSED BY '$'
(ID,NAME, GENDER)
BEGINDATA
1, $NIEL$, M
2, $NITIN$, M
--WE CAN ALSO REMOVE ANY SYMBOL USING OPTIONALLY ENCLOSED BY.
/
SELECT * FROM LOADER; 
/
--REMOVE THE DIFFERENT DELIMITERS IN SQL LOADER :
--================================================
--IT IS A CLAUSE OF A SQL LOADER.
--WE CAN REMOVE THE DIFFERENT DELIMITERS BY DIFFERENT COLUMNS BY PROVIDING TERMINATED BY CLAUSE ON EACH COLUMN.
--IF WHEN A COLUMN AT LAST ANY SYMBOL STORE THEN WE APPLY TERMINATED BY AFTER THIS COLUMN NAME .
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID,NAME TERMINATED BY '*', GENDER TERMINATED BY "&")
BEGINDATA
1,NIEL*B&
2,NITIN*C&
--HERE WE TERMINATE MULTIPLE COLUMN SYMBOLS.
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID TERMINATED BY '#', NAME TERMINATED BY '@', GENDER )
BEGINDATA 
1#NIEL SAHU@G
2#NITIN@H
--HERE ALSO WE REMOVED ALL SYMBOL OF ALL COLUMN.
/
SELECT * FROM LOADER;
/
--USES OF SEQUENCE IN SQL LOADER :
--====================================
--WE CAN USE A SEQUENCE IN A CONTROL FILE TO AUTOMATIC GENERATE A UNIQUE NO.
--SYNTAX :
--===========
--  <COLUMN_NAME> " < SEQUENCE_NAME >. <NEXTVAL> "

CREATE SEQUENCE LOADER_SQ ;
--HERE WE CREATE A SEQUENCE 

LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID "LOADER_SQ.NEXTVAL", NAME, GENDER)
BEGINDATA
,TOM,M
,JERRY,F
--HERE USING SEQUENCE WE INSERT DATA .
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ","
(ID "LOADER_SQ.NEXTVAL", NAME, GENDER "LOADER_SQ.CURRVAL")
BEGINDATA
,TOM,M
,JERRY,F
--HERE WE USE SEQUENCE IN MULTIPLE COLUMN .
/
SELECT * FROM LOADER;
/
--LOAD FIX LENGTH DATA FROM FLATFILE TO DATABASE
--=================================================
--IN FLATFILE IF THE DATA'S ARE AVAILABLE WITHOUT DELIMETER (,@ $...) & IN A CONSECUTIVE MANNER (100ABC20) THAT
--              TIME WE CAN SPECIFY POSITION OF CHARACTER & LOAD ACCORDINGLY .
--IN SQL LOADER THERE ARE 3 DATATYPE AVAILABLE :
--                                              1.INTEGER EXTERNAL
--                                              2.CHAR
--                                              3.DECIMAL EXTERNAL
--SYNTAX :
--=========
-- <COLUMN_NAME> POSITION ( < STARTING_POSITION : ENDING POSITION > )
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
(ID POSITION (01:02), NAME POSITION (03:06), GENDER POSITION(07))
BEGINDATA
11ABCDM
22VXYZF
--HERE POSITION WISE DATA WILL BE STORED IN DATABASE .
/
SELECT * FROM LOADER;
/
CREATE TABLE LOADER (ID INT , NAME VARCHAR2(10), JOIN DATE);

LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
(ID POSITION (01:02), NAME POSITION (03:05), 
JOIN POSITION(06:11) "TO_DATE(:JOIN , 'DDMMYY')" )
BEGINDATA
11ABC200225
22PQR261099
--HERE WE CAN ALSO SPECIFY DATE WITH LOAD FIX DATA AND SINGLE ROW FUNCTION.

--SKIP :
--=============
--WHEN WE SKIP NO. OF RECORDS FROM FLATFILE THEN THOSE TIME SKIP REQUIRE IN SQL LOADER.
--IT IS ALWAYS SKIP FROM TOP TO BOTTOM.
--THIS CLAUSE WE SPECIFY BOTH IN COMMAND PROMPT AND CONTROL FILE ALSO.
--BUT WHEN WE SPECIFY SKIP CLAUSE IN CONTROL FILE THEN MANDATORY TO TAKE OPTIONS AND IT PLACED AT 1st OF 
--                                                                                    CONTROL FILE
--SYNTAX:
--==========
--OPTIONS (SKIP =2)
--WHEN SPECIFY SKIP IN COMMAND PROMPT THEN SKIP POSITION AT LAST .
--IT IS USEFUL WHEN SKIP HEADER OF FLATFILE .

OPTIONS (SKIP =1)
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ','
(ID , NAME , JOIN "TO_DATE (:JOIN , 'DDMMYY')")
BEGINDATA
ID,NAME,DOB
1,NIEL,261099
2,JERRY,200299
--HERE WE SKIP 1ST ROW OF FLATFILE .
--AND SAME AS WE SKIP N NO. OF RECORD FROM TOP.
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ','
(ID , NAME , JOIN "TO_DATE (:JOIN , 'DDMMYY')")
BEGINDATA
ID,NAME,DOB
1,NIEL,261099
2,JERRY,200299

C:\Users\DELL>sqlldr scott/imniel99 control=C:\NIEL\LOADER\loaderctl.ctl log=C:\NIEL\LOADER\loaderlg.log SKIP =1
--HERE WE CAN SPECIFY SKIP IN COMMAND PROMPT AND THAT IS POSSIBLE .
/
SELECT * FROM LOADER;
/
--LOAD :
--=========
--WHEN WE LOAD NO. OF RECORDS FROM FLATFILE THEN THOSE TIME LOAD REQUIRE IN SQL LOADER.
--IT IS ALWAYS LOAD FROM TOP TO BOTTOM.
--THIS CLAUSE WE SPECIFY BOTH IN COMMAND PROMPT AND CONTROL FILE ALSO.
--BUT WHEN WE SPECIFY LOAD CLAUSE IN CONTROL FILE THEN MANDATORY TO TAKE OPTIONS AND IT PLACED AT 1st OF 
--                                                                                    CONTROL FILE
--SYNTAX:
--==========
--OPTIONS (LOAD =2)
--WHEN SPECIFY LOAD IN COMMAND PROMPT THEN LOAD POSITION AT LAST .

OPTIONS (LOAD=2)
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ','
(ID , NAME , JOIN "TO_DATE (:JOIN , 'DDMMYY')")
BEGINDATA
1,NIEL,261099
2,JERRY,200299
3,D,261099
--HERE WE SPECIFY LOAD =2 SO, HERE LOAD DATA FROM TOP TO BOTTOM.
/
SELECT * FROM LOADER;
/
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ','
(ID , NAME , JOIN "TO_DATE (:JOIN , 'DDMMYY')")
BEGINDATA
1,NIEL,261099
2,JERRY,200299
3,D,261099
--HERE DON'T SPECIFY LOAD

C:\Users\DELL>sqlldr scott/imniel99 control=C:\NIEL\LOADER\loaderctl.ctl log=C:\NIEL\LOADER\loaderlg.log  LOAD =1
--HERE WE SPECIFY LOAD =1 IN CMD , SO HERE ALSO SAME WORK DONE .
/
SELECT * FROM LOADER;
/
--WE CAN SPECIFY BOTH LOAD & SKIP AT A TIME :
--=============================================
C:\Users\DELL>sqlldr scott/imniel99 control=C:\NIEL\LOADER\loaderctl.ctl log=C:\NIEL\LOADER\loaderlg.log
SKIP=1  LOAD =1
/--OR

OPTIONS(LOAD =2, SKIP =1)
LOAD DATA
INFILE *
TRUNCATE INTO TABLE LOADER
FIELDS TERMINATED BY ','
(ID , NAME , JOIN "TO_DATE (:JOIN , 'DDMMYY')")
BEGINDATA
1,NIEL,261099
2,JERRY,200299
3,D,261099

--                                    THANK YOU
--==============================================================================================================
--==============================================================================================================
/
--EXTERNAL TABLE :
--===================
--IT IS A TABLE BUT THIS TABLE DOES NOT STORE ANY DATA INSIDE OF A TABLE BUT THE DATA WILL BE STORED IN 
--                                                                      THE FORM OF FLAT FILE
--WE LOAD THE DATA IN TABLE THROUGH GIVEN THE FLAT FILE PATH. 
--IF WE LOADING FILE FREQUENTLY THEN WE WILL USE EXTERNAL TABLE 
--DATA WILL BE LOAD TEMPORALLY
--IF WE ERASE THE DATA FROM FLAT FILE AUTOMATICALLY DATA WILL REMOVE FROM THE EXTERNAL TABLE.

--NOTE BY NIEL:
--=================
--WE CANT TRUNCATE A EXTERNAL TABLE .
--WE CAN'T COMMENT TO A EXTERNAL TABLE .
--WE CAN DROP A EXTRENAL TABLE .
--WE CAN RENAME A EXTERNAL TABLE.
--WE CAN ADDING COLUMN ON A EXISTING EXTERNAL TABLE.
--WE CAN DROPING COLUMN ON A EXISTING TABLE .
--IF WE DROP A EXTERNAL TABLE THEN IT WILL DOESN'T STORE IN RECYCLEBIN
--OVER A EXTERNAL TABLE WE CANT APPLY PARTITION 
--FIELDS : THIS IS ONLY USED FOR FIXED LENGTH IN SQL_LOADER

/
--INTERVIEW QUESTION :
--======================
--DIFFERENCE BETWEEN SQL LOADER & EXTERNAL TABLE :
--==================================================
--                          SQL LOADER                                      EXTERNAL TABLE 
--                         ==============                                 ===================
--1.THIS IS USED FOR DATA LOADING FROM FLATFILE           1.THIS IS USED TO POINT A DATA TO A TABLE VICE-VERSA.
--    TO TABLE.
--2.WE REQUIRED CONTROL FILE & LOADING UTILITIES          2.CONTROL FILE & LOADING UTILITIES IS NOT REQUIRED. 
--     TO COMPLETE .
--3.IT STORES DATA PERMANENTLY.                           3.IT DOESN'T STORE DATA PERMANENTLY.
--4.IT IS A AUTO COMMIT.                                  4.THERE IS A NO COMMIT IS REQUIRED .
--5.IT IS SLOWER.                                         5.IT IS FASTER.
--6.DML OPERATION IS ALLOWED .                            6.DML OPERATION IS NOT ALLOWED HERE .
--7.CONSTRAINT , VIEW , MATERIALIZED VIEW, INDEX          7.CONSTRAINT , INDEX WE CAN'T APPLY , BUT WE CAN CREATE 
--      ARE ALLOWED.                                         VIEW , MATERIALIZED VIEW , SYNONYM.
--8.FLATFILE : CONTROL FILE : TABLE : REPORT :CLIENT.     8.FLATFILE : TABLE : REPORT : CLIENT

/
--NOTE BY SIR :
--===============
--WE CAN USE EXTERNAL TABLE FOR IMPORT & EXPORT DATA.
--FOR IMPORT WE CAN USE ORACLE_LOADER.
--FOR EXPORT WE CAN USE ORACLE_DATAPUMP.
--BY DEFAULT EXTERNAL TABLE TAKES ORACLE_LOADER.
--IT IS SIMILAR TO SQL LOADER LIKE FLAT FILE, BAD FILE, LOG FILE, DISCARD FILE.
--DML OPERATION NOT ALLOWED IN EXTERNAL TABLE.
--ALTER WE CAN PERFORM ON EXTERNAL TABLE.
--WE CAN CREATE VIEW, MATERIALIZED VIEW, SYNONYM BASED ON A EXTERNAL TABLE.

/
--STEPS TO PERFORM IN EXTERNAL TABLE :
--=====================================
--STEP:1
--======
--WE NEED TO CREATE A DIRECTORY IN ORACLE .
--HERE DIRECTORY IS A INTERMEDIATE BETWEEN OS AND ORACLE DATABASE.
--FOR CREATING A DIRECTORY WE REQUIRED PERMISSION FROM DBA.
  GRANT CREATE ANY DIRECTORY TO < USER >.
  
--SYNTAX :
--==========
--CREATE OR REPLACE DIRECTORY < DIRECTORY_NAME > AS < LOCATION_PATH >

--STEP:2
--===========
--CREATE A FOLDER IN OS OF THE MENTION DIRECTORY PATH / LOCATION PATH.

--STEP:3
--=========
--CREATE OR PLACE A FLATFILE IN A MENTIONED DIRECTORY.

--STEP:4 
--=========
--CREATE A EXTERNAL TABLE BASED UPON SOME PARAMETER.

--SYNTAX:
--===========
--    CREATE TABLE < TABLE_NAME > ( < COLUMN_NAME > < DATATYPE > )
--                 ORGANIZATION EXTERNAL
--                 TYPE (ORACLE_LOADER / ORACLE_DATA PUMP)   --DEFAULT : ORACLE_LOADER
--           (     DEFAULT DIRECTORY < DIRECTORY_NAME >
--                ACCESS PARAMETERS
--             (
--                RECORDS DELIMITED BY ','
--                BADFILE <   >
--                DISCARDFILE <   >
--                LOGFILE <   >
--                READSIZE < BYTES >
--                SKIP < NO. OF ROWS >
--                FIELDS TERMINATED BY ','
--                OPTIONALLY ENCLOSED BY "'"
--                MISSING FIELD VALUES ARE NULL 
--                REJECT ROWS WITH ALL NULL FIELDS 
--             )
--              LOCATION ( FLATFILE_NAME ))
--              PARALLEL 5
--              REJECT LIMIT < INTEGER / UNLIMITED > ;    --DEFAULT :0
--           
/
--CREATE A DIRECTORY :
--=======================
CREATE OR REPLACE DIRECTORY DIR1  AS 'C:\NIEL\DIRECTORY\DIR1';--ERROR
--INSUFFICIENT PRIVILIGES.

GRANT CREATE ANY DIRECTORY TO SCOTT;--DBA

CREATE OR REPLACE DIRECTORY DIR1  AS 'C:\NIEL\DIRECTORY\DIR1';
--HERE WE CREATE A DIRECTORY WITH PATH .

--CREATE A EXTERNAL TABLE USING FIELD TERMINATED BY :
--=======================================================
--FIELDS TERMINATED BY :
--========================
--IT TERMINATED RECORD WISE RECORD.

CREATE TABLE EMP_EXT (EMPNO NUMBER , NAME VARCHAR2(10), SAL NUMBER )
      ORGANIZATION EXTERNAL 
      ( TYPE ORACLE_LOADER      --(THIS ONE OPTIONALLY, IF WE DON'T SPECIFY BY DEFAULY TAKE ORACLE_LOADER.) 
      DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (
                          FIELDS TERMINATED BY ','
                          )
      LOCATION ('ABC.TXT'));
DROP TABLE EMP_EXT PURGE;
SELECT * FROM EMP_EXT;--ERROR
--FLATFILE DOESN'T FIND.

1234,NIEL,1000
1495,JERRY, 2000
--CREATE A FLAT FILE 

--THEN AGAIN :
SELECT * FROM EMP_EXT;
-- WHEN WE EXECUTE SELECT STATEMENT THOSE AUTOMATIC A LOG FILE CREATE ON GIVEN LOCATION .

1234,NIEL,1000
1495,JERRY, 2000
5655, NITIN , 475
--SOME CHANGING IN FLAT FILE

SELECT * FROM EMP_EXT;
--HERE CHANGING VALUES ARE ALSO DISPLAY (AUTO-SYNC)

1234,NIEL,1000
1495,JERRY, 2000
5655, NITIN , 475
5985, D, HYD
--HERE ONE DATA HAVE DATATYPE MISMATCH.

SELECT * FROM EMP_EXT;--ERROR
--WE DON'T SPECIFY REJECT LIMIT SO HERE OP WILL BE DISPLAY AS ERROR .
--AND SAME TIME THIS RECORD WILL BE MOVED TO BAD FILE AND THIS BAD FILE AUTO CREATE .

--WE CAN CREATE MULTIPLE EXTERNAL TABLE ON ONE FLATFILE :
--==========================================================
CREATE TABLE EMP_EXT_CHK (ENO NUMBER, NAME VARCHAR2(10), SAL NUMBER )
        ORGANIZATION EXTERNAL
        (DEFAULT DIRECTORY DIR1
        ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
        LOCATION ('ABC.TXT'));
--WE CAN ALSO CREATE MULTIPLE EXTERNAL TABLE USING ONE FLAT FILE.

SELECT * FROM EMP_EXT_CHK;
--HERE AUTOMATIC  DISPLAY FLATFILE DATA (AUTO-SYNC).

/
DROP TABLE EMP_EXT PURGE;
/
--WE CAN LOAD DATA FROM A SPECIFIC DIRECTORY :
--==============================================
--I HAVE 2 FLAT FILE IN DIR1 DIRECTORY.

CREATE TABLE EMP_EXT (ID INT, NAME CHAR)
    ORGANIZATION EXTERNAL
        (DEFAULT DIRECTORY DIR1
            ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
          LOCATION (DIR1:'PQR.TXT'));

1	A
2	B
3	C

SELECT * FROM EMP_EXT;          
/  
CREATE TABLE EMP_EXT (ID INT , NAME CHAR)
    ORGANIZATION EXTERNAL
      (DEFAULT DIRECTORY DIR1
          ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
        LOCATION (DIR2:'EXPORT.CSV'))
        REJECT LIMIT UNLIMITED;

7782	A
7839	S
7934	D
/
SELECT * FROM EMP_EXT;
--WE CAN ALSO SPECIFY ONE DIRECTORY AND IN LOCATION WE SPECIFY ANOTHER DIRECTORY .(IT IS POSSIBLE)

CREATE DIRECTORY DIR2 AS 'C:\NIEL\DIRECTORY\DIR2';
--HERE WE CREATE A ANOTHER DIRECTORY

CREATE TABLE EMP_EXT (ID NUMBER, NAME VARCHAR2(10), SAL NUMBER)
      ORGANIZATION EXTERNAL 
     ( 
      DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS 
          ( 
            FIELDS TERMINATED BY ','
          )
        LOCATION ('ABC.TXT', DIR2: 'EXPORT.CSV' )
      );
--HERE WE CREATE A EXTERNAL TABLE WITH MULTIPLE FLATFILE .
--WHEN WE SPECIFY MULTIPLE FLATFILE THEN 2nd FLATFILE FOLDER NAME AND FLATFILE NAME SPECIFY LOACTION .

SELECT * FROM EMP_EXT;
--HERE WE SEE BOTH FLATFILE DATA IN THIS TABLE .

DROP TABLE EMP_EXT PURGE;

--RECORDS DELIMITED BY : 
--========================
--THE DELIMITED BY CLAUSE IS USED TO CHARACTER THAT IDENTITY THE END OF RECORD .
--IF WE SPECIFY DELIMITED BY NEWLINE THEN IT LOOK LINE BY LINE AND THIS IS BY DEFAULT.
--IF WE SPECIFY BOTH FIELD TERMINATED BY AND RECORDS DELIMITED BY THEN ALWAYS 1st SPECIFY DELIMITED THEN FIELD 
--                                                                                      TERMINATED.

CREATE TABLE EMP_EXT (ID NUMBER , NAME VARCHAR2(10), SAL NUMBER)
    ORGANIZATION EXTERNAL
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (RECORDS DELIMITED BY ';'
                        FIELDS TERMINATED BY ',')
                LOCATION ('ABC.TXT'));

1,A,10;2,B,20;3,C,30;

SELECT * FROM EMP_EXT;    

DROP TABLE EMP_EXT;

CREATE TABLE EMP_EXT (ID INT , ENAME VARCHAR2 (10), SAL INT)
      ORGANIZATION EXTERNAL
      (DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                          FIELDS TERMINATED BY ','
                          )
                  LOCATION ('ABC.TXT'));

1,A,100
2,B,200
3,C,300
--FLAT FILE 

SELECT * FROM EMP_EXT;                  

DROP TABLE EMP_EXT PURGE;

CREATE TABLE EMP_EXT (ID INT, NAME CHAR, SAL INT)
    ORGANIZATION EXTERNAL 
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
        LOCATION ('ABC.TXT'));
--HERE WE DON'T TAKE RECORD DELIMITED THEN IT ALSO TAKE COZ , THIS ONE IS BY DEFAULT.

1,A,100
2,B,200
3,C,300
--FLAT FILE 

SELECT * FROM EMP_EXT;        

/
DROP TABLE EMP_EXT;
/
--REJECT LIMIT :
--=================
--IF ANY DATATYPE MISMATCH BETWEEN DATABASE AND FLATFILE THEN THIS TIME COUNT AS A REJECT RECORD OR 
--                                                THIS RECORD WILL BE MOVED TO BADFILE.
--DEFAULT REJECT LIMIT IS 0.
--HERE WE SPECIFY A INTEGER OR UNLIMITED FOR REJECT .

CREATE TABLE EMP_EXT (ID INT, NAME CHAR, SAL INT)
    ORGANIZATION EXTERNAL
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
    LOCATION ('ABC.TXT'))
    REJECT LIMIT 2;
--HERE WE SPECIFY REJECT LIMIT 2 .

1,A,100
2,B,200
3,C,300
4,D,NIEL
--HERE 4th RECORD DATATYPE WILL BE MISMATCH SO THIS ONE MOVE TO BAD FILE 
SELECT * FROM EMP_EXT; 

DROP TABLE EMP_EXT;
/
CREATE TABLE EMP_EXT (ID INT, NAME CHAR, SAL INT)
    ORGANIZATION EXTERNAL 
    (DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
      LOCATION ('ABC.TXT'))
      REJECT LIMIT 2;

1,A,100
2,B,200
3,C,300
4,D,NIEL
5,E,NITITN
6,F, MUKESH

SELECT * FROM EMP_EXT;--ERROR
--COZ WE TAKE REJECT LIMIT 2 BUT HERE REJECT RECORD IS MORE THAN 2 .
/
DROP TABLE EMP_EXT;
/
CREATE TABLE EMP_EXT(ID INT , NAME CHAR, GENDER CHAR)
      ORGANIZATION EXTERNAL 
          (DEFAULT DIRECTORY DIR1
          ACCESS PARAMETERS (FIELDS TERMINATED BY ',')
              LOCATION ('ABC.TXT'))
REJECT LIMIT UNLIMITED;

D,A,1
A,B,2
3,C,3
S,5,S
--HERE 3 RECORD DATA WILL BE MISMATCH SO THOSE 3 RECORD ARE STORED IN BADFILE COZ, WE SPECIFY REJECT UNLIMITED. 
/
SELECT * FROM EMP_EXT;
/
DROP TABLE EMP_EXT;
/
--SKIP RECORDS /HEADER :
--========================
--BY DEFAULT SKIP IS 0
--IT WAS SPECIFY BEFORE FIELD TERMINATED BY AND AFTER READSIZE.
--IF WE SPECIFY SKIP THEN MANDATORY TO SPECIFY RECORDS DELIMITED BY CLAUSE

CREATE TABLE EMP_EXT (ID INT , NAME CHAR)
    ORGANIZATION EXTERNAL
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                        SKIP 1
                        FIELDS TERMINATED BY ',')
              LOCATION ('ABC.TXT'));
--HERE WE CAN SKIP 1st LINE OF FLAT FILE .

EMPNO,ENAME (ALL DEATILS OF EMP)
10,N
20,N
/
SELECT * FROM EMP_EXT;
/
DROP TABLE EMP_EXT PURGE;
/
CREATE TABLE EMP_EXT (ID INT, NAME CHAR)
    ORGANIZATION EXTERNAL 
        (DEFAULT DIRECTORY DIR1
            ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE 
                                SKIP 2
                                FIELDS TERMINATED BY ',')
              LOCATION ('ABC.TXT'));
--HERE WE SPECIFIED 2 LINES SKIP FROM FLATFILE.

EMPNO,ENAME 
--***** ******
10    ,A
20    ,B

SELECT * FROM EMP_EXT;              
/
DROP TABLE EMP_EXT PURGE;
/
--OPTIOANALLY ENCLOSED BY :
--===========================
--WE CAN REMOVE ANY CHARACTER WHICH IS OPTIONALLY ENCLOSED BY (SYMBOL HAVING STARING POINT TO ENDING POINT) 
--ALWAYS OPTIONALLY ENCLOSED USED AFTER FIELD TERMINATED BY 
CREATE TABLE EMP_EXT (ID INT , NAME VARCHAR2(10))
    ORGANIZATION EXTERNAL 
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE 
                        SKIP 2
                        FIELDS TERMINATED BY ','
                        OPTIONALLY ENCLOSED BY "'"
                        )
                LOCATION ('ABC.TXT'));
--HERE WE SPECIFY OPTIONALYY ENCLOSED BY WITH SKIP 2 , SKIP 2 RECORDS AND REMOVE THE '' FROM VALUES HERE 

ALL DEATILS OF EMP
EMPNO , ENAME 
'14', 'NIEL'
'99', 'NITIN'
--FLATFILE 

SELECT * FROM EMP_EXT;
/
DROP TABLE EMP_EXT PURGE;
/
--MISSING FIELDS VALUES ARE NULL:
--======================================
--IF WE SPECIFY ONLY  "MISSING FIELDS VALUES ARE NULL" THEN IT DISPLAY ALL VALUES WHICH RECORD HAVE 
--                                                                                        NULL OR NOTNULL
--IF WE DON'T SPECIFY ONLY  "MISSING FIELDS VALUES ARE NULL" THEN SAME WORK DONE.

CREATE TABLE EMP_EXT (ID INT , NAME VARCHAR2(10), SAL INT)
      ORGANIZATION EXTERNAL
      (DEFAULT DIRECTORY DIR1
          ACCESS PARAMETERS ( RECORDS DELIMITED BY NEWLINE 
                              FIELDS TERMINATED BY ',' )
            LOCATION ('ABC.TXT'));

1234,NIEL,
4578, NITIN,
5454, djs,
--FLATFILE 

SELECT * FROM EMP_EXT;                  
--HERE AUTOMATIC LAST COLUMN SHOW AS NULL BUT IF WE COMPARE TO SQL LOADER THERE MANDATORY FOR TRAILING NULLCOLS.

DROP TABLE EMP_EXT PURGE;
/
CREATE TABLE EMP_EXT (ID INT , NAME VARCHAR2 (10), SAL INT)
      ORGANIZATION EXTERNAL 
      (DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                          FIELDS TERMINATED BY ','
                          MISSING FIELD VALUES ARE NULL)
                LOCATION ('ABC.TXT'));

1234,,250
4578,,10
5454,,143
--HERE WE 2ND COLUMN ARE NULL .

SELECT * FROM EMP_EXT;                
1234		250
4578		10
5454		143
--2ND COLUMN DISPLAY NULL.
/
DROP TABLE EMP_EXT PURGE;
/
CREATE TABLE EMP_EXT (ID INT, NAME VARCHAR2(10), SAL INT )
      ORGANIZATION EXTERNAL 
      (DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE 
                          FIELDS TERMINATED BY ',')
                LOCATION ('ABC.TXT'));
--HERE WE DON'T SPECIFY "MISSING FIELDS VALUES ARE NULL" BUT WORK AS SAME IF WE SPECIFY 
--                                                                  "MISSING FIELDS VALUES ARE NULL".

1234,,250
4578,,10
5454,,143
--2ND COLUMN VALUES ARE NULL.

SELECT * FROM EMP_EXT;                
/
DROP TABLE EMP_EXT PURGE;
/
CREATE TABLE EMP_EXT (ID INT, NAME VARCHAR2(10), SAL INT)
      ORGANIZATION EXTERNAL 
      (DEFAULT DIRECTORY DIR1 
      ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE 
                          SKIP =2
                          FIELDS TERMINATED BY ',')
                LOCATION ('ABC.TXT'));
--HERE WE DONT SPECIFY ANY NULL RELATED CLAUSE.

ALL DEATILS OF EMP
EMPNO , ENAME 
1,NIEL,
2,,10
,,
--FLATFILE

SELECT * FROM EMP_EXT;
1	NIEL	
2		10
		
--OP
--ALL NULL FIELDS ARE DISPLAY NULL.
/
DROP TABLE EMP_EXT PURGE;
/
--REJECT ROWS WITH ALL NULL FIELDS :
--==========================================
--IF WE SPECIFY ONLY "REJECT ROWS WITH ALL NULL FIELDS" THEN IT CONSIDER WHICH RECORD LAST VALUES ARE NOT NULL,
--     ONLY THOSE RECORDS WILL BE DISPLAY AND ANY RERCORD HAVE LAST VALUE IS NULL THEN IT WILL MOVED TO BADFILE.
--IF WE SPECIFY BOTH "REJECT ROWS WITH ALL NULL FIELDS", "MISSING FIELD VALUES ARE NULL" THEN
--        IT CONSIDER WHICH WHOLE RECORD VALUES HAVE NOT NULL ONLY THOSE RECORD WILL BE DISPLAY AND 
--        ANY RECORD OF ALL VALUES ARE NULL THEN IT DOESN'T DISPLAY ,IT WILL MOVED TO BADFILE.
CREATE TABLE EMP_EXT (ID INT, NAME VARCHAR2(10), SAL INT)
      ORGANIZATION EXTERNAL
      (DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                          SKIP = 2
                          FIELDS TERMINATED BY ','
                          REJECT ROWS WITH ALL NULL FIELDS)
                  LOCATION ('ABC.TXT'))
                  REJECT LIMIT UNLIMITED ;
--HERE WE ONLY SPECIFY "REJECT ROWS WITH ALL NULL FIELDS "    

ALL DEATILS OF EMP
EMPNO , ENAME 
1,NIEL,
2,,10
,,
--FLATFILE

SELECT * FROM EMP_EXT;

2		10
--HERE OP WHICH COLUMNS ARE LAST VALUES ARE NOT NULL ONLY THOSE VALUES ARE DISPLAY.
--REST ALL ARE MOVED TO BADFILE 

1,NIEL,
,,
--BADFILE
--WE SPECIFY "REJECT ROWS WITH ALL NULL FIELDS" SO HERE CHECK LAST VALUES ARE NULL OR NOTNULL
--IF ANY VALUES LAST COLUMN IS NULL THEN THIS RECORDS WILL BE MOVED TO BAD FILE.
/
DROP TABLE EMP_EXT PURGE;
/
CREATE TABLE EMP_EXT (ID INT , NAME VARCHAR2(10), SAL INT)
      ORGANIZATION EXTERNAL
      (DEFAULT DIRECTORY DIR1
      ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                          SKIP = 2
                          FIELDS TERMINATED BY ','
                          MISSING FIELD VALUES ARE NULL
                          REJECT ROWS WITH ALL NULL FIELDS)
                LOCATION ('ABC.TXT'))
                REJECT LIMIT UNLIMITED;
--HERE WE SPECIFY BOTH NULL CLAUSE.

ALL DEATILS OF EMP
EMPNO , ENAME 
1,NIEL,
2,,10
,,
,NIEL,
--FLATFILE
/
SELECT * FROM EMP_EXT;     
--HERE WE DISPLAY ONLY WHICH RECORD HAVE NOT NULL.
/
DROP TABLE EMP_EXT PURGE;
/
--WHEN CONDITION CHECK IN EXTERNAL TABLE :
--============================================
CREATE TABLE APP_DOCTOR (ID INT, AGE INT, EOR VARCHAR2(10))
    ORGANIZATION EXTERNAL
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE
                      LOAD WHEN EOR ='EOR'
                      LOGFILE  'NIEL.LOG'
                      BADFILE  'NIEL.BAD'
                      DISCARDFILE 'NIEL.DSC'
                      FIELDS (ID POSITION (1:9),
                              AGE POSITION (10:12),
                              EOR POSITION (13:15)
                              )
                              )
                  LOCATION ('ABC.TXT')
                  )
                  REJECT LIMIT UNLIMITED
                  PARALLEL 10;
--HERE WE SPECIFY WHEN CONDITON WITH BAD,LOG, DISCARDFILE , PARALLEL.
--FIELDS :THIS IS ONLY USED FOR FIXED LENGTH IN EXTERNAL TABLE (ORACLE_LOADER)
--PARALLEL : AT A TIME 5 PROCESSER WORK FOR THIS SYNTAX.

ABCDEFGHI121EOR
123456789021EOR
123456789021EOR
123456789021EOR
123456789021FER
123456789021FER
123456789021FER
asdfasfa9021ABC
asdfasfa9021ABC
555555555021EORasdfasdas
123456789021ABC
123456789021FER
123456789021EOR
123456789021EOR
123456789021EOR
--FLATFILE

SELECT * FROM APP_DOCTOR;
--HERE WHICH CONDITION ARE SATISFY THOSE VALUES ARE DISPLAY .
--WHICH DATA ARE DOESN'T MATCH DATATYPE OF DATABASE THOSE ARE UNDER BAD FILE.
--WHICH DATA ARE DOESN'T MATCH THE CONDITION THOSE ARE UNDER DISCARD FILE.

DROP TABLE APP_DOCTOR;
/
--PARALLEL :
--=============
--WHEN ORACLE RUN SQL STATEMENT IN PARALLEL , MULTIPLE PROCESSESS WORK TOGETHER AT A TIME.

--READSIZE :
--=============
--THIS CLAUSE IS USED FOR READ BYTES OF VALUES IN EXTERNAL TABLE .

--DICTIONARY TABLE OF EXTERNAL TABLE :
--=======================================
SELECT * FROM USER_EXTERNAL_TABLES;
--HERE WE CAN ACCESS :
--TABLE_NAME ,TYPE_OWNER (USER), TYPE_NAME, DIRECTORY, REJECT LIMIT, ACCESS PARAMETER

SELECT * FROM DICT WHERE TABLE_NAME LIKE 'USER_EXTERNAL%';

SELECT * FROM USER_EXTERNAL_LOCATIONS;
--HERE WE CHECK THE LOCATION OF A EXTERNAL TABLE.
--LIKE : TABLE_NAME , LOCATION, DIRECORY_NAME .

SELECT * FROM ALL_DIRECTORIES WHERE DIRECTORY_NAME = 'DIR1';
--HERE WE CHECK THE PATH OF A DIRECTORY.

/
--ORACLE DATA PUMP :
--===================
--BY USING ORACLE_DATAPUMP WE CAN LOAD DATA FROM DATABASE TO A FILE
--IT IS USED TO WORK AS A EXPORT ACTIVITY IN EXTERNAL TABLE.
--AFTER EXPORT, THE DUMP FILE CREATE AUTOMATIC IN GIVEN PATH 
--AND THIS IS NOT A HUMAN READABLE FORMAT.
--WE CAN ALSO READ A DUMP FILE WITH CREATE A TABLE USING DUMPFILE.
--SYNTAX :
--==========
--    CREATE TABLE <TABLE_NAME > 
--        ORGANIZATION EXTERNAL 
--          (TYPE <ORACLE_DATAPUMP>
--                 DEFAULT DIRECTORY < DIRECTORY_NAME >
--                  LOCATION ('<DATA_PUMP FILENAME>'))   --THIS DATAPUMP AUTOMATIC CREATE WE JUST SPECIFY THE NAME.
--        AS < SELECT STATEMENT >;

CREATE TABLE EMP_EXT (EMPNO INT , ENAME VARCHAR2(10), JOB VARCHAR2(10), MGR INT, HIREDATE DATE,SAL INT,
                                                                  COMM INT, DEPTNO INT)
    ORGANIZATION EXTERNAL 
    (DEFAULT DIRECTORY DIR1
    ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE 
                        SKIP = 1
                        FIELDS TERMINATED BY ',')
                LOCATION ('EMP.CSV'))
                REJECT LIMIT UNLIMITED;
--HERE WE CREATE A EXTERNAL TABLE OF EMP

SELECT * FROM EMP_EXT;                
/
CREATE TABLE EMP_EXT_DMP 
    ORGANIZATION EXTERNAL 
    (TYPE ORACLE_DATAPUMP
    DEFAULT DIRECTORY DIR1
    LOCATION ('ABC.DMP'))
    AS SELECT * FROM EMP_EXT;
--HERE WE CREATE A DATAPUMP OF EMP_EXT . 
--AFTER EXECUTE AUTOMATIC A DATAPUMP FILE CREATED AND THIS FILE WAS HUMAN NOT READABLE FORMAT.

SELECT * FROM EMP_EXT_DMP;
--DETAILD OF DUMP FILE.

/
CREATE TABLE EMP_EXT_DMP2
   (	"EMPNO" NUMBER(4,0), 
	"ENAME" VARCHAR2(10 BYTE), 
	"JOB" VARCHAR2(9 BYTE), 
	"MGR" NUMBER(4,0), 
	"HIREDATE" DATE, 
	"SAL" NUMBER(7,2), 
	"COMM" NUMBER(7,2), 
	"DEPTNO" NUMBER(2,0))
  ORGANIZATION EXTERNAL 
  (TYPE ORACLE_DATAPUMP
  DEFAULT DIRECTORY DIR1
  LOCATION ('ABC.DMP'));
--HERE WE CREATE A TABLE USING DUMP FILE .

  SELECT * FROM EMP_EXT_DMP2;
  
--                                          THANK YOU
--=============================================================================================================
/
--EXECUTE A FILE FROM OPERATING SYSTEM TO DATABASE
--==================================================
--WE CAN ALSO EXECUTE A FILE FROM OS TO SQL.

--STEPS :
--========
--  1.1ST WE CREATE A FILE WITH TAKE EXTENSION .TXT / .CSV / .SQL
--  2.THEN UNDER THIS FILE WE SPECIFY SOME SQL QUERY.
--  3.AFTER THAT COME TO DEVELOPER TOOL AND SPECIFY @ -- DRIVE WITH LOCATION -- FILE NAME 
--  4.AND AFTER EXECUTE THIS FORMAT WE DISPLAY THIS QUERY WHICH IS UNDER FILE.

--SYNTAX:
--========
--@ < DRIVE_WITH_LOCATION > / < FILE_NAME > ;
@C:\NIEL\NEW.SQL;
--HERE WE SEE THIS QUERY USING FILE.
--WE CAN ALSO USE EXTENSION OF THIS FILE IS .TXT, .CSV

--===============================================================================================================
--                                              THANK YOU
--===============================================================================================================
/
--GLOBAL TEMPORARY TABLE : (GTT)
--================================
--GTT IS A TEMPORARY TABLE THAT HOLDS DATA ONLY FOR THE DURATION OF A SESSION .
--IT ONLY SAVES DATA FOR THE SESSION & THE SAME DATA CAN'T BE QUERIED / DISPLAY BY OTHER USERS.
--BENEFITS OF GTT IS QUICKER DATA RETRIVAL.
--IT MEANS , DURING A SESSION WE CAN STORED DATA IN A TABULAR FORM IN THE TEMPORARY TABLE & ACCESS IT INSTANTLY
--                                                                           WHEN WE NEED IT.
--TABLE STRUCTURE CAN BE VIEWED BY OTHERS USERS.
--GTT HAVE ALL FEATURES OF NORMAL TABLE LIKE VIEW, MATERIALIZED VIEW, INDEX, TRIGGER, EXPLAIN PLAN...

--NOTE BY NIEL :
--================
--IF WE TRUNCATE THE TABLE THEN THIS WILL BE WORK FOR ONLY SAME SESSION NOT OTHERS SESSION.
--OVER A GTT WE CAN APPLY NOT NULL, UNIQUE, PRIMARY, DEFAULT, CHECK CONSTRAINT.
--OVER A GTT WE CAN'T APPLY FOREIGN KEY CONSTRAINT.
--IF WE USE MULTPLE SESSION FOR A SINGLE GTT AND BOTH GTT HAVE DATA THEN WE CAN'T DROP THAT TABLE IN ANY USER.
--WE CAN CREATE VIEW, MV, SYNONYM USING THIS GTT BUT WE CAN'T SEE THE DATA ON THIS OBJECTS.

--TYPES OF GTT :
--==============
--GTT ARE DIVIDED INTO 2 PARTS 
--      1.TRANSACTION SPECIFIC GTT (ON COMMIT DELETE ROWS)
--      2.SESSION SPECIFIC GTT (ON COMMIT PRESERVE ROWS)

--1.TRANSACTION SPECIFIC GTT (ON COMMIT DELETE ROWS)
--=====================================================
--IN TRANSACTION SPECIFIC GTT WHEN WE COMMIT THEN DELETE THE ALL RECORDS FROM TABLE.
--IN THIS GTT TABLE HAVE STORED DATA THEN WE CAN'T  DROP THIS TABLE, 1ST WE REMOVE THE DATA IN ALL SESSION THEN
--                                                                        WE DROP THE TABLE.

--SYNTAX :
--==========
--      CREATE GLOBAL TEMPORARY TABLE < TABLE_NAME > (< COLUMN_NAME > < DATATYPE >)
--      ON COMMIT DELETE ROWS;

CREATE GLOBAL TEMPORARY TABLE GTT1(ID INT)
      ON COMMIT DELETE ROWS;

SELECT * FROM GTT1;

INSERT INTO GTT1 VALUES (1);
INSERT INTO GTT1 VALUES (2);
INSERT INTO GTT1 VALUES (3);

SELECT * FROM GTT1;
--HERE WE DISPLAY INSERTED VALUES

SELECT * FROM GTT1;--ON SQL PLUS
--HERE NO RECORDS WILL BE DISPLAY
--BUT TABLE STRUCTURE WE SEE ON ANOTEHR SESSION.

INSERT INTO GTT1 VALUES (4);--SQL PLUS
INSERT INTO GTT1 VALUES (5);--SQL PLUS
--HERE WE INSERT 2 VALUES IN ANOTHER SESSION

SELECT * FROM GTT1;--SQL PLUS
--HERE ONLY THOSE RECORD WILL BE DISPLAY WHICH ARE WE INSERT ON SAME SESSION LIKE (4,5)

COMMIT;
--WE COMMIT THE SESSION

SELECT * FROM GTT1;
--AFTER COMMIT ALL THE DATA WILL BE TRUNCATE AUTOMATIC.(ON COMMIT DELETE ROWS)

COMMIT;--SQL PLUS
--THERE ALSO DATA WILL BE TRUNCATE AUTOMATIC;

SELECT * FROM GTT1;
--AGAIN WE INSERT DATA IN DEVELOPER TOOL.

SELECT * FROM GTT1;--SQLPLUS
--HERE WE INSERT DATA IN SQL PLUS

--NOW BOTH SESSION HAVE DATA

DROP TABLE GTT1;--ERROR
--IF WE USE MULTPLE SESSION FOR A SINGLE GTT THEN WE CAN'T DROP THAT TABLE IN ANY USER.

SELECT * FROM GTT1;
--HERE GTT WAS EMPTY COZ DROP IS A DDL COMMAND & IT IS A AUTO COMMIT.

/
--SESSION SPECIFIC GTT :
--========================
--IN SESSION GTT WHEN WE COMMIT THEN DATA STORED IN TABLE FOR PARTICULAR SESSION ONLY .
--AFTER THIS SESSION THIS DATA WILL BE REMOVED FROM TABLE .

--NOTE BY NIEL :
--================
--IN ON COMMIT PRESERVE ROWS DATA HAVE STORED BEFORE / AFTER COMMIT BUT, THIS NOT IN POSSIBLE IN ON COMMIT DELETE
--                                                                              ROWS.
--IF WE RELOGIN THIS SESSION THEN WE CAN'T DISPLAY THOSE DATA.
--IF HAVE ANY DATA ON THIS GTT THEN WE CAN'T DROP THE GTT , 1st TRUNCATE THE TABLE THEN WE DROP .
--WE CAN CREATE VIEW, MV, SYNONYM USING THIS GTT BUT HERE SAME WORK ALL OBJECTS AS THEIR PRINCIPLE.

--SYNTAX :
--==========
--CREATE GLOBAL TEMPORARY TABLE < TABLE_NAME > ( < COLUMN_NAME > < DATATYPE > )
--                    ON COMMIT PRESERVE ROWS.

CREATE GLOBAL TEMPORARY TABLE GTT2 (ID INT)
                    ON COMMIT PRESERVE ROWS;
                    
INSERT INTO GTT2 VALUES (1);                    
INSERT INTO GTT2 VALUES (2);                    
INSERT INTO GTT2 VALUES (3);                    

COMMIT;
--IN ON COMMIT PRESERVE ROWS DATA HAVE STORED BEFORE / AFTER COMMIT BUT, THIS NOT IN POSSIBLE IN ON COMMIT DELETE
--                                                                              ROWS.

SELECT * FROM GTT2;

SELECT * FROM GTT2;--SQLPLUS
--HERE CAN'T DISPLAY ANY RECORD COZ OF ANOTHER SESSION.

SQL> insert into gtt2 values (1);

--HERE WE INSERT DATA USING SQLPLUS
--BUT THIS DATA ONLY DISPLAY FOR THIS SESSION.

--DICTIONARY TABLE OF GTT:
--=========================
SELECT * FROM USER_TABLES WHERE TEMPORARY = 'Y';
--HERE WE CAN SEE THE ALL TEMPORARY TABLE IN SPECIFIC USER.

SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = 'TABLE' AND TEMPORARY ='Y' ;
--HERE ALSO WE SEE THE TEMPORARY TABLE IN OBJECTS.
--==========================================================================================================
--                                        THANK YOU
--===========================================================================================================

--WITH CALUSE :
--================
--IT WAS INTRODUCED IN ORACLE 9i.
--WE CAN ALSO CALLED WITH CLAUSE IS A COMMON TABLE EXPRESSION(CTE) OR SUB QUERY FACTORING.
--WITH CLAUSE IS USED TO REDUCE THE REPETATION & SIMPLIFY SQL STATEMENT .
--IT WAS A PERFORMANCE ENHANCER.
--ADVANTAGE OF WITH CLAUSE WE CAN HANDLE COMPLEX QUERY 
--WITH CLAUSE ONLY USED FOR DATA FETCHING & PERFORMANCE ENHANCEMENT.
--WE CAN TAKE N. NO. OF QUERY STORED IN WITH CLAUSE .

--SYNTAX :
--==========
--    WITH < QUERY_NAME > AS 
--    (SQL QUERY )
--    SELECT * FROM QUERY_NAME;

WITH NIEL AS (SELECT * FROM EMP)
SELECT * FROM NIEL;
--HERE WE STORED DATA OF SELECT STATEMENT IN NIEL TEMPORARY.

WITH N1 AS (SELECT * FROM EMP),
     N2 AS (SELECT * FROM DEPT)
SELECT * FROM N1 INNER JOIN N2 ON N1.DEPTNO = N2.DEPTNO ;
--HERE WE MAKE JOIN USING WITH CLAUSE .

WITH N1 AS (SELECT * FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO)
SELECT * FROM N1;
--HERE WE RETRIVE DATA FROM WITH CLAUSE FROM JOIN .

WITH N1 AS (SELECT AVG(SAL) FROM EMP )
SELECT * FROM EMP WHERE SAL < (SELECT * FROM N1);
--HERE WE SEE THE LESS THAN SAL COMPARE TO AVARAGE SAL WHICH IS UNDER WITH CLAUSE.

SELECT ENAME FROM EMP WHERE SAL IN 
    (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
--THIS IS NORMAL SUBQUERY.

WITH N1 AS (SELECT ENAME FROM EMP WHERE SAL IN 
              (SELECT MAX (SAL)  FROM EMP GROUP BY DEPTNO))
SELECT * FROM  EMP WHERE ENAME IN (SELECT * FROM N1);     

--Q.LIST THE DEPARTMENT NAME , 1ST HIGHEST SAL , 2ND HIGHEST SAL, 3RD HIGHEST SAL ?
SELECT * FROM (
SELECT D.DNAME , E.SAL , DENSE_RANK () OVER (PARTITION BY E.DEPTNO ORDER BY SAL DESC ) AS DRNK 
        FROM EMP E INNER JOIN DEPT D
        ON E.DEPTNO = D.DEPTNO) WHERE DRNK BETWEEN 1 AND 3;
--HERE WE MAKE USING JOINS AND SUB QUERY .
--OR
WITH N1 AS (SELECT * FROM EMP),
      N2 AS (SELECT * FROM DEPT)
SELECT * FROM (SELECT DNAME , N1.DEPTNO,N1.SAL, DENSE_RANK () 
          OVER (PARTITION BY N1.DEPTNO ORDER BY N1.SAL DESC) AS DRNK 
          FROM N1 INNER JOIN N2 ON N1.DEPTNO = N2.DEPTNO) WHERE DRNK <=3;
--HERE WE USING WITH CLAUSE 

CREATE OR REPLACE VIEW  VW_DEPTWISE_T3 AS 
    WITH N1 AS (SELECT * FROM EMP),
          N2 AS (SELECT * FROM DEPT)
   SELECT DNAME,SAL, DENSE_RANK () OVER (PARTITION BY N1.DEPTNO ORDER BY SAL DESC) AS DRNK 
      FROM N1 INNER JOIN N2  
      ON N1.DEPTNO = N2.DEPTNO;
--HERE WE CREATE A VIEW USING WITH CLAUSE .

SELECT * FROM VW_DEPTWISE_T3;      

WITH N1 AS (SELECT DEPTNO, MAX (SAL) FROM EMP GROUP BY DEPTNO ) 
    SELECT * FROM N1 ORDER BY DEPTNO;
--DEPT WISE MAXSAL .
 
WITH N1 AS (SELECT  MGR FROM EMP WHERE MGR IS NOT NULL)
SELECT * FROM EMP WHERE EMPNO NOT IN (SELECT * FROM N1);
--NORMAL EMPLOYEE 

WITH N1 AS (SELECT DISTINCT COUNT(*) AS CNT, DEPTNO  FROM EMP GROUP BY DEPTNO)
      SELECT E.ENAME , N1.CNT, E.DEPTNO FROM EMP E JOIN N1  ON E.DEPTNO = N1.DEPTNO ORDER BY E.DEPTNO;
--DEPT WISE EMPLOYEE COUNT AND THEIR NAME .

WITH N1 AS (
SELECT DISTINCT DNAME , COUNT(*) OVER (PARTITION BY E.DEPTNO)  FROM EMP E INNER JOIN DEPT D 
ON E.DEPTNO = D.DEPTNO )
SELECT * FROM N1;
--USING WITH CLAUSE DNAME WISE EMP COUNT.

WITH D AS (SELECT * FROM DEPT ),
    S AS (SELECT * FROM SALGRADE)
SELECT * FROM EMP E INNER JOIN S  ON E.SAL BETWEEN S.LOSAL AND S.HISAL 
        INNER JOIN D ON E.DEPTNO = D.DEPTNO ORDER BY S.GRADE;     
--JOIN WITH MULTIPLE TABLE USING WITH CLAUSE.
--====================================================================================================
--                                            THANK YOU
--======================================================================================================
/
-- WM_CONCAT AND  LISTAGG :
--=========================
--WM_CONCAT :
--============
--WM_CONCAT IS AN AGGREGATE FUNCTION THAT RETURN VALUES FROM TABLES SEPARATED BY COMMA (,).

SELECT WM_CONCAT (SAL) FROM EMP;
--HERE WE SEE THE ALL DATA IN ROW BASIC .
--O/P:
800,1600,1250,2975,1250,2850,2450,3000,5000,1500,1100,950,3000,1300

SELECT DEPTNO , WM_CONCAT (SAL) FROM EMP GROUP BY DEPTNO;
--HERE WE SEE THE ALL DATA IN DEPTNO WISE ROW BASIC SAL.
--O/P:
10	2450,1300,5000
20	800,3000,1100,3000,2975
30	1600,950,1500,2850,1250,1250

SELECT DEPTNO, WM_CONCAT (SAL) FROM EMP WHERE DEPTNO = 10 GROUP BY DEPTNO ;
--ONLY DEPTNO 10 SAL WE SEE IN ROW BASIC 
--OP:
10	2450,1300,5000

SELECT DEPTNO, WM_CONCAT (ENAME) FROM EMP GROUP BY DEPTNO;
--HERE WE SEE DEPT WISE ENAME IN SINGLE ROW.

SELECT JOB , WM_CONCAT (ENAME) FROM EMP GROUP BY JOB;
--JOB WISE ENAME 

SELECT DNAME , WM_CONCAT(SAL) FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO GROUP BY DNAME;

--LISTAGG : 
--============
--IT WAS INTRODUCE IN ORACLE 12 VERSION .
--THE ORACLE LISTAGG () FUNCTION IS AN AGREEGATE FUNCTION THAT TRANSFORMS DATA MULTIPLE ROWS INTO A SINGLE LIST 
--                OF VALUES SEPARATED BY SEPCIFIED DELIMITER (, / # @ ....)
--WE CAN SIMPLY SAY IT CONCAT MULTIPLE ROWS IN A SINGLE ROWS.
--ORDER BY CLAUSE MANDATORY.
--BUT DELIMITER IS NOT MANDATORY.

SELECT DEPTNO, LISTAGG(SAL, ',')WITHIN GROUP (ORDER BY DEPTNO) AS EMPLOYEES FROM EMP GROUP BY DEPTNO;
--HERE WE SEE ALL SAL WITH THEIR DEPTNO IN ROW BASIC.
--OP:
10	1300,2450,5000
20	1100,2975,3000,3000,800
30	1250,1250,1500,1600,2850,950

SELECT DEPTNO, LISTAGG(SAL, '#') WITHIN GROUP (ORDER BY SAL) FROM EMP GROUP BY DEPTNO;
--HERE WE SEE ALL SAL IN ASC ORDER WITH THEIR DEPTNO.
--OP:
10	1300#2450#5000
20	800#1100#2975#3000#3000
30	950#1250#1250#1500#1600#2850

SELECT DEPTNO, LISTAGG (SAL, ',') WITHIN GROUP (ORDER BY SAL DESC ) FROM EMP GROUP BY DEPTNO;
--HERE WE SEE THE ALL DATA IN DESC ORDER WITH THEIR DEPTNO.
--OP :
10	5000,2450,1300
20	3000,3000,2975,1100,800
30	2850,1600,1500,1250,1250,950

SELECT DEPTNO , LISTAGG (SAL+500, ',') WITHIN GROUP (ORDER BY SAL) FROM EMP GROUP BY DEPTNO;
--WE CAN ALSO ARITHMATIC OPERATION DO HERE .
--OP :
10	1800,2950,5500
20	1300,1600,3475,3500,3500
30	1450,1750,1750,2000,2100,3350

SELECT DEPTNO , LISTAGG (SUBSTR (SAL, 1,1), '#') WITHIN GROUP (ORDER BY SAL DESC)
        FROM EMP GROUP BY DEPTNO;
--WE CAN ALSO USE ALL SINGLE ROW FUNCTION .

SELECT DEPTNO , SUM(SAL) FROM EMP GROUP BY DEPTNO;
--DEPT WISE SUM(SAL)
30	9400
20	10875
10	8750

SELECT SUM(DECODE (DEPTNO, 10, SAL)) AS "10",
        SUM(DECODE (DEPTNO, 20, SAL)) AS "20",
        SUM(DECODE (DEPTNO, 30, SAL)) AS "30" 
           FROM EMP;
--OP :
8750	10875	9400

/
--TASK 1:
--=========
--Q.DISPLAY DEPTNO, AND THEIR SAL IN ROW BASIC IN ASC ORDER ?
SELECT DEPTNO , LISTAGG (SAL, ',') WITHIN GROUP (ORDER BY SAL ) FROM EMP GROUP BY DEPTNO;

--TASK:2
--==========
--Q.DISPLAY DNAME WITH SAL IN A ROW BASIC (LISTAGG) ?
SELECT DNAME , LISTAGG( SAL, ',') WITHIN GROUP (ORDER BY SAL)
      FROM EMP E INNER JOIN DEPT D 
      ON E.DEPTNO = D.DEPTNO 
      GROUP BY DNAME;

--TASK :3
--==========
--Q.DNAME WITH TOP 3 SAL  ?
SELECT DNAME , LISTAGG(SAL, ',') WITHIN GROUP (ORDER BY SAL DESC) FROM (
      SELECT DNAME , SAL, DENSE_RANK () OVER (PARTITION BY DNAME ORDER BY SAL DESC) AS DR
       FROM EMP E , DEPT D WHERE E.DEPTNO = D.DEPTNO) WHERE DR<=3 GROUP BY DNAME  ;      
       
--===========================================================================================================       
--                                       THANK YOU 
--===========================================================================================================
/
--PIVOT :
--=========
--IT WAS INTRODUCE IN ORACLE 11.
--THIS CLAUSE IS ENABLES US TO FLIP THE ROWS IN TO COLUMNS IN THE O/P FROM A QUERY .
--IN THIS CLAUSE AGGREGATE FUNCTION MANDATORY.
--THIS CLAUSE IS USEFUL TO LOOK OVERALL DATA FROM HUGE RECORDS.

--SYNTAX :
--==========
--      SELECT * FROM 
--      (SELECT COL1, COL2 FROM TABLE_NAME WHERE CONDITIONS )
--      PIVOT 
--      (AGGREGATE_FUNCTION (COL2)
--           FOR COL2
--            IN (EXP1, EXP2...EXPN) | SUBQUERY )
--           ORDER BY EXPRESSION { ASC / DESC};

SELECT DEPTNO , SUM(SAL) FROM EMP GROUP BY ROLLUP( DEPTNO);
--OP:
10	8750
20	10875
30	9400
N	29025
  
SELECT SUM(DECODE(DEPTNO , 10, SAL)) AS "10 ",
        SUM(DECODE (DEPTNO, 20, SAL)) AS "20",
        SUM(DECODE (DEPTNO, 30, SAL)) AS "30",
        SUM(DECODE (DEPTNO, DEPTNO, SAL))AS GRAND FROM EMP;
--OP :
8750	10875	9400	29025

SELECT * FROM (
                SELECT DEPTNO AS DEPT, SAL FROM EMP
              )
          PIVOT (SUM(SAL) FOR DEPT IN (10,20,30) );
--HERE WE GET THE SUM(SAL) DEPT WISE ROW BASIC .  
--OP :
10,     20,   30
8750	10875	9400

SELECT * FROM 
        (SELECT DEPTNO , SAL FROM EMP)
        PIVOT (MAX(SAL) AS DEPT FOR DEPTNO IN (10,20,30));
--HERE WE GET THE MAX(SAL) DEPT WISE ROW BASIC.

--Q.DISPLAY DEPTNO WITH THEIR DNAME USING PIVOT ?
SELECT * FROM (SELECT DEPTNO, DNAME FROM DEPT) 
        PIVOT (MAX(DNAME) FOR DEPTNO IN (10,20,30,40) );

--Q.DISPLAY HOW MANY EMPLOYEE WORKING IN JOB, DEPTNO WISE USING PIVOT ?
SELECT * FROM 
        (SELECT JOB, DEPTNO FROM EMP)
        PIVOT (COUNT(*) FOR DEPTNO IN (10,20,30,40));

--Q.DISPLAY HOW MANY EMPLOYEE WORK IN DEPTNO , JOB WISE AND THEIR SUM (SAL) USING PIVOT?
WITH N1 AS (SELECT JOB, DEPTNO , SAL FROM EMP)
SELECT * FROM N1
      PIVOT (COUNT(*) AS CNT , 
              SUM(SAL) AS SM_SAL FOR DEPTNO IN (10,20,30,40));
        

--TASK : 4
--==========
--  10    20    30    TOTAL
--  8750  10875 9400  29025

WITH N1 AS  (SELECT SUM(SAL) FROM EMP)
SELECT E.*, (SELECT * FROM N1) TOTAL FROM (SELECT DEPTNO , SAL  FROM EMP )
          PIVOT (SUM(SAL) FOR DEPTNO IN (10 AS D10,20 AS D20,30 AS D30)) E;
          
--TASK : 5
--==========
--Q. LOCATION WISE EMPLOYEE COUNT USING PIVOT ?
SELECT * FROM (SELECT DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO)
          PIVOT (COUNT(*) FOR DNAME IN ('ACCOUNTING' AS ACCOUNTING, 'RESEARCH' AS RESEARCH,
                                        'SALES' AS SALES,'OPERATIONS' AS OPERATIONS ));
          
--UNPIVOT :
--==========
--IT WAS INTRODUCE IN ORACLE 11.
--THIS CLAUSE IS ENABLES US TO FLIP THE COLUMNS IN TO ROWS IN THE O/P FROM A QUERY .
--HERE DATATYPE SHOULD MATCH IT'S MANDATORY .

--SYNTAX :
--==========
--      SELECT < SELECT_LIST > FROM < TABLE_NAME >
--      UNPIVOT < COLUMN_NAME >

SELECT * FROM 
        (SELECT 'HII' AS C1,
                'THIS' AS C2,
                'NIEL' AS C3 FROM DUAL)
            UNPIVOT (COL_VAL FOR COL_NAME IN (C1, C2, C3));
--WHICH DATA AFTER IN OPERATOR IS SPECIFY COLUMN_NAME BEFORE IN OPERATOR.    
--WHICH COLUMN NAME SPECIFY IN SELECT STATEMENT THEY ARE UNDER AFTER UNPIVOT COLUMN_NAME. 
          
SELECT EMPNO, ENAME , JOB FROM EMP WHERE EMPNO IN (7839, 7499);
--HERE WE SEE THE OP IN COLUMN BASIC.

SELECT EMPNO, DTL , DETAILS FROM EMP
      UNPIVOT (DETAILS FOR DTL IN (ENAME , JOB)) ;
      
SELECT EMPNO, N1, N2 FROM EMP
      UNPIVOT (N2 FOR N1 IN (ENAME , JOB));
      
SELECT ENAME , DTL, DETAILS FROM EMP 
      UNPIVOT (DETAILS FOR DTL IN (SAL, COMM));
      
SELECT ENAME, EMPNO, DTL , DETAILS FROM EMP
      UNPIVOT (DETAILS FOR (DTL) IN 
        (MGR , SAL, COMM)) WHERE EMPNO IN (7839,7499)
        ORDER BY EMPNO;
--OP :
ALLEN	7499	MGR	7698
ALLEN	7499	SAL	1600
ALLEN	7499	COMM	300
KING	7839	SAL	5000
